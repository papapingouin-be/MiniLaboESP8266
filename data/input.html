<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Configuration des IO – MiniLabo</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding-bottom: 3rem;
    }

    nav.quick-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    nav.quick-links a {
      background: #eef3ff;
      border-radius: 999px;
      color: #1f3d7a;
      padding: 0.4rem 0.9rem;
      text-decoration: none;
      font-weight: 600;
      border: 1px solid #b7c5ff;
    }

    .io-layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(280px, 2fr);
      gap: 1.75rem;
      align-items: start;
    }

    table#ioTable {
      width: 100%;
      border-collapse: collapse;
    }

    table#ioTable th,
    table#ioTable td {
      border: 1px solid #c8d2e0;
      padding: 0.4rem 0.6rem;
    }

    table#ioTable tbody tr.selected {
      outline: 2px solid #0059ff;
      outline-offset: -2px;
      background: #f0f5ff;
    }

    table#ioTable tbody tr:hover {
      background: #f7faff;
    }

    td input[readonly] {
      background: #f8f9fc;
      border: none;
      font-weight: 600;
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .panel {
      background: #f7f9fc;
      border: 1px solid #d7deea;
      border-radius: 12px;
      padding: 1.2rem 1.5rem;
    }

    .panel h2 {
      margin-top: 0;
    }

    .panel ul {
      margin: 0.5rem 0 0.25rem;
    }

    .typology-grid {
      display: grid;
      gap: 1.25rem;
    }

    .typology-grid article {
      background: #fff;
      border: 1px solid #dbe3f6;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
    }

    .typology-grid h3 {
      margin-top: 0;
    }

    details.typology-details {
      background: #fff;
      border-radius: 10px;
      border: 1px solid #ccd8ef;
      padding: 0.8rem 1rem;
    }

    details.typology-details + details.typology-details {
      margin-top: 0.75rem;
    }

    details.typology-details summary {
      cursor: pointer;
      font-weight: 600;
      color: #1c317a;
    }

    .assistant-section form {
      display: grid;
      gap: 0.75rem;
    }

    .assistant-section label {
      display: flex;
      flex-direction: column;
      font-size: 0.95rem;
      gap: 0.25rem;
    }

    .assistant-section input,
    .assistant-section select {
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      border: 1px solid #c7d2e5;
    }

    .assistant-section button {
      justify-self: flex-start;
    }

    .assistant-section .udp-panel {
      border-top: 1px solid #d7deea;
      margin-top: 1.25rem;
      padding-top: 1rem;
      display: grid;
      gap: 0.65rem;
    }

    .udp-scan-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .udp-scan-status {
      font-size: 0.85rem;
      color: #53618c;
    }

    .udp-devices {
      display: grid;
      gap: 0.75rem;
    }

    .udp-device {
      border: 1px solid #ccd8ef;
      border-radius: 10px;
      padding: 0.75rem 0.9rem;
      background: #fff;
      display: grid;
      gap: 0.5rem;
      box-shadow: 0 2px 4px rgba(31, 61, 122, 0.05);
    }

    .udp-device h4 {
      margin: 0;
      font-size: 1rem;
      color: #1c317a;
    }

    .udp-device .udp-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1rem;
      font-size: 0.85rem;
      color: #51607f;
    }

    .udp-device-inputs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .udp-device-inputs button {
      border: 1px solid #b0c2ef;
      background: #f3f6ff;
      color: #1c317a;
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border 0.15s ease;
    }

    .udp-device-inputs button:hover:not(.selected) {
      background: #e3eaff;
    }

    .udp-device-inputs button.selected {
      background: #1f3d7a;
      border-color: #1f3d7a;
      color: #fff;
    }

    .udp-device-inputs button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .udp-device-empty {
      font-size: 0.85rem;
      color: #6a7998;
      font-style: italic;
    }

    .assistant-result {
      background: #fff;
      border: 1px dashed #a3b3d4;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      font-family: "Courier New", monospace;
      white-space: pre-wrap;
    }

    .legend {
      font-size: 0.9rem;
      color: #304160;
    }

    .highlight {
      font-weight: 600;
      color: #214bb8;
    }

    details.collapsible-toggle {
      background: #f1f4fb;
      border: 1px solid #d7deea;
      border-radius: 12px;
      padding: 0.75rem 1rem;
    }

    details.collapsible-toggle > summary {
      cursor: pointer;
      font-weight: 600;
      color: #1f3d7a;
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    details.collapsible-toggle > summary::-webkit-details-marker {
      display: none;
    }

    details.collapsible-toggle > summary::before {
      content: '\\25B8';
      transition: transform 0.2s ease;
      font-size: 0.85rem;
    }

    details.collapsible-toggle[open] > summary::before {
      transform: rotate(90deg);
    }

    details.collapsible-toggle .collapsible-content {
      margin-top: 0.75rem;
      display: grid;
      gap: 0.75rem;
    }

    section.panel.collapsible details.collapsible-toggle {
      background: transparent;
      border: none;
      padding: 0;
    }

    section.panel.collapsible details.collapsible-toggle .collapsible-content {
      margin-top: 1rem;
    }

    section.panel.collapsible {
      padding-bottom: 0.5rem;
    }

    table#ioTable td[data-field="raw"],
    table#ioTable td[data-field="value"] {
      font-family: "Courier New", monospace;
      text-align: right;
      white-space: nowrap;
    }

    table#ioTable td[data-field="raw"] span,
    table#ioTable td[data-field="value"] span {
      display: inline-block;
      min-width: 4.5rem;
    }

    .log-panel {
      display: grid;
      gap: 0.75rem;
    }

    .log-output {
      background: #101a33;
      border: 1px solid #1f2f55;
      border-radius: 10px;
      color: #e7efff;
      font-family: "Courier New", monospace;
      font-size: 0.85rem;
      line-height: 1.35;
      max-height: 280px;
      overflow-y: auto;
      padding: 0.75rem 0.9rem;
      white-space: pre-wrap;
    }

    .log-entry {
      margin: 0;
    }

    .log-entry + .log-entry {
      margin-top: 0.35rem;
    }

    .log-entry .log-time {
      color: #9db7ff;
    }

    .log-entry.info .log-message {
      color: #e7efff;
    }

    .log-entry.success .log-message {
      color: #9df4c2;
    }

    .log-entry.warn .log-message {
      color: #ffd66b;
    }

    .log-entry.error .log-message {
      color: #ff9a9a;
    }

    @media (max-width: 900px) {
      .io-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <h1>Configuration des entrées/sorties</h1>
  <details class="collapsible-toggle">
    <summary>Afficher les informations générales</summary>
    <div class="collapsible-content">
      <p>Cette page centralise la typologie des entrées/sorties du MiniLabo et propose des outils de calibration. Sélectionnez un
      canal dans le tableau, puis utilisez l’assistant pour calculer la conversion entre la grandeur électrique mesurée et la
      grandeur physique souhaitée.</p>
      <p>Les sections d’aide détaillées sont repliées par défaut pour alléger l’écran. Ouvrez-les au besoin pour retrouver la
      documentation complète.</p>
    </div>
  </details>

  <nav class="quick-links">
    <a href="#typologie-entrees">Entrées</a>
    <a href="#typologie-sorties">Sorties</a>
    <a href="outputs.html">Configurer les sorties</a>
    <a href="#udp">Serveur&nbsp;UDP</a>
    <a href="#configuration">Table de configuration</a>
    <a href="#assistant">Assistant de calibration</a>
  </nav>

  <section id="typologie-entrees" class="panel collapsible">
    <details class="collapsible-toggle">
      <summary>Typologie des entrées</summary>
      <div class="collapsible-content">
        <p>Une entrée convertit un signal en une valeur exploitable par les outils web (oscilloscope, DMM, scripts math, UDP). Les
        entrées peuvent être locales (connectées directement à l’ESP8266) ou déportées (reçues via le réseau).</p>
        <div class="typology-grid">
          <article>
            <h3>Entrées réelles locales</h3>
            <ul>
              <li><span class="highlight">ADC interne (A0)</span> : 10 bits, 0–1 V natif (0–3,3 V avec diviseur intégré sur NodeMCU).</li>
              <li><span class="highlight">ADS1115 (I²C)</span> : module 16 bits avec amplification programmable, idéal pour les mesures fines.</li>
              <li><span class="highlight">ZMPT101B</span> : transformateur de tension AC, sortie 0–3,3 V, 10 bits.</li>
              <li><span class="highlight">ZMCT103C</span> : transformateur de courant AC, tension de sortie proportionnelle.</li>
            </ul>
          </article>
          <article>
            <h3>Entrées déportées</h3>
            <p>Les valeurs proviennent d’autres modules (ESP8266/ESP32) ou d’un PC via UDP. Elles complètent la configuration locale et
            sont intégrées aux mêmes outils de visualisation.</p>
            <ul>
              <li>Permet de centraliser des mesures distantes dans un seul MiniLabo.</li>
              <li>Chaque flux UDP est identifié par un nom de canal (ID) repris dans le tableau de configuration.</li>
              <li>La normalisation k/b peut s’appliquer comme pour les entrées réelles.</li>
            </ul>
          </article>
        </div>
      </div>
    </details>
  </section>

  <section id="typologie-sorties" class="panel collapsible">
    <details class="collapsible-toggle">
      <summary>Typologie des sorties</summary>
      <div class="collapsible-content">
        <div class="typology-grid">
          <article>
            <h3>Sorties réelles</h3>
            <ul>
              <li><span class="highlight">MCP4725 (DAC 12 bits)</span> : conversion en tension 0–3,3 V proportionnelle au pourcentage demandé.</li>
              <li><span class="highlight">Convertisseur PWM → 0–10 V</span> : interface pour actionneurs industriels ou drivers de LED.</li>
            </ul>
          </article>
          <article>
            <h3>Stratégies d’utilisation</h3>
            <ul>
              <li>Associez chaque sortie à l’entrée ou au calcul math correspondant (PID, consigne, etc.).</li>
              <li>Définissez une conversion inverse (grandeur physique → tension) via les coefficients k/b.</li>
              <li>Utilisez les outils math pour générer des profils de sortie ou automatiser des séquences.</li>
            </ul>
          </article>
        </div>
      </div>
    </details>
  </section>

  <section id="udp" class="panel collapsible">
    <details class="collapsible-toggle">
      <summary>Serveur UDP</summary>
      <div class="collapsible-content">
        <p>Le MiniLabo peut diffuser ses valeurs sur le réseau via <span class="highlight">UDP TX</span>. Toute valeur convertie (après k/b)
        peut être publiée vers un autre MiniLabo ou un PC pour être affichée, enregistrée ou réinjectée dans une boucle d’asservissement.</p>
        <ul class="legend">
          <li>Utilisez le champ <em>type</em> pour distinguer les canaux UDP entrants (« udp-in ») et sortants (« udp-out »).</li>
          <li>Configurez les paramètres réseau dans l’onglet <a href="udp.html">UDP</a> puis associez le canal dans cette page.</li>
          <li>Le statut du flux est visible dans la page <a href="logs.html">Logs</a> et dans l’onglet réseau.</li>
        </ul>
      </div>
    </details>
  </section>

  <div class="io-layout" id="configuration">
    <section>
      <h2>Table de configuration des canaux</h2>
      <p>Sélectionnez une ligne pour la relier aux outils de calibration. Les colonnes <em>k</em> et <em>b</em> définissent la relation
      <code>valeur_physique = k × mesure + b</code>.</p>
      <table id="ioTable">
        <thead>
          <tr>
            <th>ID</th>
            <th>Type</th>
            <th>Index</th>
            <th>k</th>
            <th>b</th>
            <th>Mesure brute</th>
            <th>Valeur calculée</th>
            <th>Unité</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
      <datalist id="channelTypeOptions"></datalist>
      <div class="actions">
        <button type="button" onclick="addRow()">Ajouter une ligne</button>
        <button type="button" onclick="refresh()">Rafraîchir</button>
        <button type="button" onclick="save()">Enregistrer</button>
      </div>
      <p id="status"></p>
      <section class="panel log-panel">
        <h2>Journal de configuration</h2>
        <p class="legend">Les étapes s’affichent ici pour faciliter le diagnostic en cas de blocage.</p>
        <div class="log-output" id="logOutput" aria-live="polite"></div>
        <div class="actions">
          <button type="button" onclick="clearLog()">Effacer le journal</button>
        </div>
      </section>
    </section>

    <aside id="assistant" class="panel assistant-section">
      <h2>Assistant de calibration</h2>
      <p class="legend">Ligne sélectionnée : <span id="selectedChannel">aucune</span></p>
      <form onsubmit="event.preventDefault(); computeCalibration();">
        <label>
          Profil matériel
          <select id="hardwareProfile"></select>
        </label>
        <label>
          Mesure min (valeur brute)
          <input type="number" id="rawMin" step="any" value="0">
        </label>
        <label>
          Mesure max (valeur brute)
          <input type="number" id="rawMax" step="any" value="1023">
        </label>
        <label>
          Grandeur physique min
          <input type="number" id="physMin" step="any" value="0">
        </label>
        <label>
          Grandeur physique max
          <input type="number" id="physMax" step="any" value="1">
        </label>
        <button type="submit">Calculer k &amp; b</button>
      </form>
      <div class="assistant-result" id="assistantResult">Complétez les champs ci-dessus pour obtenir la formule.</div>
      <div class="actions">
        <button type="button" onclick="applyToSelection()">Appliquer à la ligne sélectionnée</button>
        <button type="button" onclick="resetAssistant()">Réinitialiser</button>
      </div>
      <details class="typology-details" open>
        <summary>Astuces de conversion</summary>
        <ul>
          <li>Pour un capteur linéaire 0–10 V relié à l’ADS1115 : mesure min = 0, mesure max = 32767 (16 bits), grandeur max = 10.</li>
          <li>Pour un transformateur ZMPT101B : renseignez les valeurs RMS attendues (ex. 0 V ↔ 0 V, 230 V ↔ 1,65 V).</li>
          <li>Pour une entrée UDP représentant un pourcentage : mesure min = 0, max = 100, grandeur max = 1 (pour normaliser).</li>
        </ul>
      </details>
      <section id="udpInputPanel" class="udp-panel" hidden>
        <h3>Entrée UDP distante</h3>
        <p class="legend">Associez une valeur émise par un autre module MiniLabo ou une application PC.</p>
        <div class="udp-scan-actions">
          <button type="button" id="udpScanButton">Scanner le réseau</button>
          <span id="udpScanStatus" class="udp-scan-status"></span>
        </div>
        <p id="udpSelectionSummary" class="legend">Sélectionnez une ligne de type « udp-in » pour configurer la source distante.</p>
        <div id="udpDevicesList" class="udp-devices"></div>
      </section>
    </aside>
  </div>

  <section class="panel">
    <h2>FAQ express</h2>
    <details class="typology-details">
      <summary>Comment déterminer k et b ?</summary>
      <p>Mesurez deux points de référence (min et max) ou utilisez la fiche technique du capteur. L’assistant calcule automatiquement<br>
      <code>k = (physMax − physMin) / (rawMax − rawMin)</code> et <code>b = physMin − k × rawMin</code>.</p>
    </details>
    <details class="typology-details">
      <summary>Que signifie l’index ?</summary>
      <p>Il s’agit du canal physique ou logique. Pour l’ADC interne, l’index est souvent 0. Pour l’ADS1115, utilisez l’entrée A0–A3.
      Pour l’UDP, l’index correspond au port logique défini dans la configuration réseau.</p>
    </details>
    <details class="typology-details">
      <summary>Comment créer une chaîne complète mesure → actionneur ?</summary>
      <p>1) Configurez l’entrée et normalisez-la.<br>2) Utilisez l’onglet <a href="math.html">Math</a> pour appliquer un traitement ou un
      contrôle.<br>3) Mappez le résultat sur une sortie dans cette page et, si besoin, diffusez-le via UDP.</p>
    </details>
  </section>

  <script>
  const hardwareProfiles = [
    {
      id: 'adc',
      name: 'ADC interne (A0)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Entrée 0–1 V (ou 0–3,3 V avec diviseur).'
    },
    {
      id: 'ads1115',
      name: 'ADS1115 (gain ±4.096 V)',
      bits: 16,
      rawMin: 0,
      rawMax: 32767,
      description: '16 bits, utilisez le gain selon votre montage.'
    },
    {
      id: 'zmpt101b',
      name: 'ZMPT101B (0–3,3 V)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Transformateur de tension AC.'
    },
    {
      id: 'zmct103c',
      name: 'ZMCT103C (sortie AC)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Transformateur de courant AC.'
    },
    {
      id: 'udp',
      name: 'Entrée UDP personnalisée',
      bits: 16,
      rawMin: 0,
      rawMax: 1,
      description: 'Adapter les bornes selon la source distante.'
    }
  ];

  const DEFAULT_LOCAL_INPUTS = [
    {
      type: 'a0',
      label: 'ADC interne A0',
      defaultId: 'A0',
      defaultUnit: 'V',
      indexes: [{ value: 0, label: 'A0' }]
    }
  ];
  const EXTRA_TYPES = [
    { type: 'udp-in', label: 'UDP entrant' },
    { type: 'udp-out', label: 'UDP sortant' },
    { type: 'udp', label: 'UDP' },
    { type: 'math', label: 'Calcul mathématique' }
  ];
  const TYPE_DATALIST_ID = 'channelTypeOptions';

  let selectedRow = null;
  let lastComputation = null;
  let capabilities = { localInputs: DEFAULT_LOCAL_INPUTS.map(normalizeLocalInput) };
  let hardwarePromise = null;
  let snapshotTimer = null;
  let latestSnapshotRaw = new Map();
  const LOG_MAX_ENTRIES = 200;
  let logEntries = [];
  let snapshotLogCount = 0;
  let snapshotErrorNotified = false;
  const UDP_TYPES = new Set(['udp', 'udp-in', 'udp-out']);
  const UDP_PANEL_TYPES = new Set(['udp', 'udp-in']);
  let udpScanResults = [];
  let udpScanInProgress = false;

  function isUdpType(value) {
    if (!value) return false;
    return UDP_TYPES.has(String(value).trim().toLowerCase());
  }

  function isUdpPanelType(value) {
    if (!value) return false;
    return UDP_PANEL_TYPES.has(String(value).trim().toLowerCase());
  }

  function isUdpHardwareProfileSelected() {
    const select = document.getElementById('hardwareProfile');
    if (!select) return false;
    return select.value === 'udp';
  }

  function getRowRemote(tr) {
    if (!tr || !tr.dataset) return null;
    if (!Object.prototype.hasOwnProperty.call(tr.dataset, 'remote')) return null;
    const raw = tr.dataset.remote;
    if (!raw || !raw.length) return null;
    try {
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : null;
    } catch (err) {
      return null;
    }
  }

  function setRowRemote(tr, remote) {
    if (!tr || !tr.dataset) return;
    if (remote && typeof remote === 'object') {
      try {
        tr.dataset.remote = JSON.stringify(remote);
      } catch (err) {
        tr.dataset.remote = '';
      }
    } else if (Object.prototype.hasOwnProperty.call(tr.dataset, 'remote')) {
      delete tr.dataset.remote;
    }
  }

  function remoteMatchesSelection(remote, device, input) {
    if (!remote || typeof remote !== 'object') return false;
    if (!device || typeof device !== 'object') return false;
    if (!input || typeof input !== 'object') return false;
    const remoteId = remote.channelId || remote.channelLabel || '';
    const inputId = input.id || input.label || '';
    if (!remoteId || !inputId) return false;
    const remoteMac = remote.mac ? String(remote.mac).toLowerCase() : '';
    const deviceMac = device.mac ? String(device.mac).toLowerCase() : '';
    const sameMac = remoteMac.length && deviceMac.length && remoteMac === deviceMac;
    const sameIp = remote.ip && device.ip && remote.ip === device.ip;
    return (sameMac || sameIp) && remoteId === inputId;
  }

  function formatRemoteSummary(remote) {
    if (!remote || typeof remote !== 'object') {
      return 'Aucune entrée distante sélectionnée.';
    }
    const parts = [];
    if (remote.channelId) {
      parts.push(`Canal ${remote.channelId}`);
    } else if (remote.channelLabel) {
      parts.push(`Canal ${remote.channelLabel}`);
    }
    if (remote.hostname) {
      parts.push(remote.hostname);
    } else if (remote.mac) {
      parts.push(remote.mac);
    }
    if (remote.ip) {
      parts.push(remote.ip);
    }
    if (!parts.length) {
      return 'Aucune entrée distante sélectionnée.';
    }
    return parts.join(' · ');
  }

  function renderUdpDevices(devices, selectedRemote) {
    const container = document.getElementById('udpDevicesList');
    if (!container) return;
    container.innerHTML = '';
    if (!Array.isArray(devices) || !devices.length) {
      container.innerHTML = '<p class="legend">Aucun module détecté pour le moment.</p>';
      return;
    }
    devices.forEach(device => {
      if (!device || typeof device !== 'object') return;
      const card = document.createElement('article');
      card.className = 'udp-device';
      const title = document.createElement('h4');
      const titleCandidates = [device.hostname, device.mac, device.ip, 'Module UDP'];
      const chosen = titleCandidates.find(entry => typeof entry === 'string' && entry.trim().length);
      title.textContent = chosen ? chosen : 'Module UDP';
      card.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'udp-meta';
      const ipSpan = document.createElement('span');
      ipSpan.textContent = `IP : ${device.ip || '—'}`;
      meta.appendChild(ipSpan);
      if (device.mac) {
        const macSpan = document.createElement('span');
        macSpan.textContent = `MAC : ${device.mac}`;
        meta.appendChild(macSpan);
      }
      const rxPort = device.rx_port ?? device.rxPort;
      if (Number.isFinite(rxPort) && rxPort > 0) {
        const portSpan = document.createElement('span');
        portSpan.textContent = `Port UDP : ${rxPort}`;
        meta.appendChild(portSpan);
      }
      card.appendChild(meta);

      const inputsWrap = document.createElement('div');
      inputsWrap.className = 'udp-device-inputs';
      const inputs = Array.isArray(device.inputs) ? device.inputs : [];
      if (!inputs.length) {
        const empty = document.createElement('p');
        empty.className = 'udp-device-empty';
        empty.textContent = 'Aucune entrée distante publiée.';
        inputsWrap.appendChild(empty);
      } else {
        inputs.forEach(input => {
          if (!input || typeof input !== 'object') return;
          const btn = document.createElement('button');
          btn.type = 'button';
          const label = input.id || input.label || input.type || 'Entrée';
          const unitSuffix = input.unit ? ` (${input.unit})` : '';
          btn.textContent = `${label}${unitSuffix}`;
          if (remoteMatchesSelection(selectedRemote, device, input)) {
            btn.classList.add('selected');
          }
          btn.addEventListener('click', () => {
            if (!selectedRow) {
              logEvent('Sélectionnez d’abord une ligne dans la table.', 'warn');
              return;
            }
            applyRemoteSelection(selectedRow, device, input);
          });
          inputsWrap.appendChild(btn);
        });
      }
      card.appendChild(inputsWrap);
      container.appendChild(card);
    });
  }

  async function scanUdpDevices() {
    if (udpScanInProgress) {
      return;
    }
    const statusEl = document.getElementById('udpScanStatus');
    udpScanInProgress = true;
    if (statusEl) {
      statusEl.textContent = 'Scan en cours...';
    }
    try {
      const res = await fetch('/api/udp/discover');
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      const data = await res.json();
      udpScanResults = Array.isArray(data.devices) ? data.devices : [];
      const status = typeof data.status === 'string' ? data.status : '';
      if (statusEl) {
        if (status === 'udp_disabled' || status === 'udp_unavailable') {
          statusEl.textContent = 'Le service UDP est désactivé sur ce module.';
        } else if (!udpScanResults.length) {
          statusEl.textContent = 'Aucun module détecté.';
        } else {
          statusEl.textContent = `Modules détectés : ${udpScanResults.length}`;
        }
      }
      if (selectedRow) {
        updateUdpPanelContext(selectedRow);
      } else {
        renderUdpDevices(udpScanResults, null);
      }
      if (udpScanResults.length) {
        logEvent(`Scan UDP terminé : ${udpScanResults.length} module(s) détecté(s).`, 'success');
      } else if (status !== 'udp_disabled' && status !== 'udp_unavailable') {
        logEvent('Scan UDP terminé : aucun module détecté.', 'info');
      }
    } catch (err) {
      const reason = err && err.message ? err.message : String(err);
      if (statusEl) {
        statusEl.textContent = `Erreur lors du scan : ${reason}`;
      }
      logEvent(`Erreur lors du scan UDP : ${reason}`, 'error');
    } finally {
      udpScanInProgress = false;
    }
  }

  function updateUdpPanelContext(tr) {
    const panel = document.getElementById('udpInputPanel');
    const summaryEl = document.getElementById('udpSelectionSummary');
    const statusEl = document.getElementById('udpScanStatus');
    if (!panel) return;
    if (!isUdpHardwareProfileSelected()) {
      panel.hidden = true;
      if (summaryEl) {
        summaryEl.textContent = 'Sélectionnez le profil matériel « Entrée UDP personnalisée » pour configurer une source distante.';
      }
      if (statusEl && !udpScanInProgress) {
        statusEl.textContent = '';
      }
      return;
    }
    if (!tr) {
      panel.hidden = true;
      if (summaryEl) {
        summaryEl.textContent = 'Sélectionnez une ligne de type « udp-in » pour configurer la source distante.';
      }
      if (statusEl && udpScanResults.length === 0 && !udpScanInProgress) {
        statusEl.textContent = '';
      }
      return;
    }
    const typeInput = tr.querySelector('td[data-field="type"] input');
    const typeValue = typeInput ? typeInput.value.trim().toLowerCase() : '';
    if (!isUdpPanelType(typeValue)) {
      panel.hidden = true;
      if (summaryEl) {
        summaryEl.textContent = 'Sélectionnez une ligne de type « udp-in » pour configurer la source distante.';
      }
      return;
    }
    panel.hidden = false;
    const remote = getRowRemote(tr);
    if (summaryEl) {
      summaryEl.textContent = formatRemoteSummary(remote);
    }
    if (udpScanInProgress && statusEl) {
      statusEl.textContent = 'Scan en cours...';
    } else if (statusEl && !udpScanResults.length) {
      statusEl.textContent = 'Aucun module détecté pour le moment.';
    }
    renderUdpDevices(udpScanResults, remote);
  }

  function applyRemoteSelection(tr, device, input) {
    if (!tr || !device || !input) return;
    const typeInput = tr.querySelector('td[data-field="type"] input');
    if (typeInput) {
      typeInput.value = 'udp-in';
      handleTypeChange(tr, typeInput, { forceUnit: false });
    }
    const remoteInfo = {
      ip: device.ip || '',
      mac: device.mac || '',
      hostname: device.hostname || '',
      rxPort: device.rx_port ?? device.rxPort ?? 0,
      txPort: device.tx_port ?? device.txPort ?? 0,
      channelId: input.id || input.label || '',
      channelLabel: input.label || input.id || '',
      channelType: input.type || '',
      channelIndex: Number.isFinite(input.index) ? input.index : 0,
      channelUnit: input.unit || ''
    };
    setRowRemote(tr, remoteInfo);
    const indexEditor = tr.querySelector('td[data-field="index"] select, td[data-field="index"] input');
    if (indexEditor) {
      indexEditor.value = String(remoteInfo.channelIndex || 0);
      indexEditor.dispatchEvent(new Event('input', { bubbles: true }));
      indexEditor.dispatchEvent(new Event('change', { bubbles: true }));
    }
    const unitInput = tr.querySelector('td[data-field="unit"] input');
    if (unitInput && (unitInput.dataset.autofill !== 'false' || !unitInput.value.trim().length)) {
      unitInput.value = remoteInfo.channelUnit || unitInput.value;
      unitInput.dataset.autofill = remoteInfo.channelUnit ? 'true' : unitInput.dataset.autofill;
    }
    if (selectedRow === tr) {
      updateUdpPanelContext(tr);
    }
    const labelParts = [];
    if (remoteInfo.channelId) labelParts.push(remoteInfo.channelId);
    if (remoteInfo.hostname) labelParts.push(remoteInfo.hostname);
    else if (remoteInfo.mac) labelParts.push(remoteInfo.mac);
    if (remoteInfo.ip) labelParts.push(remoteInfo.ip);
    logEvent(`Entrée UDP associée à ${labelParts.join(' · ') || 'une source distante'}.`, 'info');
  }

  function populateProfiles() {
    const select = document.getElementById('hardwareProfile');
    select.innerHTML = '';
    hardwareProfiles.forEach(profile => {
      const option = document.createElement('option');
      option.value = profile.id;
      option.textContent = profile.name;
      option.dataset.rawMin = profile.rawMin;
      option.dataset.rawMax = profile.rawMax;
      option.title = profile.description;
      select.appendChild(option);
    });
    if (hardwareProfiles.length) {
      const first = hardwareProfiles[0];
      document.getElementById('rawMin').value = first.rawMin;
      document.getElementById('rawMax').value = first.rawMax;
    }
    select.addEventListener('change', event => {
      const option = event.target.selectedOptions[0];
      if (!option) return;
      document.getElementById('rawMin').value = option.dataset.rawMin;
      document.getElementById('rawMax').value = option.dataset.rawMax;
      updateUdpPanelContext(selectedRow);
    });
    updateUdpPanelContext(selectedRow);
  }

  function normalizeLocalInput(entry) {
    const source = entry && typeof entry === 'object' ? entry : {};
    const type =
      typeof source.type === 'string' && source.type.trim().length
        ? source.type.trim()
        : 'a0';
    const label =
      typeof source.label === 'string' && source.label.trim().length
        ? source.label.trim()
        : type.toUpperCase();
    const defaultId =
      typeof source.defaultId === 'string' && source.defaultId.trim().length
        ? source.defaultId.trim()
        : label.replace(/\s+/g, '');
    const defaultUnit =
      typeof source.defaultUnit === 'string' ? source.defaultUnit : '';
    const indexes = [];
    if (Array.isArray(source.indexes) && source.indexes.length) {
      const seen = new Set();
      source.indexes.forEach(item => {
        if (!item) return;
        const numeric = Number(item.value);
        const value = Number.isFinite(numeric)
          ? numeric
          : Number(parseInt(item.value, 10));
        const indexValue = Number.isFinite(value) ? value : 0;
        if (seen.has(indexValue)) return;
        seen.add(indexValue);
        const labelText =
          typeof item.label === 'string' && item.label.trim().length
            ? item.label.trim()
            : String(indexValue);
        indexes.push({ value: indexValue, label: labelText });
      });
    }
    if (!indexes.length) {
      indexes.push({ value: 0, label: '0' });
    }
    return { type, label, defaultId, defaultUnit, indexes };
  }

  function ensureHardwareCapabilities() {
    if (!hardwarePromise) {
      hardwarePromise = fetchHardwareCapabilities();
    }
    return hardwarePromise;
  }

  async function fetchHardwareCapabilities() {
    logEvent('Détection des capacités matérielles...', 'info');
    let locals = [];
    let hadNetworkError = false;
    try {
      const res = await fetch('/api/io/hardware');
      if (res.ok) {
        const data = await res.json();
        if (data && Array.isArray(data.localInputs) && data.localInputs.length) {
          locals = data.localInputs.map(normalizeLocalInput);
        }
      } else {
        hadNetworkError = true;
        logEvent(`Lecture des capacités matérielles impossible (statut ${res.status}).`, 'warn');
      }
    } catch (err) {
      hadNetworkError = true;
      const reason = err && err.message ? err.message : String(err);
      logEvent(`Erreur lors de la récupération des capacités matérielles : ${reason}`, 'warn');
    }
    if (!locals.length) {
      locals = DEFAULT_LOCAL_INPUTS.map(normalizeLocalInput);
      if (hadNetworkError) {
        logEvent('Utilisation des profils par défaut (capteurs matériels non détectés).', 'warn');
      } else {
        logEvent('Aucun profil spécifique détecté, utilisation des valeurs par défaut.', 'info');
      }
    } else {
      logEvent(`Capacités matérielles chargées (${locals.length} profil(s)).`, 'success');
    }
    capabilities.localInputs = locals;
    updateTypeDatalist();
    return capabilities;
  }

  function updateTypeDatalist() {
    const datalist = document.getElementById(TYPE_DATALIST_ID);
    if (!datalist) return;
    datalist.innerHTML = '';
    const seen = new Set();
    capabilities.localInputs.forEach(cap => {
      const option = document.createElement('option');
      option.value = cap.type;
      option.label = cap.label;
      datalist.appendChild(option);
      seen.add(cap.type);
    });
    EXTRA_TYPES.forEach(extra => {
      if (seen.has(extra.type)) return;
      const option = document.createElement('option');
      option.value = extra.type;
      option.label = extra.label;
      datalist.appendChild(option);
      seen.add(extra.type);
    });
  }

  function ensureTypeOption(type, label) {
    if (!type) return;
    const datalist = document.getElementById(TYPE_DATALIST_ID);
    if (!datalist) return;
    const value = type.trim();
    if (!value.length) return;
    const exists = Array.from(datalist.options).some(
      option => option.value === value
    );
    if (exists) return;
    const option = document.createElement('option');
    option.value = value;
    if (label && label.trim().length) option.label = label.trim();
    datalist.appendChild(option);
  }

  function findCapability(type) {
    if (!type) return null;
    const value = type.trim();
    return capabilities.localInputs.find(cap => cap.type === value) || null;
  }

  function buildDefaultId(capability, indexValue) {
    if (!capability) return '';
    const base = capability.defaultId || capability.type || 'CH';
    const indexes = capability.indexes || [];
    const numericIndex = Number.isFinite(indexValue) ? indexValue : 0;
    if (indexes.length > 1) {
      return base + numericIndex;
    }
    return base;
  }

  function collectExistingIds(excludeRow) {
    const ids = new Set();
    document.querySelectorAll('#ioTable tbody tr').forEach(row => {
      if (row === excludeRow) return;
      const input = row.querySelector('td[data-field="id"] input');
      const value = input ? input.value.trim() : '';
      if (value.length) {
        ids.add(value);
      }
    });
    return ids;
  }

  function generateUniqueId(base, excludeRow) {
    const cleanBase = base && base.trim().length ? base.trim() : 'ch';
    const existing = collectExistingIds(excludeRow);
    if (!existing.has(cleanBase)) {
      return cleanBase;
    }
    let counter = 1;
    let candidate;
    do {
      candidate = `${cleanBase}-${counter}`;
      counter += 1;
    } while (existing.has(candidate));
    return candidate;
  }

  function getRowId(tr) {
    if (!tr) return 'aucune';
    const input = tr.querySelector('td[data-field="id"] input');
    const value = input ? input.value.trim() : '';
    return value.length ? value : '(sans ID)';
  }

  function updateSelectedLabel(value) {
    const el = document.getElementById('selectedChannel');
    if (!el) return;
    if (!value || value === 'aucune') {
      el.textContent = 'aucune';
    } else {
      el.textContent = value;
    }
  }

  function attachRowHandlers(tr) {
    tr.addEventListener('click', () => {
      if (selectedRow) {
        selectedRow.classList.remove('selected');
      }
      selectedRow = tr;
      selectedRow.classList.add('selected');
      updateSelectedLabel(getRowId(tr));
      updateUdpPanelContext(tr);
      if (lastComputation) {
        applyValuesToRow(tr, lastComputation.k, lastComputation.b);
      }
    });
  }

  function applyValuesToRow(tr, k, b) {
    const kInput = tr.querySelector('td[data-field="k"] input');
    const bInput = tr.querySelector('td[data-field="b"] input');
    if (kInput) {
      kInput.value = Number.isFinite(k) ? Number(k.toFixed(6)) : '';
    }
    if (bInput) {
      bInput.value = Number.isFinite(b) ? Number(b.toFixed(6)) : '';
    }
    refreshValueColumn();
  }

  function updateIndexEditor(tr, type, desiredIndex) {
    const indexCell = tr.querySelector('td[data-field="index"]');
    if (!indexCell) return null;
    const capability = findCapability(type);
    const idInput = tr.querySelector('td[data-field="id"] input');
    const previous = indexCell.querySelector('select, input');
    let fallback = Number.isFinite(desiredIndex) ? desiredIndex : null;
    if (fallback === null && previous) {
      const parsed = parseInt(previous.value, 10);
      if (Number.isFinite(parsed)) {
        fallback = parsed;
      }
    }
    indexCell.innerHTML = '';
    let editor;
    if (capability && capability.indexes.length) {
      editor = document.createElement('select');
      capability.indexes.forEach(entry => {
        const option = document.createElement('option');
        option.value = String(entry.value);
        option.textContent = entry.label;
        editor.appendChild(option);
      });
      let target = Number.isFinite(fallback) ? fallback : capability.indexes[0].value;
      if (!capability.indexes.some(entry => entry.value === target)) {
        target = capability.indexes[0].value;
      }
      editor.value = String(target);
    } else {
      editor = document.createElement('input');
      editor.type = 'number';
      editor.step = '1';
      editor.min = '0';
      const value = Number.isFinite(fallback) ? fallback : 0;
      editor.value = String(value);
    }
    const onChange = () => {
      if (capability && idInput && idInput.dataset.autogenerated !== 'false') {
        const idxValue = parseInt(editor.value, 10);
        const baseId = buildDefaultId(capability, idxValue);
        idInput.value = generateUniqueId(baseId, tr);
        idInput.dataset.autogenerated = 'true';
        if (selectedRow === tr) {
          updateSelectedLabel(getRowId(tr));
        }
      }
      refreshValueColumn();
    };
    editor.addEventListener('change', onChange);
    editor.addEventListener('input', onChange);
    indexCell.appendChild(editor);
    return editor;
  }

  function handleTypeChange(tr, typeInput, options = {}) {
    const type = (typeInput.value || '').trim();
    const capability = findCapability(type);
    ensureTypeOption(
      type,
      capability ? capability.label : type
    );
    const indexEditor = updateIndexEditor(tr, type, options.index);
    const idInput = tr.querySelector('td[data-field="id"] input');
    if (idInput && capability && (options.generateId || idInput.dataset.autogenerated !== 'false' || !idInput.value.trim().length)) {
      const idxValue = indexEditor ? parseInt(indexEditor.value, 10) : 0;
      const baseId = buildDefaultId(capability, idxValue);
      idInput.value = generateUniqueId(baseId, tr);
      idInput.dataset.autogenerated = 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
    } else if (idInput && !capability && options.generateId && idInput.dataset.autogenerated !== 'false') {
      const base = type.length ? type.toUpperCase() : 'CH';
      idInput.value = generateUniqueId(base, tr);
      idInput.dataset.autogenerated = 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
    }
    const unitInput = tr.querySelector('td[data-field="unit"] input');
    if (unitInput) {
      if (capability && (options.forceUnit || unitInput.dataset.autofill !== 'false' || !unitInput.value.trim().length)) {
        unitInput.value = capability.defaultUnit || '';
        unitInput.dataset.autofill = 'true';
      } else if (!capability && options.forceUnit && unitInput.dataset.autofill !== 'false') {
        unitInput.value = '';
        unitInput.dataset.autofill = 'true';
      }
    }
    refreshValueColumn();
    if (!isUdpType(type)) {
      setRowRemote(tr, null);
      if (selectedRow === tr) {
        updateUdpPanelContext(null);
      }
    } else if (selectedRow === tr) {
      updateUdpPanelContext(tr);
    }
  }

  function removeRow(tr) {
    if (!tr) return;
    if (selectedRow === tr) {
      selectedRow.classList.remove('selected');
      selectedRow = null;
      updateSelectedLabel(null);
      updateUdpPanelContext(null);
    }
    tr.remove();
    updateTableStatus();
    refreshValueColumn();
  }

  function formatNumber(value) {
    if (!Number.isFinite(value)) return '—';
    if (Math.abs(value) >= 1000) {
      return value.toPrecision(4);
    }
    if (Math.abs(value) > 0 && Math.abs(value) < 0.001) {
      return value.toExponential(2);
    }
    return value.toFixed(3);
  }

  function escapeHtml(input) {
    const str = typeof input === 'string' ? input : String(input ?? '');
    return str.replace(/[&<>"']/g, char => {
      switch (char) {
        case '&':
          return '&amp;';
        case '<':
          return '&lt;';
        case '>':
          return '&gt;';
        case '"':
          return '&quot;';
        case "'":
          return '&#39;';
        default:
          return char;
      }
    });
  }

  function formatLogEntry(entry) {
    const date = entry && entry.time instanceof Date ? entry.time : new Date();
    const level = entry && typeof entry.level === 'string' ? entry.level : 'info';
    const message = entry && Object.prototype.hasOwnProperty.call(entry, 'message')
      ? entry.message
      : '';
    const timeLabel = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    return `<p class="log-entry ${level}"><span class="log-time">[${timeLabel}]</span> <span class="log-message">${escapeHtml(message)}</span></p>`;
  }

  function renderLog() {
    const output = document.getElementById('logOutput');
    if (!output) return;
    output.innerHTML = logEntries.map(formatLogEntry).join('\n');
    output.scrollTop = output.scrollHeight;
  }

  function logEvent(message, level = 'info') {
    const normalized = level === 'error' || level === 'warn' || level === 'success' ? level : 'info';
    logEntries.push({
      message,
      level: normalized,
      time: new Date()
    });
    if (logEntries.length > LOG_MAX_ENTRIES) {
      logEntries = logEntries.slice(logEntries.length - LOG_MAX_ENTRIES);
    }
    renderLog();
  }

  function clearLog() {
    logEntries = [];
    renderLog();
  }

  function refreshValueColumn() {
    const rows = document.querySelectorAll('#ioTable tbody tr');
    rows.forEach(tr => {
      const idInput = tr.querySelector('td[data-field="id"] input');
      const rawSpan = tr.querySelector('td[data-field="raw"] span');
      const valueSpan = tr.querySelector('td[data-field="value"] span');
      if (rawSpan) rawSpan.textContent = '—';
      if (valueSpan) valueSpan.textContent = '—';
      if (!idInput) {
        return;
      }
      const id = idInput.value.trim();
      if (!id.length || !latestSnapshotRaw.has(id)) {
        return;
      }
      const raw = latestSnapshotRaw.get(id);
      if (!Number.isFinite(raw)) {
        return;
      }
      if (rawSpan) {
        rawSpan.textContent = formatNumber(raw);
      }
      const kInput = tr.querySelector('td[data-field="k"] input');
      const bInput = tr.querySelector('td[data-field="b"] input');
      const kVal = kInput ? parseFloat(kInput.value) : NaN;
      const bVal = bInput ? parseFloat(bInput.value) : NaN;
      if (!Number.isFinite(kVal) || !Number.isFinite(bVal) || !valueSpan) {
        return;
      }
      const computed = kVal * raw + bVal;
      valueSpan.textContent = formatNumber(computed);
    });
  }

  async function updateSnapshot(options = {}) {
    const opts = options || {};
    const silent = Boolean(opts.silent);
    const reason = typeof opts.reason === 'string' && opts.reason.trim().length ? opts.reason.trim() : '';
    const suffix = reason.length ? ` (${reason})` : '';
    if (!silent) {
      logEvent(`Lecture des valeurs instantanées${suffix}...`, 'info');
    }
    let success = false;
    let map = latestSnapshotRaw;
    try {
      const res = await fetch('/api/io/snapshot');
      if (!res.ok) {
        throw new Error(`statut ${res.status}`);
      }
      const data = await res.json();
      map = new Map();
      if (data && Array.isArray(data.channels)) {
        data.channels.forEach(ch => {
          if (!ch || typeof ch.id !== 'string') return;
          const raw = Number(ch.raw);
          if (Number.isFinite(raw)) {
            map.set(ch.id, raw);
          }
        });
      }
      const hadErrorBefore = snapshotErrorNotified;
      latestSnapshotRaw = map;
      snapshotErrorNotified = false;
      success = true;
      if (!silent) {
        logEvent(`Valeurs instantanées mises à jour (${map.size} canal(aux)).`, 'success');
      } else if (snapshotLogCount === 0 || hadErrorBefore) {
        logEvent(`Valeurs instantanées disponibles (${map.size} canal(aux)).`, 'success');
      }
      snapshotLogCount += 1;
    } catch (err) {
      const reasonText = err && err.message ? err.message : String(err);
      if (!silent || !snapshotErrorNotified) {
        logEvent(`Impossible de mettre à jour les valeurs instantanées${suffix} : ${reasonText}`, 'error');
      }
      snapshotErrorNotified = true;
    } finally {
      refreshValueColumn();
    }
    return success;
  }

  function startSnapshotPolling() {
    if (snapshotTimer) return;
    snapshotTimer = setInterval(() => {
      updateSnapshot({ silent: true, reason: 'sondage' });
    }, 4000);
    logEvent('Surveillance périodique des mesures démarrée.', 'info');
  }

  function setupCollapsibleNavigation() {
    const links = document.querySelectorAll('nav.quick-links a[href^="#"]');
    links.forEach(link => {
      link.addEventListener('click', () => {
        const targetId = link.getAttribute('href');
        if (!targetId) return;
        const section = document.querySelector(targetId);
        if (!section) return;
        const details = section.querySelector('details.collapsible-toggle');
        if (details) {
          details.open = true;
        }
      });
    });
    if (window.location.hash) {
      const section = document.querySelector(window.location.hash);
      if (section) {
        const details = section.querySelector('details.collapsible-toggle');
        if (details) {
          details.open = true;
        }
      }
    }
    window.addEventListener('hashchange', () => {
      if (!window.location.hash) return;
      const section = document.querySelector(window.location.hash);
      if (!section) return;
      const details = section.querySelector('details.collapsible-toggle');
      if (details) {
        details.open = true;
      }
    });
  }

  function updateTableStatus(message) {
    const status = document.getElementById('status');
    if (!status) return;
    if (message) {
      status.textContent = message;
      return;
    }
    const tbody = document.querySelector('#ioTable tbody');
    if (tbody && tbody.children.length === 0) {
      status.textContent = 'Aucun canal n’est configuré pour le moment.';
    } else {
      status.textContent = '';
    }
  }

  function createRow(data = {}) {
    const tr = document.createElement('tr');
    let remoteInfo = null;
    if (data && Object.prototype.hasOwnProperty.call(data, 'remote')) {
      if (typeof data.remote === 'string') {
        try {
          remoteInfo = JSON.parse(data.remote);
        } catch (err) {
          remoteInfo = null;
        }
      } else if (typeof data.remote === 'object' && data.remote !== null) {
        remoteInfo = data.remote;
      }
    }
    setRowRemote(tr, remoteInfo);

    const idCell = document.createElement('td');
    idCell.dataset.field = 'id';
    const idInput = document.createElement('input');
    idInput.type = 'text';
    idInput.placeholder = 'Identifiant';
    idCell.appendChild(idInput);
    tr.appendChild(idCell);

    const typeCell = document.createElement('td');
    typeCell.dataset.field = 'type';
    const typeInput = document.createElement('input');
    typeInput.type = 'text';
    typeInput.setAttribute('list', TYPE_DATALIST_ID);
    typeInput.placeholder = 'Type';
    typeCell.appendChild(typeInput);
    tr.appendChild(typeCell);

    const indexCell = document.createElement('td');
    indexCell.dataset.field = 'index';
    tr.appendChild(indexCell);

    const kCell = document.createElement('td');
    kCell.dataset.field = 'k';
    const kInput = document.createElement('input');
    kInput.type = 'number';
    kInput.step = '0.000001';
    kInput.value = Number.isFinite(data.k) ? data.k : 0;
    kCell.appendChild(kInput);
    tr.appendChild(kCell);

    const bCell = document.createElement('td');
    bCell.dataset.field = 'b';
    const bInput = document.createElement('input');
    bInput.type = 'number';
    bInput.step = '0.001';
    bInput.value = Number.isFinite(data.b) ? data.b : 0;
    bCell.appendChild(bInput);
    tr.appendChild(bCell);

    const rawCell = document.createElement('td');
    rawCell.dataset.field = 'raw';
    const rawSpan = document.createElement('span');
    rawSpan.textContent = '—';
    rawCell.appendChild(rawSpan);
    tr.appendChild(rawCell);

    const valueCell = document.createElement('td');
    valueCell.dataset.field = 'value';
    const valueSpan = document.createElement('span');
    valueSpan.textContent = '—';
    valueCell.appendChild(valueSpan);
    tr.appendChild(valueCell);

    const unitCell = document.createElement('td');
    unitCell.dataset.field = 'unit';
    const unitInput = document.createElement('input');
    unitInput.type = 'text';
    unitInput.placeholder = 'ex : V';
    unitCell.appendChild(unitInput);
    tr.appendChild(unitCell);

    const actionsCell = document.createElement('td');
    actionsCell.dataset.field = 'actions';
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.textContent = 'Supprimer';
    removeBtn.addEventListener('click', event => {
      event.stopPropagation();
      removeRow(tr);
    });
    actionsCell.appendChild(removeBtn);
    tr.appendChild(actionsCell);

    const initialType =
      typeof data.type === 'string' && data.type.trim().length
        ? data.type.trim()
        : (capabilities.localInputs[0]
            ? capabilities.localInputs[0].type
            : (EXTRA_TYPES[0] ? EXTRA_TYPES[0].type : ''));
    typeInput.value = initialType;
    const capability = findCapability(initialType);
    ensureTypeOption(
      initialType,
      capability ? capability.label : initialType
    );

    const desiredIndex =
      Number.isFinite(data.index)
        ? data.index
        : (capability && capability.indexes.length
            ? capability.indexes[0].value
            : 0);
    const indexEditor = updateIndexEditor(tr, initialType, desiredIndex);

    const baseId = capability
      ? buildDefaultId(
          capability,
          indexEditor ? parseInt(indexEditor.value, 10) : desiredIndex
        )
      : (initialType ? initialType.toUpperCase() : 'CH');
    const hasId = typeof data.id === 'string' && data.id.trim().length;
    idInput.value = hasId ? data.id : generateUniqueId(baseId, tr);
    idInput.dataset.autogenerated = hasId ? 'false' : 'true';

    const hasUnit = Object.prototype.hasOwnProperty.call(data, 'unit');
    const initialUnit = hasUnit
      ? (data.unit || '')
      : (capability ? capability.defaultUnit || '' : '');
    unitInput.value = initialUnit;
    unitInput.dataset.autofill = hasUnit && data.unit ? 'false' : 'true';

    idInput.addEventListener('input', () => {
      idInput.dataset.autogenerated = idInput.value.trim().length ? 'false' : 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
      refreshValueColumn();
    });

    typeInput.addEventListener('input', () => {
      handleTypeChange(tr, typeInput);
    });
    typeInput.addEventListener('change', () => {
      handleTypeChange(tr, typeInput, { forceUnit: true });
    });

    kInput.addEventListener('input', refreshValueColumn);
    bInput.addEventListener('input', refreshValueColumn);
    unitInput.addEventListener('input', () => {
      unitInput.dataset.autofill = unitInput.value.trim().length ? 'false' : 'true';
    });

    attachRowHandlers(tr);
    return tr;
  }

  async function refresh() {
    await ensureHardwareCapabilities();
    const tbody = document.querySelector('#ioTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';
    let channels = [];
    let loadError = false;
    logEvent('Chargement de la configuration IO...', 'info');
    try {
      const res = await fetch('/api/config?area=io');
      if (!res.ok) throw new Error('config fetch failed');
      channels = await res.json();
    } catch (err) {
      loadError = true;
      updateTableStatus('Erreur lors du chargement de la configuration IO.');
      const reason = err && err.message ? err.message : String(err);
      logEvent(`Erreur lors du chargement de la configuration IO : ${reason}`, 'error');
    }
    if (!loadError) {
      if (Array.isArray(channels)) {
        channels.forEach(ch => {
          const tr = createRow(ch || {});
          tbody.appendChild(tr);
        });
      }
      if (selectedRow) {
        selectedRow.classList.remove('selected');
        selectedRow = null;
      }
      updateSelectedLabel(null);
      updateUdpPanelContext(null);
      updateTableStatus();
      const count = Array.isArray(channels) ? channels.length : 0;
      if (count === 0) {
        logEvent('Configuration IO chargée : aucune ligne définie.', 'warn');
      } else {
        logEvent(`Configuration IO chargée (${count} ligne(s)).`, 'success');
      }
    }
    refreshValueColumn();
    await updateSnapshot({ reason: 'après chargement' });
    startSnapshotPolling();
  }

  async function addRow() {
    await ensureHardwareCapabilities();
    const tbody = document.querySelector('#ioTable tbody');
    if (!tbody) return;
    const defaultCap = capabilities.localInputs[0] || null;
    const newRow = createRow({
      type: defaultCap ? defaultCap.type : (EXTRA_TYPES[0] ? EXTRA_TYPES[0].type : ''),
      index: defaultCap && defaultCap.indexes.length ? defaultCap.indexes[0].value : 0,
      k: 1,
      b: 0,
      unit: defaultCap ? defaultCap.defaultUnit : ''
    });
    tbody.appendChild(newRow);
    logEvent('Nouvelle ligne ajoutée à la configuration.', 'info');
    updateTableStatus();
    refreshValueColumn();
    const idInput = newRow.querySelector('td[data-field="id"] input');
    if (idInput) {
      idInput.focus();
      idInput.select();
    }
  }

  async function save() {
    const rows = document.querySelectorAll('#ioTable tbody tr');
    const payload = [];
    rows.forEach(tr => {
      const idInput = tr.querySelector('td[data-field="id"] input');
      const typeInput = tr.querySelector('td[data-field="type"] input');
      const indexEditor = tr.querySelector('td[data-field="index"] select, td[data-field="index"] input');
      const kInput = tr.querySelector('td[data-field="k"] input');
      const bInput = tr.querySelector('td[data-field="b"] input');
      const unitInput = tr.querySelector('td[data-field="unit"] input');
      const id = idInput ? idInput.value.trim() : '';
      const type = typeInput ? typeInput.value.trim() : '';
      const indexValue = indexEditor ? parseInt(indexEditor.value, 10) : 0;
      const kVal = kInput ? parseFloat(kInput.value) : NaN;
      const bVal = bInput ? parseFloat(bInput.value) : NaN;
      const unit = unitInput ? unitInput.value.trim() : '';
      const rowData = {
        id,
        type,
        index: Number.isFinite(indexValue) ? indexValue : 0,
        k: Number.isFinite(kVal) ? kVal : 0,
        b: Number.isFinite(bVal) ? bVal : 0,
        unit
      };
      const remoteInfo = getRowRemote(tr);
      if (remoteInfo && isUdpType(type)) {
        rowData.remote = remoteInfo;
      }
      payload.push(rowData);
    });
    logEvent(`Enregistrement de la configuration IO (${payload.length} ligne(s))...`, 'info');
    try {
      const res = await fetch('/api/config?area=io', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.ok) {
        updateTableStatus('Configuration enregistrée.');
        logEvent('Configuration IO enregistrée avec succès.', 'success');
        await updateSnapshot({ reason: 'après sauvegarde' });
      } else {
        const txt = await res.text();
        updateTableStatus('Erreur lors de l’enregistrement : ' + txt);
        logEvent(`Erreur HTTP lors de l’enregistrement : ${txt || res.status}`, 'error');
      }
    } catch (err) {
      updateTableStatus('Erreur lors de l’enregistrement de la configuration.');
      const reason = err && err.message ? err.message : String(err);
      logEvent(`Exception pendant l’enregistrement : ${reason}`, 'error');
    }
  }

  function computeCalibration() {
    const rawMin = parseFloat(document.getElementById('rawMin').value);
    const rawMax = parseFloat(document.getElementById('rawMax').value);
    const physMin = parseFloat(document.getElementById('physMin').value);
    const physMax = parseFloat(document.getElementById('physMax').value);

    if (!Number.isFinite(rawMin) || !Number.isFinite(rawMax) || rawMin === rawMax) {
      document.getElementById('assistantResult').textContent = 'Vérifiez les valeurs de mesure min/max (elles doivent être différentes).';
      return;
    }

    const k = (physMax - physMin) / (rawMax - rawMin);
    const b = physMin - k * rawMin;
    lastComputation = { k, b };
    const result = [
      'k = ' + k.toPrecision(8),
      'b = ' + b.toPrecision(8),
      '',
      'Formule : valeur_physique = ' + k.toPrecision(8) + ' × mesure + ' + b.toPrecision(8)
    ].join('\n');
    document.getElementById('assistantResult').textContent = result;

    if (selectedRow) {
      applyValuesToRow(selectedRow, k, b);
    }
  }

  function applyToSelection() {
    if (!selectedRow) {
      document.getElementById('assistantResult').textContent = 'Sélectionnez d’abord une ligne dans la table.';
      return;
    }
    if (!lastComputation) {
      document.getElementById('assistantResult').textContent = 'Calculez k et b avant de les appliquer.';
      return;
    }
    applyValuesToRow(selectedRow, lastComputation.k, lastComputation.b);
  }

  function resetAssistant() {
    document.getElementById('hardwareProfile').selectedIndex = 0;
    document.getElementById('rawMin').value = hardwareProfiles[0].rawMin;
    document.getElementById('rawMax').value = hardwareProfiles[0].rawMax;
    document.getElementById('physMin').value = 0;
    document.getElementById('physMax').value = 1;
    document.getElementById('assistantResult').textContent = 'Complétez les champs ci-dessus pour obtenir la formule.';
    lastComputation = null;
    updateUdpPanelContext(selectedRow);
  }

  const udpScanButton = document.getElementById('udpScanButton');
  if (udpScanButton) {
    udpScanButton.addEventListener('click', () => {
      scanUdpDevices();
    });
  }
  renderUdpDevices(udpScanResults, null);
  updateUdpPanelContext(null);

  logEvent('Initialisation de la page IO...', 'info');
  setupCollapsibleNavigation();
  populateProfiles();
  updateTypeDatalist();
  ensureHardwareCapabilities()
    .catch(() => capabilities)
    .finally(() => {
      refresh();
    });
  </script>
</body>
</html>
