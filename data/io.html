<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Configuration des IO – MiniLabo</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding-bottom: 3rem;
    }

    nav.quick-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    nav.quick-links a {
      background: #eef3ff;
      border-radius: 999px;
      color: #1f3d7a;
      padding: 0.4rem 0.9rem;
      text-decoration: none;
      font-weight: 600;
      border: 1px solid #b7c5ff;
    }

    .io-layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(280px, 2fr);
      gap: 1.75rem;
      align-items: start;
    }

    table#ioTable {
      width: 100%;
      border-collapse: collapse;
    }

    table#ioTable th,
    table#ioTable td {
      border: 1px solid #c8d2e0;
      padding: 0.4rem 0.6rem;
    }

    table#ioTable tbody tr.selected {
      outline: 2px solid #0059ff;
      outline-offset: -2px;
      background: #f0f5ff;
    }

    table#ioTable tbody tr:hover {
      background: #f7faff;
    }

    td input[readonly] {
      background: #f8f9fc;
      border: none;
      font-weight: 600;
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .panel {
      background: #f7f9fc;
      border: 1px solid #d7deea;
      border-radius: 12px;
      padding: 1.2rem 1.5rem;
    }

    .panel h2 {
      margin-top: 0;
    }

    .panel ul {
      margin: 0.5rem 0 0.25rem;
    }

    .typology-grid {
      display: grid;
      gap: 1.25rem;
    }

    .typology-grid article {
      background: #fff;
      border: 1px solid #dbe3f6;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
    }

    .typology-grid h3 {
      margin-top: 0;
    }

    details.typology-details {
      background: #fff;
      border-radius: 10px;
      border: 1px solid #ccd8ef;
      padding: 0.8rem 1rem;
    }

    details.typology-details + details.typology-details {
      margin-top: 0.75rem;
    }

    details.typology-details summary {
      cursor: pointer;
      font-weight: 600;
      color: #1c317a;
    }

    .assistant-section form {
      display: grid;
      gap: 0.75rem;
    }

    .assistant-section label {
      display: flex;
      flex-direction: column;
      font-size: 0.95rem;
      gap: 0.25rem;
    }

    .assistant-section input,
    .assistant-section select {
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      border: 1px solid #c7d2e5;
    }

    .assistant-section button {
      justify-self: flex-start;
    }

    .assistant-result {
      background: #fff;
      border: 1px dashed #a3b3d4;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      font-family: "Courier New", monospace;
      white-space: pre-wrap;
    }

    .legend {
      font-size: 0.9rem;
      color: #304160;
    }

    .highlight {
      font-weight: 600;
      color: #214bb8;
    }

    @media (max-width: 900px) {
      .io-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <h1>Configuration des entrées/sorties</h1>
  <p>Cette page centralise la typologie des entrées/sorties du MiniLabo et propose des outils de calibration. Commencez par
  sélectionner un canal dans le tableau, puis utilisez l’assistant pour calculer la conversion entre la grandeur électrique
  mesurée et la grandeur physique souhaitée.</p>

  <nav class="quick-links">
    <a href="#typologie-entrees">Entrées</a>
    <a href="#typologie-sorties">Sorties</a>
    <a href="#udp">Serveur&nbsp;UDP</a>
    <a href="#configuration">Table de configuration</a>
    <a href="#assistant">Assistant de calibration</a>
  </nav>

  <section id="typologie-entrees" class="panel">
    <h2>Typologie des entrées</h2>
    <p>Une entrée convertit un signal en une valeur exploitable par les outils web (oscilloscope, DMM, scripts math, UDP). Les
    entrées peuvent être locales (connectées directement à l’ESP8266) ou déportées (reçues via le réseau).</p>
    <div class="typology-grid">
      <article>
        <h3>Entrées réelles locales</h3>
        <ul>
          <li><span class="highlight">ADC interne (A0)</span> : 10 bits, 0–1 V natif (0–3,3 V avec diviseur intégré sur NodeMCU).</li>
          <li><span class="highlight">ADS1115 (I²C)</span> : module 16 bits avec amplification programmable, idéal pour les mesures fines.</li>
          <li><span class="highlight">ZMPT101B</span> : transformateur de tension AC, sortie 0–3,3 V, 10 bits.</li>
          <li><span class="highlight">ZMCT103C</span> : transformateur de courant AC, tension de sortie proportionnelle.</li>
        </ul>
      </article>
      <article>
        <h3>Entrées déportées</h3>
        <p>Les valeurs proviennent d’autres modules (ESP8266/ESP32) ou d’un PC via UDP. Elles complètent la configuration locale et
        sont intégrées aux mêmes outils de visualisation.</p>
        <ul>
          <li>Permet de centraliser des mesures distantes dans un seul MiniLabo.</li>
          <li>Chaque flux UDP est identifié par un nom de canal (ID) repris dans le tableau de configuration.</li>
          <li>La normalisation k/b peut s’appliquer comme pour les entrées réelles.</li>
        </ul>
      </article>
    </div>
  </section>

  <section id="typologie-sorties" class="panel">
    <h2>Typologie des sorties</h2>
    <div class="typology-grid">
      <article>
        <h3>Sorties réelles</h3>
        <ul>
          <li><span class="highlight">MCP4725 (DAC 12 bits)</span> : conversion en tension 0–3,3 V proportionnelle au pourcentage demandé.</li>
          <li><span class="highlight">Convertisseur PWM → 0–10 V</span> : interface pour actionneurs industriels ou drivers de LED.</li>
        </ul>
      </article>
      <article>
        <h3>Stratégies d’utilisation</h3>
        <ul>
          <li>Associez chaque sortie à l’entrée ou au calcul math correspondant (PID, consigne, etc.).</li>
          <li>Définissez une conversion inverse (grandeur physique → tension) via les coefficients k/b.</li>
          <li>Utilisez les outils math pour générer des profils de sortie ou automatiser des séquences.</li>
        </ul>
      </article>
    </div>
  </section>

  <section id="udp" class="panel">
    <h2>Serveur UDP</h2>
    <p>Le MiniLabo peut diffuser ses valeurs sur le réseau via <span class="highlight">UDP TX</span>. Toute valeur convertie (après k/b)
    peut être publiée vers un autre MiniLabo ou un PC pour être affichée, enregistrée ou réinjectée dans une boucle d’asservissement.</p>
    <ul class="legend">
      <li>Utilisez le champ <em>type</em> pour distinguer les canaux UDP entrants (« udp-in ») et sortants (« udp-out »).</li>
      <li>Configurez les paramètres réseau dans l’onglet <a href="udp.html">UDP</a> puis associez le canal dans cette page.</li>
      <li>Le statut du flux est visible dans la page <a href="logs.html">Logs</a> et dans l’onglet réseau.</li>
    </ul>
  </section>

  <div class="io-layout" id="configuration">
    <section>
      <h2>Table de configuration des canaux</h2>
      <p>Sélectionnez une ligne pour la relier aux outils de calibration. Les colonnes <em>k</em> et <em>b</em> définissent la relation
      <code>valeur_physique = k × mesure + b</code>.</p>
      <table id="ioTable">
        <thead>
          <tr>
            <th>ID</th>
            <th>Type</th>
            <th>Index</th>
            <th>k</th>
            <th>b</th>
            <th>Valeur calculée</th>
            <th>Unité</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
      <datalist id="channelTypeOptions"></datalist>
      <div class="actions">
        <button type="button" onclick="addRow()">Ajouter une ligne</button>
        <button type="button" onclick="refresh()">Rafraîchir</button>
        <button type="button" onclick="save()">Enregistrer</button>
      </div>
      <p id="status"></p>
    </section>

    <aside id="assistant" class="panel assistant-section">
      <h2>Assistant de calibration</h2>
      <p class="legend">Ligne sélectionnée : <span id="selectedChannel">aucune</span></p>
      <form onsubmit="event.preventDefault(); computeCalibration();">
        <label>
          Profil matériel
          <select id="hardwareProfile"></select>
        </label>
        <label>
          Mesure min (valeur brute)
          <input type="number" id="rawMin" step="any" value="0">
        </label>
        <label>
          Mesure max (valeur brute)
          <input type="number" id="rawMax" step="any" value="1023">
        </label>
        <label>
          Grandeur physique min
          <input type="number" id="physMin" step="any" value="0">
        </label>
        <label>
          Grandeur physique max
          <input type="number" id="physMax" step="any" value="1">
        </label>
        <button type="submit">Calculer k &amp; b</button>
      </form>
      <div class="assistant-result" id="assistantResult">Complétez les champs ci-dessus pour obtenir la formule.</div>
      <div class="actions">
        <button type="button" onclick="applyToSelection()">Appliquer à la ligne sélectionnée</button>
        <button type="button" onclick="resetAssistant()">Réinitialiser</button>
      </div>
      <details class="typology-details" open>
        <summary>Astuces de conversion</summary>
        <ul>
          <li>Pour un capteur linéaire 0–10 V relié à l’ADS1115 : mesure min = 0, mesure max = 32767 (16 bits), grandeur max = 10.</li>
          <li>Pour un transformateur ZMPT101B : renseignez les valeurs RMS attendues (ex. 0 V ↔ 0 V, 230 V ↔ 1,65 V).</li>
          <li>Pour une entrée UDP représentant un pourcentage : mesure min = 0, max = 100, grandeur max = 1 (pour normaliser).</li>
        </ul>
      </details>
    </aside>
  </div>

  <section class="panel">
    <h2>FAQ express</h2>
    <details class="typology-details">
      <summary>Comment déterminer k et b ?</summary>
      <p>Mesurez deux points de référence (min et max) ou utilisez la fiche technique du capteur. L’assistant calcule automatiquement<br>
      <code>k = (physMax − physMin) / (rawMax − rawMin)</code> et <code>b = physMin − k × rawMin</code>.</p>
    </details>
    <details class="typology-details">
      <summary>Que signifie l’index ?</summary>
      <p>Il s’agit du canal physique ou logique. Pour l’ADC interne, l’index est souvent 0. Pour l’ADS1115, utilisez l’entrée A0–A3.
      Pour l’UDP, l’index correspond au port logique défini dans la configuration réseau.</p>
    </details>
    <details class="typology-details">
      <summary>Comment créer une chaîne complète mesure → actionneur ?</summary>
      <p>1) Configurez l’entrée et normalisez-la.<br>2) Utilisez l’onglet <a href="math.html">Math</a> pour appliquer un traitement ou un
      contrôle.<br>3) Mappez le résultat sur une sortie dans cette page et, si besoin, diffusez-le via UDP.</p>
    </details>
  </section>

  <script>
  const hardwareProfiles = [
    {
      id: 'adc',
      name: 'ADC interne (A0)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Entrée 0–1 V (ou 0–3,3 V avec diviseur).'
    },
    {
      id: 'ads1115',
      name: 'ADS1115 (gain ±4.096 V)',
      bits: 16,
      rawMin: 0,
      rawMax: 32767,
      description: '16 bits, utilisez le gain selon votre montage.'
    },
    {
      id: 'zmpt101b',
      name: 'ZMPT101B (0–3,3 V)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Transformateur de tension AC.'
    },
    {
      id: 'zmct103c',
      name: 'ZMCT103C (sortie AC)',
      bits: 10,
      rawMin: 0,
      rawMax: 1023,
      description: 'Transformateur de courant AC.'
    },
    {
      id: 'udp',
      name: 'Entrée UDP personnalisée',
      bits: 16,
      rawMin: 0,
      rawMax: 1,
      description: 'Adapter les bornes selon la source distante.'
    }
  ];

  const DEFAULT_LOCAL_INPUTS = [
    {
      type: 'a0',
      label: 'ADC interne A0',
      defaultId: 'A0',
      defaultUnit: 'V',
      indexes: [{ value: 0, label: 'A0' }]
    }
  ];
  const EXTRA_TYPES = [
    { type: 'udp-in', label: 'UDP entrant' },
    { type: 'udp-out', label: 'UDP sortant' },
    { type: 'udp', label: 'UDP' },
    { type: 'math', label: 'Calcul mathématique' }
  ];
  const TYPE_DATALIST_ID = 'channelTypeOptions';

  let selectedRow = null;
  let lastComputation = null;
  let capabilities = { localInputs: DEFAULT_LOCAL_INPUTS.map(normalizeLocalInput) };
  let hardwarePromise = null;
  let snapshotTimer = null;
  let latestSnapshotRaw = new Map();

  function populateProfiles() {
    const select = document.getElementById('hardwareProfile');
    select.innerHTML = '';
    hardwareProfiles.forEach(profile => {
      const option = document.createElement('option');
      option.value = profile.id;
      option.textContent = profile.name;
      option.dataset.rawMin = profile.rawMin;
      option.dataset.rawMax = profile.rawMax;
      option.title = profile.description;
      select.appendChild(option);
    });
    if (hardwareProfiles.length) {
      const first = hardwareProfiles[0];
      document.getElementById('rawMin').value = first.rawMin;
      document.getElementById('rawMax').value = first.rawMax;
    }
    select.addEventListener('change', event => {
      const option = event.target.selectedOptions[0];
      if (!option) return;
      document.getElementById('rawMin').value = option.dataset.rawMin;
      document.getElementById('rawMax').value = option.dataset.rawMax;
    });
  }

  function normalizeLocalInput(entry) {
    const source = entry && typeof entry === 'object' ? entry : {};
    const type =
      typeof source.type === 'string' && source.type.trim().length
        ? source.type.trim()
        : 'a0';
    const label =
      typeof source.label === 'string' && source.label.trim().length
        ? source.label.trim()
        : type.toUpperCase();
    const defaultId =
      typeof source.defaultId === 'string' && source.defaultId.trim().length
        ? source.defaultId.trim()
        : label.replace(/\s+/g, '');
    const defaultUnit =
      typeof source.defaultUnit === 'string' ? source.defaultUnit : '';
    const indexes = [];
    if (Array.isArray(source.indexes) && source.indexes.length) {
      const seen = new Set();
      source.indexes.forEach(item => {
        if (!item) return;
        const numeric = Number(item.value);
        const value = Number.isFinite(numeric)
          ? numeric
          : Number(parseInt(item.value, 10));
        const indexValue = Number.isFinite(value) ? value : 0;
        if (seen.has(indexValue)) return;
        seen.add(indexValue);
        const labelText =
          typeof item.label === 'string' && item.label.trim().length
            ? item.label.trim()
            : String(indexValue);
        indexes.push({ value: indexValue, label: labelText });
      });
    }
    if (!indexes.length) {
      indexes.push({ value: 0, label: '0' });
    }
    return { type, label, defaultId, defaultUnit, indexes };
  }

  function ensureHardwareCapabilities() {
    if (!hardwarePromise) {
      hardwarePromise = fetchHardwareCapabilities();
    }
    return hardwarePromise;
  }

  async function fetchHardwareCapabilities() {
    let locals = [];
    try {
      const res = await fetch('/api/io/hardware');
      if (res.ok) {
        const data = await res.json();
        if (data && Array.isArray(data.localInputs) && data.localInputs.length) {
          locals = data.localInputs.map(normalizeLocalInput);
        }
      }
    } catch (err) {
      // Ignore network errors and fall back to defaults.
    }
    if (!locals.length) {
      locals = DEFAULT_LOCAL_INPUTS.map(normalizeLocalInput);
    }
    capabilities.localInputs = locals;
    updateTypeDatalist();
    return capabilities;
  }

  function updateTypeDatalist() {
    const datalist = document.getElementById(TYPE_DATALIST_ID);
    if (!datalist) return;
    datalist.innerHTML = '';
    const seen = new Set();
    capabilities.localInputs.forEach(cap => {
      const option = document.createElement('option');
      option.value = cap.type;
      option.label = cap.label;
      datalist.appendChild(option);
      seen.add(cap.type);
    });
    EXTRA_TYPES.forEach(extra => {
      if (seen.has(extra.type)) return;
      const option = document.createElement('option');
      option.value = extra.type;
      option.label = extra.label;
      datalist.appendChild(option);
      seen.add(extra.type);
    });
  }

  function ensureTypeOption(type, label) {
    if (!type) return;
    const datalist = document.getElementById(TYPE_DATALIST_ID);
    if (!datalist) return;
    const value = type.trim();
    if (!value.length) return;
    const exists = Array.from(datalist.options).some(
      option => option.value === value
    );
    if (exists) return;
    const option = document.createElement('option');
    option.value = value;
    if (label && label.trim().length) option.label = label.trim();
    datalist.appendChild(option);
  }

  function findCapability(type) {
    if (!type) return null;
    const value = type.trim();
    return capabilities.localInputs.find(cap => cap.type === value) || null;
  }

  function buildDefaultId(capability, indexValue) {
    if (!capability) return '';
    const base = capability.defaultId || capability.type || 'CH';
    const indexes = capability.indexes || [];
    const numericIndex = Number.isFinite(indexValue) ? indexValue : 0;
    if (indexes.length > 1) {
      return base + numericIndex;
    }
    return base;
  }

  function collectExistingIds(excludeRow) {
    const ids = new Set();
    document.querySelectorAll('#ioTable tbody tr').forEach(row => {
      if (row === excludeRow) return;
      const input = row.querySelector('td[data-field="id"] input');
      const value = input ? input.value.trim() : '';
      if (value.length) {
        ids.add(value);
      }
    });
    return ids;
  }

  function generateUniqueId(base, excludeRow) {
    const cleanBase = base && base.trim().length ? base.trim() : 'ch';
    const existing = collectExistingIds(excludeRow);
    if (!existing.has(cleanBase)) {
      return cleanBase;
    }
    let counter = 1;
    let candidate;
    do {
      candidate = `${cleanBase}-${counter}`;
      counter += 1;
    } while (existing.has(candidate));
    return candidate;
  }

  function getRowId(tr) {
    if (!tr) return 'aucune';
    const input = tr.querySelector('td[data-field="id"] input');
    const value = input ? input.value.trim() : '';
    return value.length ? value : '(sans ID)';
  }

  function updateSelectedLabel(value) {
    const el = document.getElementById('selectedChannel');
    if (!el) return;
    if (!value || value === 'aucune') {
      el.textContent = 'aucune';
    } else {
      el.textContent = value;
    }
  }

  function attachRowHandlers(tr) {
    tr.addEventListener('click', () => {
      if (selectedRow) {
        selectedRow.classList.remove('selected');
      }
      selectedRow = tr;
      selectedRow.classList.add('selected');
      updateSelectedLabel(getRowId(tr));
      if (lastComputation) {
        applyValuesToRow(tr, lastComputation.k, lastComputation.b);
      }
    });
  }

  function applyValuesToRow(tr, k, b) {
    const kInput = tr.querySelector('td[data-field="k"] input');
    const bInput = tr.querySelector('td[data-field="b"] input');
    if (kInput) {
      kInput.value = Number.isFinite(k) ? Number(k.toFixed(6)) : '';
    }
    if (bInput) {
      bInput.value = Number.isFinite(b) ? Number(b.toFixed(6)) : '';
    }
    refreshValueColumn();
  }

  function updateIndexEditor(tr, type, desiredIndex) {
    const indexCell = tr.querySelector('td[data-field="index"]');
    if (!indexCell) return null;
    const capability = findCapability(type);
    const idInput = tr.querySelector('td[data-field="id"] input');
    const previous = indexCell.querySelector('select, input');
    let fallback = Number.isFinite(desiredIndex) ? desiredIndex : null;
    if (fallback === null && previous) {
      const parsed = parseInt(previous.value, 10);
      if (Number.isFinite(parsed)) {
        fallback = parsed;
      }
    }
    indexCell.innerHTML = '';
    let editor;
    if (capability && capability.indexes.length) {
      editor = document.createElement('select');
      capability.indexes.forEach(entry => {
        const option = document.createElement('option');
        option.value = String(entry.value);
        option.textContent = entry.label;
        editor.appendChild(option);
      });
      let target = Number.isFinite(fallback) ? fallback : capability.indexes[0].value;
      if (!capability.indexes.some(entry => entry.value === target)) {
        target = capability.indexes[0].value;
      }
      editor.value = String(target);
    } else {
      editor = document.createElement('input');
      editor.type = 'number';
      editor.step = '1';
      editor.min = '0';
      const value = Number.isFinite(fallback) ? fallback : 0;
      editor.value = String(value);
    }
    const onChange = () => {
      if (capability && idInput && idInput.dataset.autogenerated !== 'false') {
        const idxValue = parseInt(editor.value, 10);
        const baseId = buildDefaultId(capability, idxValue);
        idInput.value = generateUniqueId(baseId, tr);
        idInput.dataset.autogenerated = 'true';
        if (selectedRow === tr) {
          updateSelectedLabel(getRowId(tr));
        }
      }
      refreshValueColumn();
    };
    editor.addEventListener('change', onChange);
    editor.addEventListener('input', onChange);
    indexCell.appendChild(editor);
    return editor;
  }

  function handleTypeChange(tr, typeInput, options = {}) {
    const type = (typeInput.value || '').trim();
    const capability = findCapability(type);
    ensureTypeOption(
      type,
      capability ? capability.label : type
    );
    const indexEditor = updateIndexEditor(tr, type, options.index);
    const idInput = tr.querySelector('td[data-field="id"] input');
    if (idInput && capability && (options.generateId || idInput.dataset.autogenerated !== 'false' || !idInput.value.trim().length)) {
      const idxValue = indexEditor ? parseInt(indexEditor.value, 10) : 0;
      const baseId = buildDefaultId(capability, idxValue);
      idInput.value = generateUniqueId(baseId, tr);
      idInput.dataset.autogenerated = 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
    } else if (idInput && !capability && options.generateId && idInput.dataset.autogenerated !== 'false') {
      const base = type.length ? type.toUpperCase() : 'CH';
      idInput.value = generateUniqueId(base, tr);
      idInput.dataset.autogenerated = 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
    }
    const unitInput = tr.querySelector('td[data-field="unit"] input');
    if (unitInput) {
      if (capability && (options.forceUnit || unitInput.dataset.autofill !== 'false' || !unitInput.value.trim().length)) {
        unitInput.value = capability.defaultUnit || '';
        unitInput.dataset.autofill = 'true';
      } else if (!capability && options.forceUnit && unitInput.dataset.autofill !== 'false') {
        unitInput.value = '';
        unitInput.dataset.autofill = 'true';
      }
    }
    refreshValueColumn();
  }

  function removeRow(tr) {
    if (!tr) return;
    if (selectedRow === tr) {
      selectedRow.classList.remove('selected');
      selectedRow = null;
      updateSelectedLabel(null);
    }
    tr.remove();
    updateTableStatus();
    refreshValueColumn();
  }

  function formatNumber(value) {
    if (!Number.isFinite(value)) return '—';
    if (Math.abs(value) >= 1000) {
      return value.toPrecision(4);
    }
    if (Math.abs(value) > 0 && Math.abs(value) < 0.001) {
      return value.toExponential(2);
    }
    return value.toFixed(3);
  }

  function refreshValueColumn() {
    const rows = document.querySelectorAll('#ioTable tbody tr');
    rows.forEach(tr => {
      const idInput = tr.querySelector('td[data-field="id"] input');
      const valueSpan = tr.querySelector('td[data-field="value"] span');
      if (!valueSpan || !idInput) {
        if (valueSpan) valueSpan.textContent = '—';
        return;
      }
      const id = idInput.value.trim();
      if (!id.length || !latestSnapshotRaw.has(id)) {
        valueSpan.textContent = '—';
        return;
      }
      const raw = latestSnapshotRaw.get(id);
      if (!Number.isFinite(raw)) {
        valueSpan.textContent = '—';
        return;
      }
      const kInput = tr.querySelector('td[data-field="k"] input');
      const bInput = tr.querySelector('td[data-field="b"] input');
      const kVal = kInput ? parseFloat(kInput.value) : NaN;
      const bVal = bInput ? parseFloat(bInput.value) : NaN;
      if (!Number.isFinite(kVal) || !Number.isFinite(bVal)) {
        valueSpan.textContent = '—';
        return;
      }
      const computed = kVal * raw + bVal;
      valueSpan.textContent = formatNumber(computed);
    });
  }

  async function updateSnapshot() {
    try {
      const res = await fetch('/api/io/snapshot');
      if (!res.ok) throw new Error('snapshot failed');
      const data = await res.json();
      const map = new Map();
      if (data && Array.isArray(data.channels)) {
        data.channels.forEach(ch => {
          if (!ch || typeof ch.id !== 'string') return;
          const raw = Number(ch.raw);
          if (Number.isFinite(raw)) {
            map.set(ch.id, raw);
          }
        });
      }
      latestSnapshotRaw = map;
    } catch (err) {
      // Keep previous snapshot on error.
    }
    refreshValueColumn();
  }

  function startSnapshotPolling() {
    if (snapshotTimer) return;
    snapshotTimer = setInterval(updateSnapshot, 4000);
  }

  function updateTableStatus(message) {
    const status = document.getElementById('status');
    if (!status) return;
    if (message) {
      status.textContent = message;
      return;
    }
    const tbody = document.querySelector('#ioTable tbody');
    if (tbody && tbody.children.length === 0) {
      status.textContent = 'Aucun canal n’est configuré pour le moment.';
    } else {
      status.textContent = '';
    }
  }

  function createRow(data = {}) {
    const tr = document.createElement('tr');

    const idCell = document.createElement('td');
    idCell.dataset.field = 'id';
    const idInput = document.createElement('input');
    idInput.type = 'text';
    idInput.placeholder = 'Identifiant';
    idCell.appendChild(idInput);
    tr.appendChild(idCell);

    const typeCell = document.createElement('td');
    typeCell.dataset.field = 'type';
    const typeInput = document.createElement('input');
    typeInput.type = 'text';
    typeInput.setAttribute('list', TYPE_DATALIST_ID);
    typeInput.placeholder = 'Type';
    typeCell.appendChild(typeInput);
    tr.appendChild(typeCell);

    const indexCell = document.createElement('td');
    indexCell.dataset.field = 'index';
    tr.appendChild(indexCell);

    const kCell = document.createElement('td');
    kCell.dataset.field = 'k';
    const kInput = document.createElement('input');
    kInput.type = 'number';
    kInput.step = '0.000001';
    kInput.value = Number.isFinite(data.k) ? data.k : 0;
    kCell.appendChild(kInput);
    tr.appendChild(kCell);

    const bCell = document.createElement('td');
    bCell.dataset.field = 'b';
    const bInput = document.createElement('input');
    bInput.type = 'number';
    bInput.step = '0.001';
    bInput.value = Number.isFinite(data.b) ? data.b : 0;
    bCell.appendChild(bInput);
    tr.appendChild(bCell);

    const valueCell = document.createElement('td');
    valueCell.dataset.field = 'value';
    const valueSpan = document.createElement('span');
    valueSpan.textContent = '—';
    valueCell.appendChild(valueSpan);
    tr.appendChild(valueCell);

    const unitCell = document.createElement('td');
    unitCell.dataset.field = 'unit';
    const unitInput = document.createElement('input');
    unitInput.type = 'text';
    unitInput.placeholder = 'ex : V';
    unitCell.appendChild(unitInput);
    tr.appendChild(unitCell);

    const actionsCell = document.createElement('td');
    actionsCell.dataset.field = 'actions';
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.textContent = 'Supprimer';
    removeBtn.addEventListener('click', event => {
      event.stopPropagation();
      removeRow(tr);
    });
    actionsCell.appendChild(removeBtn);
    tr.appendChild(actionsCell);

    const initialType =
      typeof data.type === 'string' && data.type.trim().length
        ? data.type.trim()
        : (capabilities.localInputs[0]
            ? capabilities.localInputs[0].type
            : (EXTRA_TYPES[0] ? EXTRA_TYPES[0].type : ''));
    typeInput.value = initialType;
    const capability = findCapability(initialType);
    ensureTypeOption(
      initialType,
      capability ? capability.label : initialType
    );

    const desiredIndex =
      Number.isFinite(data.index)
        ? data.index
        : (capability && capability.indexes.length
            ? capability.indexes[0].value
            : 0);
    const indexEditor = updateIndexEditor(tr, initialType, desiredIndex);

    const baseId = capability
      ? buildDefaultId(
          capability,
          indexEditor ? parseInt(indexEditor.value, 10) : desiredIndex
        )
      : (initialType ? initialType.toUpperCase() : 'CH');
    const hasId = typeof data.id === 'string' && data.id.trim().length;
    idInput.value = hasId ? data.id : generateUniqueId(baseId, tr);
    idInput.dataset.autogenerated = hasId ? 'false' : 'true';

    const hasUnit = Object.prototype.hasOwnProperty.call(data, 'unit');
    const initialUnit = hasUnit
      ? (data.unit || '')
      : (capability ? capability.defaultUnit || '' : '');
    unitInput.value = initialUnit;
    unitInput.dataset.autofill = hasUnit && data.unit ? 'false' : 'true';

    idInput.addEventListener('input', () => {
      idInput.dataset.autogenerated = idInput.value.trim().length ? 'false' : 'true';
      if (selectedRow === tr) {
        updateSelectedLabel(getRowId(tr));
      }
      refreshValueColumn();
    });

    typeInput.addEventListener('input', () => {
      handleTypeChange(tr, typeInput);
    });
    typeInput.addEventListener('change', () => {
      handleTypeChange(tr, typeInput, { forceUnit: true });
    });

    kInput.addEventListener('input', refreshValueColumn);
    bInput.addEventListener('input', refreshValueColumn);
    unitInput.addEventListener('input', () => {
      unitInput.dataset.autofill = unitInput.value.trim().length ? 'false' : 'true';
    });

    attachRowHandlers(tr);
    return tr;
  }

  async function refresh() {
    await ensureHardwareCapabilities();
    const tbody = document.querySelector('#ioTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';
    let channels = [];
    let loadError = false;
    try {
      const res = await fetch('/api/config?area=io');
      if (!res.ok) throw new Error('config fetch failed');
      channels = await res.json();
    } catch (err) {
      loadError = true;
      updateTableStatus('Erreur lors du chargement de la configuration IO.');
    }
    if (!loadError) {
      if (Array.isArray(channels)) {
        channels.forEach(ch => {
          const tr = createRow(ch || {});
          tbody.appendChild(tr);
        });
      }
      if (selectedRow) {
        selectedRow.classList.remove('selected');
        selectedRow = null;
      }
      updateSelectedLabel(null);
      updateTableStatus();
    }
    refreshValueColumn();
    await updateSnapshot();
    startSnapshotPolling();
  }

  async function addRow() {
    await ensureHardwareCapabilities();
    const tbody = document.querySelector('#ioTable tbody');
    if (!tbody) return;
    const defaultCap = capabilities.localInputs[0] || null;
    const newRow = createRow({
      type: defaultCap ? defaultCap.type : (EXTRA_TYPES[0] ? EXTRA_TYPES[0].type : ''),
      index: defaultCap && defaultCap.indexes.length ? defaultCap.indexes[0].value : 0,
      k: 1,
      b: 0,
      unit: defaultCap ? defaultCap.defaultUnit : ''
    });
    tbody.appendChild(newRow);
    updateTableStatus();
    refreshValueColumn();
    const idInput = newRow.querySelector('td[data-field="id"] input');
    if (idInput) {
      idInput.focus();
      idInput.select();
    }
  }

  async function save() {
    const rows = document.querySelectorAll('#ioTable tbody tr');
    const payload = [];
    rows.forEach(tr => {
      const idInput = tr.querySelector('td[data-field="id"] input');
      const typeInput = tr.querySelector('td[data-field="type"] input');
      const indexEditor = tr.querySelector('td[data-field="index"] select, td[data-field="index"] input');
      const kInput = tr.querySelector('td[data-field="k"] input');
      const bInput = tr.querySelector('td[data-field="b"] input');
      const unitInput = tr.querySelector('td[data-field="unit"] input');
      const id = idInput ? idInput.value.trim() : '';
      const type = typeInput ? typeInput.value.trim() : '';
      const indexValue = indexEditor ? parseInt(indexEditor.value, 10) : 0;
      const kVal = kInput ? parseFloat(kInput.value) : NaN;
      const bVal = bInput ? parseFloat(bInput.value) : NaN;
      const unit = unitInput ? unitInput.value.trim() : '';
      payload.push({
        id,
        type,
        index: Number.isFinite(indexValue) ? indexValue : 0,
        k: Number.isFinite(kVal) ? kVal : 0,
        b: Number.isFinite(bVal) ? bVal : 0,
        unit
      });
    });
    try {
      const res = await fetch('/api/config?area=io', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.ok) {
        updateTableStatus('Configuration enregistrée.');
        await updateSnapshot();
      } else {
        const txt = await res.text();
        updateTableStatus('Erreur lors de l’enregistrement : ' + txt);
      }
    } catch (err) {
      updateTableStatus('Erreur lors de l’enregistrement de la configuration.');
    }
  }

  function computeCalibration() {
    const rawMin = parseFloat(document.getElementById('rawMin').value);
    const rawMax = parseFloat(document.getElementById('rawMax').value);
    const physMin = parseFloat(document.getElementById('physMin').value);
    const physMax = parseFloat(document.getElementById('physMax').value);

    if (!Number.isFinite(rawMin) || !Number.isFinite(rawMax) || rawMin === rawMax) {
      document.getElementById('assistantResult').textContent = 'Vérifiez les valeurs de mesure min/max (elles doivent être différentes).';
      return;
    }

    const k = (physMax - physMin) / (rawMax - rawMin);
    const b = physMin - k * rawMin;
    lastComputation = { k, b };
    const result = [
      'k = ' + k.toPrecision(8),
      'b = ' + b.toPrecision(8),
      '',
      'Formule : valeur_physique = ' + k.toPrecision(8) + ' × mesure + ' + b.toPrecision(8)
    ].join('\n');
    document.getElementById('assistantResult').textContent = result;

    if (selectedRow) {
      applyValuesToRow(selectedRow, k, b);
    }
  }

  function applyToSelection() {
    if (!selectedRow) {
      document.getElementById('assistantResult').textContent = 'Sélectionnez d’abord une ligne dans la table.';
      return;
    }
    if (!lastComputation) {
      document.getElementById('assistantResult').textContent = 'Calculez k et b avant de les appliquer.';
      return;
    }
    applyValuesToRow(selectedRow, lastComputation.k, lastComputation.b);
  }

  function resetAssistant() {
    document.getElementById('hardwareProfile').selectedIndex = 0;
    document.getElementById('rawMin').value = hardwareProfiles[0].rawMin;
    document.getElementById('rawMax').value = hardwareProfiles[0].rawMax;
    document.getElementById('physMin').value = 0;
    document.getElementById('physMax').value = 1;
    document.getElementById('assistantResult').textContent = 'Complétez les champs ci-dessus pour obtenir la formule.';
    lastComputation = null;
  }

  populateProfiles();
  updateTypeDatalist();
  ensureHardwareCapabilities()
    .catch(() => capabilities)
    .finally(() => {
      refresh();
    });
  </script>
</body>
</html>
