<!DOCTYPE html>
<html lang="fr">
<!--
  devices.html

  Cette page regroupe les quatre appareils principaux du MiniLabo dans
  une interface unique composée de quatre cadrans : multimètre,
  générateur de fonctions, oscilloscope et éditeur d’équations
  mathématiques.  Elle est destinée à servir d’écran de contrôle
  « console » rappelant un banc de mesures complet.  Chaque cadran
  fonctionne indépendamment : le multimètre lit les valeurs exposées
  par l’API DMM, le générateur permet d’ajuster amplitude, offset,
  fréquence et forme sur une sortie, l’oscilloscope trace un canal en
  direct et l’éditeur math gère des formules créant des IO
  dérivées.

  TODO:
  – Brancher chaque cadran sur les appels API correspondants.  Voir
    les fonctions loadDmm(), loadIOForFunc(), loadScope() et
    loadMath() plus bas pour des squelettes d’implémentation.  Ces
    fonctions interrogent respectivement /api/dmm, /api/io,
    /api/scope et /api/config?area=math.
  – Gérer les modes d’affichage du multimètre (binaire et cadran
    analogique) : seuls les chiffres sont affichés pour l’instant.
  – Implémenter la mise à jour en temps réel de l’oscilloscope selon
    la base de temps et l’échelle verticale définies dans
    scope.json.  Actuellement un auto‑scale basique est utilisé.
  – Ajouter un panneau de logs ou de messages de statut si
    nécessaire.
  – Cette page n’est pas liée par défaut dans index.html ; ajoutez
    simplement un lien vers devices.html si vous souhaitez
    l’utiliser comme tableau de bord.
-->
<head>
  <meta charset="utf-8" />
  <title>MiniLabo — Console 4 cadrans</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0c0f14;
      --panel:#121722;
      --panel-2:#0f141d;
      --bezel:#1a2230;
      --accent:#36d399;
      --accent-2:#4cc3ff;
      --warn:#ffb86b;
      --danger:#ff6b6b;
      --text:#e5e7eb;
      --sub:#98a2b3;
      --grid:#1f2a3a;
      --grid-sub:#162030;
      --shadow: 0 10px 25px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
      background: radial-gradient(1200px 800px at 70% -200px, #111827 0%, #0b0e13 60%, #090c11 100%);
      color:var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 20px; border-bottom:1px solid #1f2937;
      background:linear-gradient(180deg,#101522 0%, #0e1220 100%);
      position:sticky; top:0; z-index:10;
    }
    header h1{margin:0; font-size:18px; letter-spacing:.3px; font-weight:600}
    header .led{
      width:10px;height:10px;border-radius:50%;
      box-shadow:0 0 12px rgba(54,211,153,.55), inset 0 0 4px rgba(0,0,0,.6);
      background:radial-gradient(circle at 30% 30%, #7fffbf, #11a86e);
      margin-right:8px; display:inline-block; vertical-align:middle;
    }
    .wrap{
      padding:18px; max-width:1400px; margin:0 auto;
    }
    .grid{
      display:grid; gap:18px;
      grid-template-columns: repeat(2, minmax(300px, 1fr));
      grid-auto-rows: minmax(320px, 1fr);
    }
    .card{
      background: linear-gradient(145deg, var(--panel) 0%, var(--panel-2) 100%);
      border:1px solid #1b2636;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative; overflow:hidden;
    }
    .bezel{
      position:absolute; inset:0; pointer-events:none;
      border-radius: var(--radius);
      box-shadow: inset 0 0 0 2px #0c121b, inset 0 0 0 3px #1e293b, inset 0 0 60px rgba(0,0,0,.35);
    }
    .screw{
      position:absolute; width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #a3b2c7, #6d7b91 60%, #425067);
      box-shadow: inset 0 0 2px rgba(0,0,0,.6); opacity:.65;
    }
    .screw::after{
      content:""; position:absolute; inset:3px 1px 3px 1px; background:#0f1420; transform:rotate(90deg);
      clip-path: polygon(0 45%,100% 45%,100% 55%,0 55%);
      opacity:.85;
    }
    .screw.tl{top:8px; left:10px}
    .screw.tr{top:8px; right:10px}
    .screw.bl{bottom:8px; left:10px}
    .screw.br{bottom:8px; right:10px}

    .card h2{
      margin:0; padding:12px 14px; font-size:14px; letter-spacing:.35px; font-weight:600;
      border-bottom:1px solid #1b2636;
      background: linear-gradient(180deg,#0f1522,#0c111c);
      display:flex; align-items:center; gap:10px;
    }
    .pill{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; color:#0b1220; background:#b9f6da}
    .pill.blue{background:#bfe7ff}
    .content{padding:14px; display:grid; grid-template-columns: 1.2fr .8fr; gap:14px; height:calc(100% - 52px)}
    .content.dmm-vertical{display:flex; flex-direction:column}
    .content.dmm-vertical .dmm-display{flex:1; min-height:0}
    .content.dmm-vertical .dmm-controls{margin-top:14px}
    .content.single{grid-template-columns: 1fr}

    /* DMM styles */
    .dmm-display{
      background: radial-gradient(600px 200px at 50% -10%, #0c111b 0%, #0c111b 60%, #0a0f18 100%);
      border:1px solid #1a2332; border-radius:12px; padding:12px 14px; min-height:220px;
      display:flex; justify-content:center; align-items:center; position:relative; overflow:hidden;
      text-shadow: 0 0 6px rgba(54,211,153,0.2);
    }
    .dmm-view{display:none; flex-direction:column; align-items:center; justify-content:center; gap:12px; width:100%; height:100%; text-align:center}
    .dmm-view.active{display:flex}
    .digits{
      display:flex; align-items:flex-end; gap:12px;
    }
    .digits span{
      background: linear-gradient(180deg, #c7ffe7 0%, #7ef1c6 40%, #3bd098 60%, #1aaa73 100%);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      filter: drop-shadow(0 5px 12px rgba(54, 211, 153, .18));
      display:inline-flex; align-items:flex-end;
    }
    .digits-value{
      font-variant-numeric: tabular-nums;
      font-size:56px; line-height:1; font-weight:700; letter-spacing:1px;
    }
    .digits-unit{
      font-size:28px; font-weight:600; letter-spacing:1.2px; text-transform:uppercase; padding-bottom:6px;
    }
    .dmm-meta{font-size:12px; color:var(--sub)}
    .binary-readout{display:flex; flex-direction:column; gap:4px; align-items:center; font-size:12px; color:var(--sub)}
    .binary-value{font-size:32px; font-weight:600; letter-spacing:1px; color:#7ef1c6}
    .binary-caption{text-transform:uppercase; letter-spacing:.2em; font-size:10px; color:#637186}
    .binary-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(32px,1fr)); gap:8px 10px; justify-items:center; width:100%; max-width:260px}
    .binary-empty{grid-column:1/-1; font-size:12px; color:#5f6b7c; letter-spacing:.05em; text-transform:uppercase}
    .binary-cell{display:flex; flex-direction:column; align-items:center; gap:4px}
    .binary-bit{width:100%; padding:6px 0; border-radius:6px; background:#0b1623; border:1px solid #1f2a3a; font-size:14px; font-weight:600; color:#c7d2e2; box-shadow: inset 0 1px 0 rgba(255,255,255,.05); text-align:center}
    .binary-bit.on{background:linear-gradient(180deg, rgba(126,241,198,.35) 0%, rgba(59,208,152,.35) 100%); color:#bff6dd; border-color:#2c4a3b}
    .binary-bit-label{font-size:9px; color:#516072; text-transform:uppercase; letter-spacing:.1em}
    .binary-meta{font-size:11px; color:#8793a3; text-align:center}
    .gauge{width:100%; max-width:260px}
    #dmm-gauge-svg{width:100%; height:auto}
    .gauge-arc{fill:none; stroke:#1f2b3d; stroke-width:10; stroke-linecap:round}
    .gauge-needle{stroke:#4cc3ff; stroke-width:4; stroke-linecap:round; filter:drop-shadow(0 0 6px rgba(76,195,255,.6))}
    .gauge-hub{fill:#0b1220; stroke:#4cc3ff; stroke-width:2}
    .gauge-tick{stroke:#2a3546; stroke-width:2; stroke-linecap:round}
    .gauge-tick.minor{stroke-width:1; stroke:#1a2434}
    .gauge-label{fill:#7c8b9f; font-size:10px; font-weight:500; text-shadow:none}
    .gauge-readout{display:flex; align-items:baseline; gap:6px; font-variant-numeric: tabular-nums}
    .gauge-value{font-size:32px; font-weight:600; color:#7ef1c6}
    .gauge-unit{font-size:16px; font-weight:600; color:#bfe7ff}
    .dmm-controls{display:flex; flex-direction:column; gap:12px}
    .dmm-controls .control-line{display:flex; flex-wrap:wrap; gap:18px; align-items:flex-start}
    .dmm-controls .control-group{flex:1 1 220px}
    .dmm-controls label,
    .dmm-controls .control-label{display:block; font-size:12px; color:#b5c0cd; margin-bottom:6px}
    .info-label{position:relative; display:inline-flex; align-items:center; gap:6px; cursor:help}
    .info-icon{width:16px; height:16px; border-radius:50%; background:#1f2b3d; color:#bfe7ff; font-size:10px; font-weight:600; display:inline-flex; align-items:center; justify-content:center; box-shadow:0 0 0 1px rgba(79,89,110,.45)}
    .info-label::after{content:attr(data-tooltip); position:absolute; left:0; bottom:calc(100% + 10px); background:#0d1420; color:#d1d8e5; padding:8px 10px; border-radius:8px; border:1px solid #1f2b3d; box-shadow:0 12px 24px rgba(0,0,0,.45); width:220px; max-width:260px; opacity:0; transform:translateY(6px); pointer-events:none; transition:opacity .2s ease, transform .2s ease; line-height:1.4}
    .info-label:hover::after,
    .info-label:focus-visible::after{opacity:1; transform:translateY(0)}
    .info-label:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:4px}
    .mode-row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .mode-buttons{display:flex; flex-wrap:wrap; gap:10px}
    .mode-row .btn.warn{margin-left:auto}
    @media (max-width: 720px){
      .dmm-controls .control-line{flex-direction:column}
      .mode-row{justify-content:flex-start}
      .mode-row .btn.warn{margin-left:0}
    }

    .dmm-controls label{display:block; font-size:12px; color:#b5c0cd; margin:8px 0 4px}
    .select, input[type="number"], input[type="text"]{
      width:100%; padding:8px 10px; background:#0c121b; color:var(--text);
      border:1px solid #223044; border-radius:8px; outline:none;
    }
    .btn{
      appearance:none; border:1px solid #1f2b3d; background:linear-gradient(180deg,#1a2434,#121b27);
      color:var(--text); padding:9px 12px; border-radius:10px; cursor:pointer;
      box-shadow:0 6px 14px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .btn.primary{ border-color:#1f3b2f; background:linear-gradient(180deg,#1f3b2f,#15281f); color:#bff6dd}
    .btn.warn{ border-color:#3b2f1f; background:linear-gradient(180deg,#3b2f1f,#2a2117); color:#ffd7a7}
    .btn.active{border-color:#2f4b66; background:linear-gradient(180deg,#1d2738,#162131); box-shadow:0 0 0 1px rgba(76,195,255,.2), inset 0 1px 0 rgba(255,255,255,.08)}
    .row{display:flex; gap:10px}
    .row>*{flex:1}
    .row.compact>*{flex:0 0 auto}
    .row.compact .grow{flex:1 1 auto}
    .badge{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #334155; color:#cbd5e1; background:#0b1220; display:inline-block}

    /* Generator */
    .knob{
      display:flex; flex-direction:column; gap:6px; align-items:stretch;
      background:#0c121b; border:1px solid #1a2332; border-radius:10px; padding:10px;
    }
    input[type="range"]{ width:100% }
    input[type="range"]{
      -webkit-appearance:none; height:6px; background: #152030; border-radius:999px; outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe7ff, #4ba8e6);
      box-shadow: 0 0 0 2px #0b1220, 0 8px 16px rgba(0,0,0,.5);
      border:1px solid #1e3a5f;
    }

    /* Scope */
    .scope-wrap{
      background:#060a11; border:1px solid #122033; border-radius:12px; overflow:hidden; position:relative;
    }
    .scope-head{
      display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border-bottom:1px solid #122033; background:#09121c;
      font-size:12px; color:#b7c3d1;
    }
    canvas{ display:block; width:100%; height:220px; background: #0a0f16}
    .scope-meta{display:flex; gap:8px; align-items:center}
    .scope-led{width:8px;height:8px;border-radius:50%; background:#67e8f9; box-shadow:0 0 10px rgba(76,195,255,.6)}

    /* Math editor */
    .math{
      display:grid; gap:10px; grid-template-columns: 1fr;
      height:100%;
      grid-template-rows: auto 1fr auto;
    }
    textarea{
      width:100%; height:160px; resize:vertical; min-height:120px;
      background:#0c121b; color:#e5e7eb; border:1px solid #1a2332; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .hint{font-size:12px; color:#a6b1bf}
    .list{
      border:1px dashed #203047; border-radius:10px; padding:10px; color:#cbd5e1; font-size:13px; background:#0a0f16;
    }

    /* Utils */
    .right{justify-content:flex-end}
    .muted{color:#9aa7b7}
    .unit{font-weight:600; color:#bfe7ff; margin-left:8px}
    .spacer{height:6px}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <header>
    <h1><span class="led"></span> MiniLabo — Console</h1>
    <div class="muted">Session PIN via cookie – Web en ligne</div>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- DMM -->
      <section class="card" id="card-dmm">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Multimètre <span class="badge" id="dmm-channel">CH1</span> <span class="pill" id="dmm-mode-pill">UDC</span></h2>
        <div class="content dmm-vertical">
          <div class="dmm-display">
            <div class="dmm-view active" data-view="digits">
              <div class="digits"><span class="digits-value" id="dmm-value">—.—</span><span class="digits-unit" id="dmm-unit-inline">V</span></div>
              <div class="spacer"></div>
              <div class="dmm-meta" id="dmm-meta">Entrée : — • Mode : — • Décimales : —</div>
            </div>
            <div class="dmm-view" data-view="binary">
              <div class="binary-readout">
                <div class="binary-value" id="dmm-binary-value">—</div>
                <div class="binary-caption">Valeur brute</div>
              </div>
              <div class="binary-grid" id="dmm-binary"></div>
              <div class="binary-meta" id="dmm-binary-meta"></div>
            </div>
            <div class="dmm-view" data-view="gauge">
              <div class="gauge" id="dmm-gauge">
                <svg id="dmm-gauge-svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
                  <path id="dmm-gauge-arc" class="gauge-arc" d="M20 160 A80 80 0 0 1 180 160" />
                  <g id="dmm-gauge-ticks"></g>
                  <line id="dmm-gauge-needle" class="gauge-needle" x1="100" y1="120" x2="100" y2="40" />
                  <circle class="gauge-hub" cx="100" cy="120" r="6" />
                </svg>
              </div>
            </div>
          </div>
          <div class="dmm-controls">
            <div class="control-line">
              <div class="control-group">
                <label for="dmm-select">Canal</label>
                <select id="dmm-select" class="select"></select>
              </div>
              <div class="control-group">
                <div class="control-label info-label" data-tooltip="Le DMM est actualisé toutes les 2 s. Les décimales sont définies par la config du canal." tabindex="0">Affichage <span class="info-icon" aria-hidden="true">i</span></div>
                <div class="mode-row">
                  <div class="mode-buttons">
                    <button class="btn" data-mode="digits">Numérique</button>
                    <button class="btn" data-mode="binary">Binaire</button>
                    <button class="btn" data-mode="gauge">Cadran</button>
                  </div>
                  <button class="btn warn" id="dmm-hold">Hold</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- FUNCGEN -->
      <section class="card" id="card-func">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Générateur de fonctions <span class="pill blue" id="func-target-pill">cible : —</span></h2>
        <div class="content">
          <div class="knob">
            <div class="row">
              <div>
                <label>Amplitude (%)</label>
                <input id="func-amp" type="range" min="0" max="100" value="50" />
              </div>
              <div>
                <label>Offset (%)</label>
                <input id="func-off" type="range" min="0" max="100" value="0" />
              </div>
            </div>
            <div class="row">
              <div>
                <label>Fréquence (Hz)</label>
                <input id="func-freq" type="number" min="0.1" step="0.1" value="50" />
              </div>
              <div>
                <label>Forme</label>
                <select id="func-wave" class="select">
                  <option value="sine">Sinus</option>
                  <option value="square">Carré</option>
                  <option value="triangle">Triangle</option>
                </select>
              </div>
            </div>
            <div class="row">
              <div>
                <label>Cible IO</label>
                <select id="func-target" class="select"></select>
              </div>
              <div class="right" style="display:flex; align-items:flex-end">
                <button class="btn primary" id="func-apply">Appliquer</button>
              </div>
            </div>
            <div class="hint">La sortie est appliquée en % de l’échelle de l’IO cible (DAC/0‑10 V).</div>
          </div>
          <div>
            <div class="list" id="func-status">Prêt.</div>
            <div class="spacer"></div>
            <div class="hint">Astuce : définis une amplitude puis ajoute un offset pour centrer ton signal.</div>
          </div>
        </div>
      </section>

      <!-- SCOPE -->
      <section class="card" id="card-scope">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Oscilloscope <span class="badge" id="scope-chan">CH1</span> <span class="pill blue" id="scope-timebase">— ms/div</span></h2>
        <div class="content single">
          <div class="scope-wrap">
            <div class="scope-head">
              <div class="scope-meta"><span class="scope-led"></span> Live</div>
              <div class="muted" id="scope-meta">—</div>
            </div>
            <canvas id="scope-canvas" width="800" height="240"></canvas>
          </div>
          <div class="hint">Affichage 1 canal. La base de temps et la V/div se règlent dans la page Scope complète.</div>
        </div>
      </section>

      <!-- MATH EDITOR -->
      <section class="card" id="card-math">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Éditeur d’équations (IO math)</h2>
        <div class="content single">
          <div class="math">
            <div class="hint">Une équation par ligne → <code>io_out = (io_a0 * 3.3) + 0.1</code> • Variables = noms d’IO logiques • Fonctions autorisées basiques ( + − × ÷, abs, min, max ).</div>
            <textarea id="math-text" spellcheck="false" placeholder="ex: v_div = IO_A0 * 3.3&#10;v_out = v_div * 0.5"></textarea>
            <div class="row">
              <button class="btn" id="math-load">Charger</button>
              <button class="btn primary" id="math-save">Enregistrer</button>
            </div>
            <div class="list" id="math-status">Prêt.</div>
          </div>
        </div>
      </section>

    </div>
  </div>

  <script>
    const $ = (q)=>document.querySelector(q);
    const j = (url,opts={})=>fetch(url,Object.assign({headers:{'Content-Type':'application/json'}},opts));

    /* --------- DMM --------- */
    let dmmHold = false, dmmMode = 'digits';
    const dmmState = {
      config: [],
      snapshot: [],
      holdValue: null,
      holdUnit: null,
      holdNumeric: null,
      holdBinary: null,
      lastNumericValue: null,
      lastBinaryValue: null,
      gaugeRanges: {}
    };

    function getDmmMeta(ioId){
      return dmmState.config.find(ch=>ch.io===ioId) || null;
    }
    function updateDmmHeader(meta){
      const badge = $('#dmm-channel');
      const pill = $('#dmm-mode-pill');
      if(badge) badge.textContent = meta?.label || meta?.io || '—';
      if(pill) pill.textContent = meta?.mode || '—';
    }
    const gaugeGeom = { centerX: 100, centerY: 120, radius: 80, startAngle: -210, endAngle: 30 };
    function parseNumeric(value){
      const n = Number(value);
      return Number.isFinite(n) ? n : null;
    }
    function formatDecimal(value, maxDecimals=4){
      if(!Number.isFinite(value)) return '—';
      let txt = value.toFixed(maxDecimals);
      txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
      return txt;
    }
    function gaugePolar(angleDeg, radius){
      const rad = angleDeg * Math.PI / 180;
      return {
        x: gaugeGeom.centerX + Math.cos(rad) * radius,
        y: gaugeGeom.centerY + Math.sin(rad) * radius,
      };
    }
    function niceCeil(value){
      if(!Number.isFinite(value) || value === 0){ return 1; }
      const magnitude = Math.abs(value);
      const exponent = Math.floor(Math.log10(magnitude));
      const power = Math.pow(10, exponent);
      const scaled = magnitude / power;
      let nice;
      if(scaled <= 1){ nice = 1; }
      else if(scaled <= 2){ nice = 2; }
      else if(scaled <= 5){ nice = 5; }
      else { nice = 10; }
      return nice * power;
    }
    function updateDmmMode(){
      document.querySelectorAll('#card-dmm [data-mode]').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.mode === dmmMode);
      });
      document.querySelectorAll('#card-dmm .dmm-view').forEach(view=>{
        view.classList.toggle('active', view.dataset.view === dmmMode);
      });
    }
    function determineBinaryBitCount(value){
      if(!Number.isFinite(value)) return 8;
      const abs = Math.abs(value);
      if(abs < 16) return 8;
      if(abs < 256) return 8;
      if(abs < 4096) return 12;
      if(abs < 65536) return 16;
      if(abs < 16777216) return 24;
      return 32;
    }
    function updateDmmBinary(value){
      const grid = $('#dmm-binary');
      const meta = $('#dmm-binary-meta');
      const rawEl = $('#dmm-binary-value');
      if(!grid || !meta || !rawEl) return;
      grid.innerHTML = '';
      if(!Number.isFinite(value)){
        grid.innerHTML = '<div class="binary-empty">Aucune donnée</div>';
        rawEl.textContent = '—';
        meta.textContent = 'Valeur non disponible';
        return;
      }
      const rounded = Math.round(value);
      rawEl.textContent = formatDecimal(value, 6);
      const absValue = Math.abs(rounded);
      const bits = determineBinaryBitCount(absValue);
      const binary = absValue.toString(2).padStart(bits, '0');
      for(let i=0; i<bits; i++){
        const bitIndex = bits - 1 - i;
        const bit = binary[bitIndex];
        const cell = document.createElement('div');
        cell.className = 'binary-cell';
        const bitEl = document.createElement('div');
        bitEl.className = 'binary-bit' + (bit === '1' ? ' on' : '');
        bitEl.textContent = bit;
        const label = document.createElement('div');
        label.className = 'binary-bit-label';
        label.textContent = '2^' + bitIndex;
        cell.appendChild(bitEl);
        cell.appendChild(label);
        grid.appendChild(cell);
      }
      meta.textContent = `Bits : ${bits} • Arrondi : ${rounded}`;
    }
    function buildAutoGaugeRange(value){
      const base = Number.isFinite(value) ? value : 0;
      const magnitude = Math.max(Math.abs(base), 1);
      const max = niceCeil(magnitude);
      if(base >= 0){
        return {min: 0, max, explicit: false};
      }
      return {min: -max, max, explicit: false};
    }
    function getGaugeRange(ioId, meta, snapshot, numericValue){
      const candidatesMin = [meta?.min, meta?.minValue, meta?.minimum, meta?.rangeMin, meta?.range?.min, meta?.lower, meta?.low];
      const candidatesMax = [meta?.max, meta?.maxValue, meta?.maximum, meta?.rangeMax, meta?.range?.max, meta?.upper, meta?.high];
      const explicitMin = candidatesMin.map(parseNumeric).find(v=>v!==null);
      const explicitMax = candidatesMax.map(parseNumeric).find(v=>v!==null);
      if(explicitMin != null && explicitMax != null && explicitMin < explicitMax){
        const range = {min: explicitMin, max: explicitMax, explicit: true};
        dmmState.gaugeRanges[ioId] = range;
        return range;
      }
      const previous = dmmState.gaugeRanges[ioId];
      const baseRaw = parseNumeric(snapshot?.raw);
      const baseValue = Number.isFinite(numericValue) ? numericValue : (Number.isFinite(baseRaw) ? baseRaw : null);
      if(previous && previous.explicit){
        return previous;
      }
      if(previous && !Number.isFinite(baseValue)){
        return previous;
      }
      let range = previous;
      if(!range){
        range = buildAutoGaugeRange(baseValue);
      }else if(Number.isFinite(baseValue) && (baseValue < range.min || baseValue > range.max)){
        range = buildAutoGaugeRange(baseValue);
      }
      if(!range){
        range = {min: -1, max: 1, explicit: false};
      }
      if(range.max <= range.min){
        range = {min: range.min - 1, max: range.max + 1, explicit: range.explicit || false};
      }
      dmmState.gaugeRanges[ioId] = range;
      return range;
    }
    function updateGaugeTicks(range){
      const ticksGroup = document.getElementById('dmm-gauge-ticks');
      if(!ticksGroup) return;
      const arc = document.getElementById('dmm-gauge-arc');
      const largeArc = (gaugeGeom.endAngle - gaugeGeom.startAngle) > 180 ? 1 : 0;
      if(arc){
        const start = gaugePolar(gaugeGeom.startAngle, gaugeGeom.radius);
        const end = gaugePolar(gaugeGeom.endAngle, gaugeGeom.radius);
        arc.setAttribute('d', `M ${start.x.toFixed(2)} ${start.y.toFixed(2)} A ${gaugeGeom.radius} ${gaugeGeom.radius} 0 ${largeArc} 1 ${end.x.toFixed(2)} ${end.y.toFixed(2)}`);
      }
      ticksGroup.innerHTML = '';
      const majorCount = 5;
      const minorPerSegment = 4;
      const span = range.max - range.min;
      const labelDecimals = (()=>{
        if(span === 0) return 0;
        const step = span / (majorCount - 1);
        let decimals = 0, scaled = step;
        while(decimals < 3 && scaled > 0 && scaled < 1){ decimals += 1; scaled *= 10; }
        return decimals;
      })();
      const formatLabel = (value)=>{
        if(!Number.isFinite(value)) return '0';
        let txt = value.toFixed(labelDecimals);
        txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
        return txt;
      };
      const createLine = (angle, length, className)=>{
        const outer = gaugePolar(angle, gaugeGeom.radius);
        const inner = gaugePolar(angle, gaugeGeom.radius - length);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', inner.x.toFixed(2));
        line.setAttribute('y1', inner.y.toFixed(2));
        line.setAttribute('x2', outer.x.toFixed(2));
        line.setAttribute('y2', outer.y.toFixed(2));
        line.setAttribute('class', className);
        ticksGroup.appendChild(line);
      };
      for(let i=0;i<majorCount;i++){
        const ratio = i/(majorCount-1);
        const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
        createLine(angle, 14, 'gauge-tick');
        const labelPos = gaugePolar(angle, gaugeGeom.radius + 18);
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', labelPos.x.toFixed(2));
        text.setAttribute('y', labelPos.y.toFixed(2));
        text.setAttribute('text-anchor','middle');
        text.setAttribute('dominant-baseline','middle');
        text.setAttribute('class','gauge-label');
        text.textContent = formatLabel(range.min + ratio * span);
        ticksGroup.appendChild(text);
        if(i < majorCount-1){
          for(let m=1;m<=minorPerSegment;m++){
            const minorRatio = (i + m/(minorPerSegment+1)) / (majorCount-1);
            const minorAngle = gaugeGeom.startAngle + minorRatio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
            createLine(minorAngle, 8, 'gauge-tick minor');
          }
        }
      }
    }
    function updateDmmGauge(value, formatted, unit, meta, snapshot, ioId){
      const range = getGaugeRange(ioId, meta, snapshot, value);
      updateGaugeTicks(range);
      const needle = document.getElementById('dmm-gauge-needle');
      if(!needle) return;
      const span = range.max - range.min;
      const effectiveSpan = span === 0 ? 1 : span;
      const fallback = range.min + effectiveSpan / 2;
      const clamped = Number.isFinite(value) ? Math.min(Math.max(value, range.min), range.max) : fallback;
      const ratio = (clamped - range.min) / effectiveSpan;
      const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
      const tip = gaugePolar(angle, gaugeGeom.radius - 18);
      needle.setAttribute('x1', gaugeGeom.centerX.toFixed(2));
      needle.setAttribute('y1', gaugeGeom.centerY.toFixed(2));
      needle.setAttribute('x2', tip.x.toFixed(2));
      needle.setAttribute('y2', tip.y.toFixed(2));
      needle.setAttribute('opacity', Number.isFinite(value) ? '1' : '0.25');
    }
    function buildFallbackMeta(snapshot){
      return snapshot.map((ch, idx)=>({
        label: `CH${idx+1}`,
        io: ch.id || `CH${idx+1}`,
        mode: 'UDC',
        decimals: 2,
        unit: ch.unit || ''
      }));
    }
    function ensureDmmOptions(snapshot){
      const sel = $('#dmm-select');
      if(!sel) return;
      const previous = sel.value;
      const metaList = dmmState.config.length ? dmmState.config : buildFallbackMeta(snapshot||[]);
      if(!metaList.length){
        sel.innerHTML='';
        updateDmmHeader(null);
        return;
      }
      sel.innerHTML='';
      metaList.forEach(meta=>{
        const opt=document.createElement('option');
        opt.value = meta.io;
        const baseLabel = meta.label || meta.io || '—';
        const detail = meta.io && meta.io !== baseLabel ? ` — ${meta.io}` : '';
        const modeLabel = meta.mode ? ` (${meta.mode})` : '';
        opt.textContent = `${baseLabel}${detail}${modeLabel}`;
        sel.appendChild(opt);
      });
      if(previous && metaList.some(m=>m.io===previous)){
        sel.value = previous;
      }
      if(!sel.value){
        sel.value = metaList[0].io;
      }
      const currentMeta = metaList.find(m=>m.io===sel.value) || metaList[0];
      updateDmmHeader(currentMeta);
    }
    function renderDmm(){
      updateDmmMode();
      const sel = $('#dmm-select');
      if(!sel) return;
      const ioId = sel.value || dmmState.config[0]?.io || dmmState.snapshot[0]?.id || '';
      if(!sel.value && ioId) sel.value = ioId;
      const snapshot = dmmState.snapshot.find(ch=>ch.id===ioId) || dmmState.snapshot[0];
      const meta = getDmmMeta(ioId) || (snapshot ? {
        label: snapshot.id || '—',
        io: snapshot.id || '—',
        mode: 'UDC',
        decimals: 2,
        unit: snapshot.unit || ''
      } : null);
      if(meta) updateDmmHeader(meta);
      const unit = (snapshot?.unit ?? meta?.unit ?? '').toString();
      let formatted = '—.—';
      let numericValue = null;
      if(snapshot && snapshot.value !== undefined && snapshot.value !== null){
        const valueNumber = Number(snapshot.value);
        const decimals = typeof meta?.decimals === 'number' ? meta.decimals : null;
        if(Number.isFinite(valueNumber)){
          numericValue = valueNumber;
          formatted = decimals !== null ? valueNumber.toFixed(decimals) : valueNumber.toString();
        }else{
          formatted = String(snapshot.value);
        }
      }
      dmmState.lastNumericValue = Number.isFinite(numericValue) ? numericValue : null;
      const rawNumber = parseNumeric(snapshot?.raw);
      const binaryValue = Number.isFinite(rawNumber) ? rawNumber : dmmState.lastNumericValue;
      dmmState.lastBinaryValue = Number.isFinite(binaryValue) ? binaryValue : null;
      const displayFormatted = dmmHold && dmmState.holdValue !== null ? dmmState.holdValue : formatted;
      const displayUnit = dmmHold && dmmState.holdUnit !== null ? dmmState.holdUnit : unit;
      $('#dmm-value').textContent = displayFormatted;
      $('#dmm-unit-inline').textContent = displayUnit;
      const effectiveNumeric = dmmHold && dmmState.holdNumeric !== null ? dmmState.holdNumeric : dmmState.lastNumericValue;
      const effectiveBinary = dmmHold && dmmState.holdBinary !== null ? dmmState.holdBinary : dmmState.lastBinaryValue;
      const metaParts = [];
      metaParts.push('Entrée : ' + (meta?.io || snapshot?.id || '—'));
      metaParts.push('Mode : ' + (meta?.mode || '—'));
      metaParts.push('Décimales : ' + (typeof meta?.decimals === 'number' ? meta.decimals : '—'));
      $('#dmm-meta').textContent = metaParts.join(' • ');
      updateDmmBinary(effectiveBinary);
      updateDmmGauge(effectiveNumeric, displayFormatted, displayUnit, meta, snapshot, ioId);
    }
    async function loadDmmConfig(){
      try{
        const r = await j('/api/config?area=dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const cfg = await r.json();
        if(Array.isArray(cfg)){
          dmmState.config = cfg.map((entry, idx)=>{
            const mode = entry.mode || entry.acquisition || 'UDC';
            return {
              label: entry.name || `CH${idx+1}`,
              io: entry.io || `CH${idx+1}`,
              mode,
              decimals: typeof entry.decimals === 'number' ? entry.decimals : 2,
              unit: entry.unit || (mode === 'UDC' ? 'V' : ''),
            };
          });
        }else{
          dmmState.config = [];
        }
      }catch(e){
        console.warn(e);
        dmmState.config = [];
      }
      ensureDmmOptions(dmmState.snapshot);
      renderDmm();
    }
    async function loadDmm(){
      try{
        const r = await j('/api/dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        const channels = Array.isArray(data.channels) ? data.channels : [];
        dmmState.snapshot = channels.map((ch, idx)=>({
          id: ch.id || ch.name || `CH${idx+1}`,
          raw: ch.raw,
          value: ch.value,
          unit: ch.unit
        }));
        const sel = $('#dmm-select');
        if(sel && sel.options.length===0){
          ensureDmmOptions(dmmState.snapshot);
        }
        if(!dmmHold){
          dmmState.holdValue = null;
          dmmState.holdUnit = null;
          dmmState.holdNumeric = null;
          dmmState.holdBinary = null;
        }
        renderDmm();
      }catch(e){
        console.warn(e);
      }
    }
    $('#dmm-hold').addEventListener('click',()=>{
      dmmHold = !dmmHold;
      if(dmmHold){
        dmmState.holdValue = $('#dmm-value').textContent;
        dmmState.holdUnit = $('#dmm-unit-inline').textContent;
        dmmState.holdNumeric = dmmState.lastNumericValue;
        dmmState.holdBinary = dmmState.lastBinaryValue;
      }else{
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      $('#dmm-hold').textContent = dmmHold?'Hold (ON)':'Hold';
      renderDmm();
    });
    $('#dmm-select').addEventListener('change',(e)=>{
      const meta = getDmmMeta(e.target.value) || dmmState.config[0] || null;
      updateDmmHeader(meta);
      if(dmmHold){
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      renderDmm();
    });
    document.querySelectorAll('#card-dmm [data-mode]').forEach(b=>b.addEventListener('click',()=>{
      dmmMode = b.dataset.mode;
      updateDmmMode();
      renderDmm();
    }));
    updateDmmMode();

    /* --------- FUNCGEN --------- */
    async function loadIOForFunc(){
      const r = await j('/api/io');
      if(!r.ok) return;
      const arr = await r.json();
      const sel = $('#func-target');
      sel.innerHTML='';
      arr.forEach(io=>{
        const o=document.createElement('option'); o.value=io.id; o.textContent=io.id; sel.appendChild(o);
      });
      const cfg = await (await j('/api/config/funcgen')).json().catch(()=>null);
      if(cfg){
        $('#func-amp').value = cfg.amp ?? 50;
        $('#func-off').value = cfg.offset ?? 0;
        $('#func-freq').value = cfg.freq ?? 50;
        $('#func-wave').value = cfg.wave ?? 'sine';
        if(cfg.target){ sel.value = cfg.target; }
        $('#func-target-pill').textContent = 'cible : ' + (sel.value||'—');
      }
    }
    async function applyFunc(){
      const payload = {
        target: $('#func-target').value,
        freq: parseFloat($('#func-freq').value),
        amplitude: parseFloat($('#func-amp').value),
        offset: parseFloat($('#func-off').value),
        wave: $('#func-wave').value
      };
      try{
        const r = await j('/api/funcgen',{method:'POST', body: JSON.stringify(payload)});
        const ok = r.ok ? await r.json() : {success:false};
        $('#func-status').textContent = ok.success ? 'Paramètres appliqués.' : 'Erreur d’application.';
        $('#func-target-pill').textContent = 'cible : ' + (payload.target||'—');
      }catch(e){
        $('#func-status').textContent = 'Erreur réseau.';
      }
    }
    $('#func-apply').addEventListener('click', applyFunc);

    /* --------- SCOPE (aperçu 1 canal) --------- */
    const scopeCanvas = $('#scope-canvas');
    const ctx = scopeCanvas.getContext('2d');
    function drawGrid(){
      const w=scopeCanvas.width, h=scopeCanvas.height;
      ctx.fillStyle = '#0a0f16'; ctx.fillRect(0,0,w,h);
      // grille principale 10x8
      const cols=10, rows=8;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      ctx.lineWidth=1;
      for(let i=0;i<=cols;i++){
        const x = Math.round(i*w/cols)+.5;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      }
      for(let j=0;j<=rows;j++){
        const y = Math.round(j*h/rows)+.5;
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
      }
      // sous-grille
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-sub');
      ctx.lineWidth=1;
      const sub=5;
      for(let i=0;i<cols;i++){
        for(let s=1;s<sub;s++){
          const x = Math.round((i+s/sub)*w/cols)+.5;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
        }
      }
      for(let j=0;j<rows;j++){
        for(let s=1;s<sub;s++){
          const y = Math.round((j+s/sub)*h/rows)+.5;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
        }
      }
    }
    function plot(samples, color='#4cc3ff'){
      const w=scopeCanvas.width, h=scopeCanvas.height;
      if(!samples || samples.length<2){ return; }
      ctx.strokeStyle = color;
      ctx.lineWidth=2;
      ctx.beginPath();
      const N = samples.length;
      // Compute scale using max absolute value, fallback 1
      let vmax = 1;
      for(let i=0;i<N;i++){
        const v = Math.abs(samples[i]);
        if(v>vmax) vmax = v;
      }
      const yMid = h/2, scale = (h*0.4)/vmax;
      for(let i=0;i<N;i++){
        const x = i*(w-10)/(N-1)+5;
        const y = yMid - samples[i]*scale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    async function loadScope(){
      try{
        const r = await j('/api/scope');
        if(!r.ok) return;
        const data = await r.json();
        const chNames = Object.keys(data.channels||{});
        const first = chNames[0];
        const samples = first ? data.channels[first] : null;
        $('#scope-chan').textContent = first || '—';
        $('#scope-timebase').textContent = (data.timebase_ms_per_div ?? '—') + ' ms/div';
        $('#scope-meta').textContent = samples ? (samples.length+' pts') : '—';
        drawGrid(); plot(samples||[]);
      }catch(e){
        drawGrid();
      }
    }

    /* --------- MATH EDITOR --------- */
    async function loadMath(){
      try{
        const r = await j('/api/config/math');
        if(!r.ok){ $('#math-status').textContent='Impossible de charger la config.'; return; }
        const cfg = await r.json();
        const expr = (cfg.expressions||[]).join('\n');
        $('#math-text').value = expr;
        $('#math-status').textContent='Config chargée.';
      }catch(e){ $('#math-status').textContent='Erreur réseau.'; }
    }
    async function saveMath(){
      const lines = $('#math-text').value.split('\n').map(s=>s.trim()).filter(Boolean);
      const body = JSON.stringify({expressions: lines});
      try{
        const r = await j('/api/config/math?area=math',{method:'PUT', body});
        $('#math-status').textContent = r.ok ? 'Enregistré.' : 'Erreur d’enregistrement.';
      }catch(e){ $('#math-status').textContent='Erreur réseau.'; }
    }
    $('#math-load').addEventListener('click', loadMath);
    $('#math-save').addEventListener('click', saveMath);

    /* --------- Boot --------- */
    async function boot(){
      drawGrid();
      await loadDmmConfig();
      await loadDmm();
      loadIOForFunc();
      loadMath();
      loadScope();
      setInterval(()=>{ loadDmm(); }, 2000);   // DMM 2 Hz
      setInterval(()=>{ loadScope(); }, 150);  // Scope ~6-7 fps (léger)
    }
    document.addEventListener('DOMContentLoaded', ()=>{ boot(); });
  </script>
</body>
</html>
