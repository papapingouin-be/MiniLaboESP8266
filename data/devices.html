<!DOCTYPE html>
<html lang="fr">
<!--
  devices.html

  Cette page regroupe les quatre appareils principaux du MiniLabo dans
  une interface unique composée de quatre cadrans : multimètre,
  générateur de fonctions, oscilloscope et éditeur d’équations
  mathématiques.  Elle est destinée à servir d’écran de contrôle
  « console » rappelant un banc de mesures complet.  Chaque cadran
  fonctionne indépendamment : le multimètre lit les valeurs exposées
  par l’API DMM, le générateur permet d’ajuster amplitude, offset,
  fréquence et forme sur une sortie, l’oscilloscope trace un canal en
  direct et l’éditeur math gère des formules créant des IO
  dérivées.

  TODO:
  – Brancher chaque cadran sur les appels API correspondants.  Voir
    les fonctions loadDmm(), loadIOForFunc(), loadScope() et
    loadMath() plus bas pour des squelettes d’implémentation.  Ces
    fonctions interrogent respectivement /api/dmm, /api/io,
    /api/scope et /api/config?area=math.
  – Gérer les modes d’affichage du multimètre (binaire et cadran
    analogique) : seuls les chiffres sont affichés pour l’instant.
  – Implémenter la mise à jour en temps réel de l’oscilloscope selon
    la base de temps et l’échelle verticale définies dans
    scope.json.  Actuellement un auto‑scale basique est utilisé.
  – Ajouter un panneau de logs ou de messages de statut si
    nécessaire.
  – Cette page n’est pas liée par défaut dans index.html ; ajoutez
    simplement un lien vers devices.html si vous souhaitez
    l’utiliser comme tableau de bord.
-->
<head>
  <meta charset="utf-8" />
  <title>MiniLabo — Console 4 cadrans</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0c0f14;
      --panel:#121722;
      --panel-2:#0f141d;
      --bezel:#1a2230;
      --accent:#36d399;
      --accent-2:#4cc3ff;
      --warn:#ffb86b;
      --danger:#ff6b6b;
      --text:#e5e7eb;
      --sub:#98a2b3;
      --grid:#1f2a3a;
      --grid-sub:#162030;
      --shadow: 0 10px 25px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
      background: radial-gradient(1200px 800px at 70% -200px, #111827 0%, #0b0e13 60%, #090c11 100%);
      color:var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 20px; border-bottom:1px solid #1f2937;
      background:linear-gradient(180deg,#101522 0%, #0e1220 100%);
      position:sticky; top:0; z-index:10;
    }
    header h1{margin:0; font-size:18px; letter-spacing:.3px; font-weight:600}
    header .led{
      width:10px;height:10px;border-radius:50%;
      box-shadow:0 0 12px rgba(54,211,153,.55), inset 0 0 4px rgba(0,0,0,.6);
      background:radial-gradient(circle at 30% 30%, #7fffbf, #11a86e);
      margin-right:8px; display:inline-block; vertical-align:middle;
    }
    .wrap{
      padding:18px; max-width:1400px; margin:0 auto;
    }
    .grid{
      display:grid; gap:18px;
      grid-template-columns: repeat(2, minmax(300px, 1fr));
      grid-auto-rows: minmax(320px, 1fr);
    }
    .card{
      background: linear-gradient(145deg, var(--panel) 0%, var(--panel-2) 100%);
      border:1px solid #1b2636;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative; overflow:hidden;
    }
    .bezel{
      position:absolute; inset:0; pointer-events:none;
      border-radius: var(--radius);
      box-shadow: inset 0 0 0 2px #0c121b, inset 0 0 0 3px #1e293b, inset 0 0 60px rgba(0,0,0,.35);
    }
    .screw{
      position:absolute; width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #a3b2c7, #6d7b91 60%, #425067);
      box-shadow: inset 0 0 2px rgba(0,0,0,.6); opacity:.65;
    }
    .screw::after{
      content:""; position:absolute; inset:3px 1px 3px 1px; background:#0f1420; transform:rotate(90deg);
      clip-path: polygon(0 45%,100% 45%,100% 55%,0 55%);
      opacity:.85;
    }
    .screw.tl{top:8px; left:10px}
    .screw.tr{top:8px; right:10px}
    .screw.bl{bottom:8px; left:10px}
    .screw.br{bottom:8px; right:10px}

    .card h2{
      margin:0; padding:12px 14px; font-size:14px; letter-spacing:.35px; font-weight:600;
      border-bottom:1px solid #1b2636;
      background: linear-gradient(180deg,#0f1522,#0c111c);
      display:flex; align-items:center; gap:10px;
    }
    .pill{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; color:#0b1220; background:#b9f6da}
    .pill.blue{background:#bfe7ff}
    .pill.offline{background:#243244; color:#bfe7ff}
    .content{padding:14px; display:grid; grid-template-columns: 1.2fr .8fr; gap:14px; height:calc(100% - 52px)}
    .content.dmm-vertical{display:flex; flex-direction:column; height:calc(100% - 52px)}
    .content.dmm-vertical .dmm-display{flex:3 1 0; min-height:0; width:100%}
    .content.dmm-vertical .dmm-controls{flex:1 1 0; margin-top:14px; width:100%}
    .content.single{grid-template-columns: 1fr}

    /* FUNCGEN styles */
    #card-func .content{
      padding:16px;
      height:calc(100% - 52px);
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    .func-layout{
      width:100%;
      height:100%;
      border-collapse:separate;
      border-spacing:6px;
      table-layout:fixed;
      margin:0;
    }
    #card-func .content > .func-layout{flex:1 1 auto}
    .func-layout .func-col-label{width:9%}
    .func-layout .func-col-main{width:61%}
    .func-layout .func-col-side{width:30%}
    .func-layout td{
      border:1px solid #1b2636;
      border-radius:12px;
      background:rgba(12,18,30,.82);
      padding:10px 12px;
      vertical-align:top;
    }
    .func-meta-cell{
      text-align:center;
      background:linear-gradient(160deg, rgba(13,19,30,.9) 0%, rgba(12,18,29,.8) 100%);
      padding:6px 10px;
    }
    .func-meta-cell .func-summary{justify-content:center; font-size:13px; color:#d0def6}
    .func-output-cell{
      background:linear-gradient(160deg, rgba(15,23,35,.9) 0%, rgba(12,18,28,.8) 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .func-output-box{display:flex; flex-direction:column; gap:6px}
    .func-output-box label{font-size:12px; color:#9aa6bb; text-transform:uppercase; letter-spacing:.08em}
    .func-output-box .select{min-width:160px}
    .func-output-box .func-output-name{font-size:18px; font-weight:600; letter-spacing:.03em}
    .func-output-box .func-output-type{font-size:12px; letter-spacing:.18em; color:#58e4ff; text-transform:uppercase}
    .func-output-box .pill{align-self:flex-start}
    .func-display-cell{padding:0; background:none; height:100%;}
    .func-display{height:100%; min-height:260px; border-radius:16px; width:100%; display:flex; align-items:stretch;}
    .func-output-cell .func-adjust-cell{
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(12,18,30,.75);
      padding:12px;
      border-radius:10px;
    }
    .func-adjust-stack{display:flex; flex-direction:column; gap:10px; width:100%; height:100%; align-items:stretch; justify-content:space-between}
    .func-adjust-buttons{display:flex; flex-direction:column; gap:8px; width:100%; flex:1 1 auto}
    .func-adjust-buttons .func-digit-btn{min-width:0; width:100%; min-height:52px; flex:1 1 auto}
    .func-adjust-scale{display:flex; flex-wrap:wrap; gap:6px; justify-content:center; align-items:center}
    .func-scale-btn{
      border:none;
      background:linear-gradient(160deg, rgba(30,45,68,.85) 0%, rgba(16,24,38,.9) 100%);
      color:#c8d5ee;
      font-size:11px;
      padding:6px 10px;
      border-radius:10px;
      box-shadow: inset 0 0 0 1px rgba(62,94,138,.35), 0 6px 14px rgba(0,0,0,.35);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      min-width:54px;
      cursor:pointer;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .func-scale-btn .arrow{font-size:9px; line-height:1; opacity:.8}
    .func-scale-btn .func-scale-text{font-variant-numeric: tabular-nums; letter-spacing:.05em}
    .func-scale-btn.active{
      background:linear-gradient(150deg, rgba(80,220,255,.35) 0%, rgba(20,125,220,.55) 100%);
      color:#051020;
      box-shadow:0 10px 24px rgba(56,160,255,.28), inset 0 0 0 1px rgba(12,20,32,.55);
    }
    .func-scale-btn:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:3px}
    .func-param-zone{display:flex; flex-direction:column; gap:12px; align-items:center}
    .func-wave-cell{background:linear-gradient(160deg, rgba(12,18,30,.82) 0%, rgba(10,14,22,.9) 100%); padding:12px 10px}
    .func-wave-list{display:flex; gap:8px; flex-wrap:wrap; justify-content:center}
    .func-action-cell{background:linear-gradient(160deg, rgba(11,18,28,.92) 0%, rgba(8,12,21,.9) 100%)}
    .func-action-stack{display:flex; flex-direction:column; gap:12px; height:100%}
    .func-action-stack .func-hint{margin-top:auto}
    @media (max-width: 980px){
      #card-func .content{padding:12px}
        .func-layout{border-spacing:4px}
        .func-layout td{padding:8px 10px}
        .func-param-btn{padding:8px 12px; min-width:68px; min-height:44px}
        .func-param-btn .symbol{font-size:18px}
    }
    .func-wave-btn{
      border:none;
      background:rgba(76,195,255,.12);
      color:#c8f3ff;
      padding:6px 12px;
      border-radius:10px;
      font-size:12px;
      letter-spacing:.05em;
      text-transform:uppercase;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow: inset 0 0 0 1px rgba(76,195,255,.3);
      transition:background .2s ease, transform .2s ease, box-shadow .2s ease;
    }
    .func-wave-btn svg{width:18px; height:18px; stroke:currentColor; stroke-width:1.6; fill:none; opacity:.8}
    .func-wave-btn.active{
      background:linear-gradient(135deg, rgba(80,220,255,.35) 0%, rgba(27,155,240,.55) 100%);
      color:#0b1220;
      box-shadow:0 12px 28px rgba(76,195,255,.25), inset 0 0 0 1px rgba(12,20,32,.35);
    }
    .func-wave-btn:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:3px}
    .func-display{
      position:relative;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap:18px;
      padding:22px;
      border-radius:18px;
      background:radial-gradient(140% 120% at 50% 0%, rgba(76,195,255,.08) 0%, rgba(18,25,37,.85) 60%, rgba(10,14,21,.95) 100%);
      box-shadow: inset 0 0 0 1px rgba(64,91,130,.35), 0 20px 40px rgba(4,8,14,.55);
    }
    .func-digit-btn{
      border:none;
      border-radius:12px;
      background: linear-gradient(150deg, rgba(13,20,32,.9) 0%, rgba(19,29,45,1) 55%, rgba(11,16,27,1) 100%);
      color:#9bd5ff;
      font-size:28px;
      font-family:'Share Tech Mono', 'Segment7', 'DS-Digital', 'Courier New', monospace;
      letter-spacing:.12em;
      text-shadow: 0 0 14px rgba(76,195,255,.45);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: inset 0 0 0 1px rgba(62,94,138,.45), 0 10px 24px rgba(0,0,0,.4);
      transition:transform .15s ease, box-shadow .2s ease, background .2s ease;
      min-width:64px;
      min-height:52px;
    }
    .func-digit-btn:hover{transform:translateY(-2px); box-shadow: inset 0 0 0 1px rgba(76,195,255,.55), 0 16px 34px rgba(0,0,0,.55)}
    .func-digit-btn:active{transform:scale(.96); background:linear-gradient(150deg, rgba(18,26,40,.95) 0%, rgba(9,14,22,1) 100%)}
    .func-digit-btn:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:4px}
    .func-main-value{
      background:rgba(11,18,30,.85);
      border-radius:16px;
      padding:18px 14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:12px;
      box-shadow: inset 0 0 0 1px rgba(45,70,102,.45), inset 0 20px 40px rgba(5,10,18,.55);
      width:100%;
      height:100%;
      flex:1 1 auto;
    }
    .func-value-label{font-size:12px; letter-spacing:.18em; color:#9aa6bb; text-transform:uppercase}
    .func-value-main{
      font-size:56px;
      font-family:'Share Tech Mono', 'Orbitron', 'Courier New', monospace;
      font-weight:600;
      letter-spacing:.08em;
      background: linear-gradient(180deg, #c0f2ff 0%, #63d0ff 45%, #1f97ff 100%);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      text-shadow:0 6px 22px rgba(76,195,255,.35);
      display:flex;
      align-items:baseline;
      gap:8px;
    }
    .func-value-main span.unit{font-size:20px; letter-spacing:.25em; text-transform:uppercase}
    .func-value-secondary{font-size:14px; color:#83d6f7; letter-spacing:.05em}
    .func-params{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      justify-content:center;
    }
    .func-param-btn{
      position:relative;
      border:none;
      background:linear-gradient(150deg, rgba(16,23,35,.85) 0%, rgba(10,15,24,1) 100%);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      color:#c9d7f1;
      display:flex;
      align-items:center;
      justify-content:center;
      min-width:56px;
      flex:1 0 56px;
      min-height:40px;
      box-shadow: inset 0 0 0 1px rgba(45,65,92,.55), 0 10px 24px rgba(0,0,0,.4);
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .func-param-btn .symbol{font-size:18px; letter-spacing:.1em; text-transform:uppercase; color:#58e4ff; font-weight:600}
    .func-param-btn .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
    .func-param-btn::after{
      content:attr(data-tooltip);
      position:absolute;
      bottom:calc(100% + 10px);
      left:50%;
      transform:translateX(-50%) translateY(6px);
      background:#0d1420;
      color:#d1d8e5;
      padding:6px 10px;
      border-radius:8px;
      border:1px solid #1f2b3d;
      box-shadow:0 12px 24px rgba(0,0,0,.45);
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s ease, transform .2s ease;
      white-space:nowrap;
      z-index:5;
    }
    .func-param-btn:hover::after,
    .func-param-btn:focus-visible::after{opacity:1; transform:translateX(-50%) translateY(0)}
    .func-param-btn.active{
      background:linear-gradient(150deg, rgba(80,220,255,.35) 0%, rgba(20,125,220,.65) 100%);
      color:#051020;
      box-shadow:0 12px 28px rgba(56,160,255,.28), inset 0 0 0 1px rgba(12,20,32,.45);
    }
    .func-param-btn.active .symbol{color:#0b1220}
    .func-param-btn:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:4px}
    .func-summary{
      display:flex;
      flex-direction:row;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:#d0def6;
      min-height:36px;
      flex:1 1 auto;
      min-width:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .func-summary.empty{justify-content:center; align-items:center; color:#64748b}
    .func-summary-item{
      display:inline-flex;
      align-items:baseline;
      gap:6px;
    }
    .func-summary-item.current .func-summary-value{color:#58e4ff}
    .func-summary-value{font-size:14px; letter-spacing:.04em; color:#e4f1ff; font-weight:600}
    .func-summary-value .unit{font-size:11px; margin-left:3px; letter-spacing:.12em; text-transform:uppercase; color:#7fbfff}
    .func-summary-secondary{font-size:11px; color:#7a8aa6; opacity:.9}
    .func-summary-separator{opacity:.4; font-size:11px; color:#7a8aa6; margin:0 2px;}
    .func-summary-empty{opacity:.7; font-style:italic}
    #func-hint,
    .func-output-type{display:none}
    .func-hint{
      font-size:12px;
      color:#6e7f99;
      line-height:1.5;
      background:rgba(8,12,21,.85);
      border-radius:12px;
      padding:12px 14px;
      border:1px dashed rgba(76,195,255,.35);
    }
    .func-action-stack .btn.primary{
      align-self:flex-end;
      padding:12px 22px;
      font-size:14px;
      letter-spacing:.15em;
      text-transform:uppercase;
      border-radius:999px;
      background:linear-gradient(130deg, rgba(61,217,158,.8) 0%, rgba(33,162,111,.95) 100%);
      border:none;
      box-shadow:0 16px 34px rgba(27,160,112,.35), inset 0 0 0 1px rgba(6,35,23,.4);
    }
    .func-action-stack .btn.primary:hover{box-shadow:0 20px 40px rgba(27,160,112,.45)}
    .func-action-stack .btn.primary:focus-visible{outline:2px solid rgba(54,211,153,.7); outline-offset:4px}

    /* DMM styles */
    .dmm-display{
      background: radial-gradient(600px 200px at 50% -10%, #0c111b 0%, #0c111b 60%, #0a0f18 100%);
      border:1px solid #1a2332; border-radius:12px; padding:12px 14px; min-height:220px;
      display:flex; justify-content:center; align-items:center; position:relative; overflow:hidden;
      text-shadow: 0 0 6px rgba(54,211,153,0.2);
    }
    .dmm-view{display:none; flex-direction:column; align-items:center; justify-content:center; gap:12px; width:100%; height:100%; text-align:center}
    .dmm-view.active{display:flex}
    .digits{
      display:flex; align-items:flex-end; gap:12px;
    }
    .digits span{
      background: linear-gradient(180deg, #c7ffe7 0%, #7ef1c6 40%, #3bd098 60%, #1aaa73 100%);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      filter: drop-shadow(0 5px 12px rgba(54, 211, 153, .18));
      display:inline-flex; align-items:flex-end;
    }
    .digits-value{
      font-variant-numeric: tabular-nums;
      font-size:56px; line-height:1; font-weight:700; letter-spacing:1px;
    }
    .digits-unit{
      font-size:28px; font-weight:600; letter-spacing:1.2px; text-transform:uppercase; padding-bottom:6px;
    }
    .dmm-meta{font-size:12px; color:var(--sub)}
    .binary-readout{display:flex; flex-direction:column; gap:4px; align-items:center; font-size:12px; color:var(--sub)}
    .binary-value{font-size:32px; font-weight:600; letter-spacing:1px; color:#7ef1c6}
    .binary-caption{text-transform:uppercase; letter-spacing:.2em; font-size:10px; color:#637186}
    .binary-grid{display:flex; flex-wrap:wrap; gap:6px; justify-content:center; width:100%; max-width:320px}
    .binary-empty{flex:1 0 100%; font-size:12px; color:#5f6b7c; letter-spacing:.05em; text-transform:uppercase; text-align:center}
    .binary-cell{display:flex; align-items:center; justify-content:center}
    .binary-bit{padding:6px 10px; border-radius:6px; background:#0b1623; border:1px solid #1f2a3a; font-size:14px; font-weight:600; color:#c7d2e2; box-shadow: inset 0 1px 0 rgba(255,255,255,.05); text-align:center}
    .binary-bit.on{background:linear-gradient(180deg, rgba(126,241,198,.35) 0%, rgba(59,208,152,.35) 100%); color:#bff6dd; border-color:#2c4a3b}
    .binary-meta{font-size:11px; color:#8793a3; text-align:center}
    .gauge{width:100%; max-width:260px}
    #dmm-gauge-svg{width:100%; height:auto}
    .gauge-arc{fill:none; stroke:#1f2b3d; stroke-width:10; stroke-linecap:round}
    .gauge-needle{stroke:#4cc3ff; stroke-width:4; stroke-linecap:round; filter:drop-shadow(0 0 6px rgba(76,195,255,.6))}
    .gauge-hub{fill:#0b1220; stroke:#4cc3ff; stroke-width:2}
    .gauge-tick{stroke:#2a3546; stroke-width:2; stroke-linecap:round}
    .gauge-tick.minor{stroke-width:1; stroke:#1a2434}
    .gauge-label{fill:#7c8b9f; font-size:10px; font-weight:500; text-shadow:none}
    .gauge-readout{display:flex; align-items:baseline; gap:6px; font-variant-numeric: tabular-nums}
    .gauge-value{font-size:32px; font-weight:600; color:#7ef1c6}
    .gauge-unit{font-size:16px; font-weight:600; color:#bfe7ff}
    .dmm-controls{display:flex; flex-direction:column; gap:12px; height:100%}
    .dmm-controls .control-line{display:flex; gap:18px; align-items:stretch; height:100%}
    .dmm-controls .control-group{display:flex; flex-direction:column}
    .dmm-controls .control-group.channel{flex:0 0 25%; max-width:25%}
    .dmm-controls .control-group.display{flex:1 1 0}
    .dmm-controls label,
    .dmm-controls .control-label{display:block; font-size:12px; color:#b5c0cd; margin-bottom:6px}
    .info-label{position:relative; display:inline-flex; align-items:center; gap:6px; cursor:help}
    .info-icon{width:16px; height:16px; border-radius:50%; background:#1f2b3d; color:#bfe7ff; font-size:10px; font-weight:600; display:inline-flex; align-items:center; justify-content:center; box-shadow:0 0 0 1px rgba(79,89,110,.45)}
    .info-label::after{content:attr(data-tooltip); position:absolute; left:0; bottom:calc(100% + 10px); background:#0d1420; color:#d1d8e5; padding:8px 10px; border-radius:8px; border:1px solid #1f2b3d; box-shadow:0 12px 24px rgba(0,0,0,.45); width:220px; max-width:260px; opacity:0; transform:translateY(6px); pointer-events:none; transition:opacity .2s ease, transform .2s ease; line-height:1.4; white-space:pre-line}
    .info-label:hover::after,
    .info-label:focus-visible::after{opacity:1; transform:translateY(0)}
    .info-label:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:4px}
    .mode-row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .mode-buttons{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .mode-row>.btn.warn{margin-left:auto}
    .mode-buttons .btn-hold{padding:7px 10px; font-size:12px; white-space:nowrap}
    @media (max-width: 720px){
      .dmm-controls .control-line{flex-direction:column}
      .dmm-controls .control-group.channel{flex:1 1 100%; max-width:none}
      .dmm-controls .control-group.display{flex:1 1 100%}
      .mode-row{justify-content:flex-start}
      .mode-row>.btn.warn{margin-left:0}
    }

    .dmm-controls label{display:block; font-size:12px; color:#b5c0cd; margin:8px 0 4px}
    .select, input[type="number"], input[type="text"]{
      width:100%; padding:8px 10px; background:#0c121b; color:var(--text);
      border:1px solid #223044; border-radius:8px; outline:none;
    }
    .btn{
      appearance:none; border:1px solid #1f2b3d; background:linear-gradient(180deg,#1a2434,#121b27);
      color:var(--text); padding:9px 12px; border-radius:10px; cursor:pointer;
      box-shadow:0 6px 14px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .btn.primary{ border-color:#1f3b2f; background:linear-gradient(180deg,#1f3b2f,#15281f); color:#bff6dd}
    .btn.warn{ border-color:#3b2f1f; background:linear-gradient(180deg,#3b2f1f,#2a2117); color:#ffd7a7}
    .btn.active{border-color:#2f4b66; background:linear-gradient(180deg,#1d2738,#162131); box-shadow:0 0 0 1px rgba(76,195,255,.2), inset 0 1px 0 rgba(255,255,255,.08)}
    .row{display:flex; gap:10px}
    .row>*{flex:1}
    .row.compact>*{flex:0 0 auto}
    .row.compact .grow{flex:1 1 auto}
    .badge{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #334155; color:#cbd5e1; background:#0b1220; display:inline-block}

    /* Generator */
    .knob{
      display:flex; flex-direction:column; gap:6px; align-items:stretch;
      background:#0c121b; border:1px solid #1a2332; border-radius:10px; padding:10px;
    }
    input[type="range"]{ width:100% }
    input[type="range"]{
      -webkit-appearance:none; height:6px; background: #152030; border-radius:999px; outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe7ff, #4ba8e6);
      box-shadow: 0 0 0 2px #0b1220, 0 8px 16px rgba(0,0,0,.5);
      border:1px solid #1e3a5f;
    }

    /* Scope */
    .scope-wrap{
      background:#050910;
      border:1px solid #162235;
      border-radius:12px;
      overflow:hidden;
      position:relative;
      display:flex;
    }
    .scope-body{display:flex; width:100%; min-height:230px}
    .scope-screen{flex:1 1 auto; position:relative; min-height:220px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding:14px; gap:12px}
    .scope-display{width:100%; max-width:520px}
    #scope-display{width:100%; height:auto; display:block}
    #scope-display .scope-grid rect{fill:#050910; stroke:#1b2d42; stroke-width:2}
    #scope-display .grid-lines{stroke:#1b2d42; stroke-width:1.5; fill:none}
    #scope-display .sub-division{stroke:#0c1521; stroke-width:1; fill:none}
    #scope-display .scope-axis{stroke:#2e4c68; stroke-width:2}
    #scope-display .reference-line{stroke:#ff6b6b; stroke-width:1.2; stroke-dasharray:6 4}
    #scope-display .reference-label{fill:#9fb5c9; font-size:12px; font-family:inherit}
    #scope-display .scope-legend text{fill:#9fb5c9; font-size:13px; font-family:inherit}
    .scope-debug-value{
      font-size:12px; color:#9fb5c9; background:rgba(12,17,27,.75);
      padding:6px 10px; border-radius:8px; font-variant-numeric:tabular-nums;
      align-self:flex-start; box-shadow:inset 0 0 0 1px rgba(36,54,72,.6);
    }
    .scope-debug-value.empty{opacity:.6}
    .scope-controls{
      flex:0 0 200px;
      border-left:1px solid #162235;
      background:linear-gradient(180deg,#060b14 0%, #050910 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:22px;
      padding:20px 16px;
    }
    .scope-control{display:flex; flex-direction:column; align-items:center; gap:12px; width:100%}
    .scope-control .control-label{font-size:11px; text-transform:uppercase; letter-spacing:.1em; color:#8fa3b9; text-align:center}
    .scope-control select{
      width:100%;
      background:#0c1521;
      border:1px solid #1b2a3c;
      border-radius:8px;
      color:#d1e3f0;
      padding:8px 10px;
      font-size:13px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 8px 18px rgba(0,0,0,.3);
    }
    .scope-trace-button{
      width:100%;
      padding:10px;
      border-radius:8px;
      background:linear-gradient(180deg,#14263a 0%, #0d1725 100%);
      border:1px solid #1e2f44;
      color:#9be7ff;
      font-size:13px;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
      transition:transform .15s ease, box-shadow .15s ease;
    }
    .scope-trace-button:hover{transform:translateY(-1px); box-shadow:0 10px 22px rgba(0,0,0,.4);}
    .scope-trace-button:active{transform:translateY(0); box-shadow:0 4px 12px rgba(0,0,0,.35);}
    .scope-control-status{font-size:11px; text-align:center; color:#6e7d90; min-height:14px}

    .scope-modal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(3,7,13,.6); z-index:200; padding:20px}
    .scope-modal.hidden{display:none}
    .scope-modal-dialog{
      background:linear-gradient(180deg,#0f1726 0%, #0b101a 100%);
      border:1px solid #1e2a3c;
      border-radius:12px;
      padding:20px;
      width:100%;
      max-width:360px;
      box-shadow:0 30px 60px rgba(0,0,0,.45);
      color:#e5e7eb;
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .scope-modal h3{margin:0; font-size:16px; font-weight:600; text-align:left}
    .scope-modal form{display:flex; flex-direction:column; gap:16px}
    .scope-modal label{display:flex; flex-direction:column; gap:6px; font-size:13px; color:#b3c0d1; text-transform:uppercase; letter-spacing:.08em}
    .scope-modal select, .scope-modal input[type="color"], .scope-modal input[type="number"]{
      width:100%;
      padding:10px;
      border-radius:8px;
      border:1px solid #1e2f44;
      background:#0c1521;
      color:#e5e7eb;
      font-size:14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .scope-modal input[type="color"]{height:40px; padding:0; cursor:pointer}
    .scope-modal-actions{display:flex; justify-content:flex-end; gap:10px}

    /* Math editor */
    .math{
      display:grid; gap:10px; grid-template-columns: 1fr;
      height:100%;
      grid-template-rows: auto 1fr auto;
    }
    textarea{
      width:100%; height:160px; resize:vertical; min-height:120px;
      background:#0c121b; color:#e5e7eb; border:1px solid #1a2332; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .hint{font-size:12px; color:#a6b1bf}
    .list{
      border:1px dashed #203047; border-radius:10px; padding:10px; color:#cbd5e1; font-size:13px; background:#0a0f16;
    }

    /* Utils */
    .right{justify-content:flex-end}
    .muted{color:#9aa7b7}
    .unit{font-weight:600; color:#bfe7ff; margin-left:8px}
    .spacer{height:6px}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <header>
    <h1><span class="led"></span> MiniLabo — Console</h1>
    <div class="muted">Session PIN via cookie – Web en ligne</div>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- DMM -->
      <section class="card" id="card-dmm">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Multimètre <span class="badge" id="dmm-channel">CH1</span> <span class="pill" id="dmm-mode-pill">UDC</span></h2>
        <div class="content dmm-vertical">
          <div class="dmm-display">
            <div class="dmm-view active" data-view="digits">
              <div class="digits"><span class="digits-value" id="dmm-value">—.—</span><span class="digits-unit" id="dmm-unit-inline">V</span></div>
              <div class="spacer"></div>
              <div class="dmm-meta" id="dmm-meta">Entrée : — • Mode : — • Décimales : —</div>
            </div>
            <div class="dmm-view" data-view="binary">
              <div class="binary-readout">
                <div class="binary-value" id="dmm-binary-value">—</div>
                <div class="binary-caption">Valeur brute</div>
              </div>
              <div class="binary-grid" id="dmm-binary"></div>
              <div class="binary-meta" id="dmm-binary-meta"></div>
            </div>
            <div class="dmm-view" data-view="gauge">
              <div class="gauge" id="dmm-gauge">
                <svg id="dmm-gauge-svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
                  <path id="dmm-gauge-arc" class="gauge-arc" d="M20 160 A80 80 0 0 1 180 160" />
                  <g id="dmm-gauge-ticks"></g>
                  <line id="dmm-gauge-needle" class="gauge-needle" x1="100" y1="120" x2="100" y2="40" />
                  <circle class="gauge-hub" cx="100" cy="120" r="6" />
                </svg>
              </div>
            </div>
          </div>
          <div class="dmm-controls">
            <div class="control-line">
              <div class="control-group channel">
                <label for="dmm-select">Canal</label>
                <select id="dmm-select" class="select"></select>
              </div>
              <div class="control-group display">
                <div class="control-label info-label" data-tooltip="Le DMM est actualisé toutes les 2 s. Les décimales sont définies par la config du canal." tabindex="0">Affichage <span class="info-icon" aria-hidden="true">i</span></div>
                <div class="mode-row">
                  <div class="mode-buttons">
                    <button class="btn" data-mode="digits">Numérique</button>
                    <button class="btn" data-mode="binary">Binaire</button>
                    <button class="btn" data-mode="gauge">Cadran</button>
                    <button class="btn warn btn-hold" id="dmm-hold">Hold</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- FUNCGEN -->
      <section class="card" id="card-func">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Générateur de fonctions <span class="pill blue" id="func-target-pill">cible : —</span></h2>
        <div class="content">
          <table class="func-layout">
            <colgroup>
              <col class="func-col-label" />
              <col class="func-col-main" />
              <col class="func-col-side" />
            </colgroup>
            <tbody>
              <tr>
                <td class="func-meta-cell" colspan="3" valign="top">
                  <div class="func-summary empty" id="func-summary" aria-live="polite" role="list">
                    <span class="func-summary-item func-summary-empty" role="listitem">—</span>
                  </div>
                </td>
              </tr>
              <tr>
                <td class="func-param-cell" rowspan="2" valign="top">
                  <div class="func-params" id="func-param-buttons"></div>
                </td>
                <td class="func-display-cell" valign="top">
                  <div class="func-display">
                    <div class="func-main-value">
                      <div class="func-value-label" id="func-value-label">Amplitude</div>
                      <div class="func-value-main" id="func-value-main">00<span class="unit">%</span></div>
                      <div class="func-value-secondary" id="func-value-secondary"></div>
                    </div>
                  </div>
                </td>
                <td class="func-output-cell" valign="top">
                  <div class="func-output-box">
                    <label for="func-target">Sortie</label>
                    <select id="func-target" class="select"></select>
                    <div class="func-output-name" id="func-output-name">—</div>
                    <div class="func-output-type" id="func-output-type">type inconnu</div>
                    <div class="pill blue" id="func-range-pill">Plage : —</div>
                  </div>
                  <div class="func-adjust-cell">
                    <div class="func-adjust-stack">
                      <div class="func-adjust-scale" id="func-adjust-scale" role="radiogroup" aria-label="Sélection du pas"></div>
                      <div class="func-adjust-buttons">
                        <button class="func-digit-btn" id="func-plus" type="button" aria-label="Augmenter la valeur" title="Augmenter">+</button>
                        <button class="func-digit-btn" id="func-minus" type="button" aria-label="Diminuer la valeur" title="Diminuer">−</button>
                      </div>
                    </div>
                  </div>
                </td>
              </tr>
              <tr>
                <td class="func-wave-cell" valign="top">
                  <div class="func-param-zone">
                    <div class="func-wave-list" id="func-wave-list" role="radiogroup" aria-label="Forme d’onde"></div>
                  </div>
                </td>
                <td class="func-action-cell" valign="top">
                  <div class="func-action-stack">
                    <button class="btn primary" id="func-apply">Lancer la sortie</button>
                    <div class="func-hint" id="func-hint">Sélectionne une sortie pour afficher ses possibilités et ajuster ton signal.</div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- SCOPE -->
      <section class="card" id="card-scope">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Oscilloscope <span class="badge" id="scope-chan">CH1</span> <span class="pill blue" id="scope-timebase">— ms/div</span></h2>
        <div class="content single">
          <div class="scope-wrap">
            <div class="scope-body">
              <div class="scope-screen" id="scope-screen">
                <div class="scope-display" role="img" aria-label="Affichage oscilloscope">
                  <svg id="scope-display" viewBox="0 0 500 528" xmlns="http://www.w3.org/2000/svg">
                    <g class="scope-grid">
                      <rect x="0" y="0" width="500" height="500"></rect>
                      <path class="grid-lines" d="M0,0 V500 M50,0 V500 M100,0 V500 M150,0 V500 M200,0 V500 M250,0 V500 M300,0 V500 M350,0 V500 M400,0 V500 M450,0 V500 M500,0 V500 M0,0 H500 M0,50 H500 M0,100 H500 M0,150 H500 M0,200 H500 M0,250 H500 M0,300 H500 M0,350 H500 M0,400 H500 M0,450 H500 M0,500 H500"></path>
                      <line class="scope-axis" x1="0" y1="250" x2="500" y2="250"></line>
                      <line class="scope-axis" x1="250" y1="0" x2="250" y2="500"></line>
                      <path class="sub-division" d="M0,245 V255 M10,245 V255 M20,245 V255 M30,245 V255 M40,245 V255 M50,245 V255 M60,245 V255 M70,245 V255 M80,245 V255 M90,245 V255 M100,245 V255 M110,245 V255 M120,245 V255 M130,245 V255 M140,245 V255 M150,245 V255 M160,245 V255 M170,245 V255 M180,245 V255 M190,245 V255 M200,245 V255 M210,245 V255 M220,245 V255 M230,245 V255 M240,245 V255 M250,245 V255 M260,245 V255 M270,245 V255 M280,245 V255 M290,245 V255 M300,245 V255 M310,245 V255 M320,245 V255 M330,245 V255 M340,245 V255 M350,245 V255 M360,245 V255 M370,245 V255 M380,245 V255 M390,245 V255 M400,245 V255 M410,245 V255 M420,245 V255 M430,245 V255 M440,245 V255 M450,245 V255 M460,245 V255 M470,245 V255 M480,245 V255 M490,245 V255 M500,245 V255 M245,0 H255 M245,10 H255 M245,20 H255 M245,30 H255 M245,40 H255 M245,50 H255 M245,60 H255 M245,70 H255 M245,80 H255 M245,90 H255 M245,100 H255 M245,110 H255 M245,120 H255 M245,130 H255 M245,140 H255 M245,150 H255 M245,160 H255 M245,170 H255 M245,180 H255 M245,190 H255 M245,200 H255 M245,210 H255 M245,220 H255 M245,230 H255 M245,240 H255 M245,250 H255 M245,260 H255 M245,270 H255 M245,280 H255 M245,290 H255 M245,300 H255 M245,310 H255 M245,320 H255 M245,330 H255 M245,340 H255 M245,350 H255 M245,360 H255 M245,370 H255 M245,380 H255 M245,390 H255 M245,400 H255 M245,410 H255 M245,420 H255 M245,430 H255 M245,440 H255 M245,450 H255 M245,460 H255 M245,470 H255 M245,480 H255 M245,490 H255 M245,500 H255"></path>
                      <line class="reference-line" x1="0" y1="250" x2="500" y2="250"></line>
                      <text class="reference-label" x="6" y="244">0 V (réf.)</text>
                    </g>
                    <g id="scope-traces">
                      <path id="scope-trace-path" fill="none" stroke="#64ffda" stroke-width="2"></path>
                    </g>
                    <g class="scope-legend">
                      <text x="10" y="522" id="scope-voltage-scale">—</text>
                      <text x="300" y="522" id="scope-time-scale">—</text>
                    </g>
                  </svg>
                </div>
                <div class="scope-debug-value empty" id="scope-debug-value" aria-live="polite">Valeur trace : —</div>
              </div>
              <div class="scope-controls">
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Ajuste la durée affichée pour une division horizontale." tabindex="0">Base de temps <span class="info-icon" aria-hidden="true">i</span></div>
                  <select id="scope-timebase-select" aria-label="Base de temps (ms par division)"></select>
                  <div class="scope-control-status" id="scope-timebase-status" aria-live="polite"></div>
                </div>
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Sélectionne la tension représentée par une division verticale." tabindex="0">Échelle verticale <span class="info-icon" aria-hidden="true">i</span></div>
                  <select id="scope-volt-select" aria-label="Échelle verticale (volts par division)"></select>
                  <div class="scope-control-status" id="scope-volt-status" aria-live="polite"></div>
                </div>
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Choix du canal affiché et de sa couleur." tabindex="0">Trace <span class="info-icon" aria-hidden="true">i</span></div>
                  <button type="button" class="scope-trace-button" id="scope-trace-open">Configurer…</button>
                  <div class="scope-control-status" id="scope-trace-status" aria-live="polite"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- MATH EDITOR -->
      <section class="card" id="card-math">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Éditeur d’équations (IO math)</h2>
        <div class="content single">
          <div class="math">
            <div class="hint">Une équation par ligne → <code>io_out = (io_a0 * 3.3) + 0.1</code> • Variables = noms d’IO logiques • Fonctions autorisées basiques ( + − × ÷, abs, min, max ).</div>
            <textarea id="math-text" spellcheck="false" placeholder="ex: v_div = IO_A0 * 3.3&#10;v_out = v_div * 0.5"></textarea>
            <div class="row">
              <button class="btn" id="math-load">Charger</button>
              <button class="btn primary" id="math-save">Enregistrer</button>
            </div>
            <div class="list" id="math-status">Prêt.</div>
          </div>
        </div>
      </section>

    </div>
  </div>
  
  <div class="scope-modal hidden" id="scope-trace-modal" aria-hidden="true">
    <div class="scope-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="scope-trace-title">
      <h3 id="scope-trace-title">Configurer la trace</h3>
      <form id="scope-trace-form">
        <label for="scope-trace-channel">Canal</label>
        <select id="scope-trace-channel" required></select>
        <label for="scope-trace-color">Couleur</label>
        <input type="color" id="scope-trace-color" value="#64ffda" />
        <label for="scope-trace-offset-x">Offset horizontal (div)</label>
        <input type="number" id="scope-trace-offset-x" value="0" min="-5" max="5" step="0.1" />
        <label for="scope-trace-offset-y">Offset vertical (div)</label>
        <input type="number" id="scope-trace-offset-y" value="0" min="-5" max="5" step="0.1" />
        <div class="scope-modal-actions">
          <button type="button" class="btn" id="scope-trace-cancel">Annuler</button>
          <button type="submit" class="btn primary">Valider</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const $ = (q)=>document.querySelector(q);
    const j = (url,opts={})=>fetch(url,Object.assign({headers:{'Content-Type':'application/json'}},opts));

    let scopeChannelMetadata = {};

    function mergeScopeChannelMeta(channel, info = {}){
      if(!channel) return;
      if(!scopeChannelMetadata[channel]){
        scopeChannelMetadata[channel] = {label: null, io: null, display: null, description: null};
      }
      const target = scopeChannelMetadata[channel];
      if(info.label && (target.label === null || target.label === channel)){
        target.label = info.label;
      }
      if(info.display && !target.display){
        target.display = info.display;
      }
      if(info.io && (target.io === null || target.io === channel)){
        target.io = info.io;
      }
      if(info.description && !target.description){
        target.description = info.description;
      }
    }

    /* --------- DMM --------- */
    let dmmHold = false, dmmMode = 'digits';
    const dmmState = {
      config: [],
      snapshot: [],
      holdValue: null,
      holdUnit: null,
      holdNumeric: null,
      holdBinary: null,
      lastNumericValue: null,
      lastBinaryValue: null,
      gaugeRanges: {}
    };

    function getDmmMeta(ioId){
      return dmmState.config.find(ch=>ch.io===ioId) || null;
    }
    function updateDmmHeader(meta){
      const badge = $('#dmm-channel');
      const pill = $('#dmm-mode-pill');
      if(badge) badge.textContent = meta?.label || meta?.io || '—';
      if(pill) pill.textContent = meta?.mode || '—';
    }
    const gaugeGeom = { centerX: 100, centerY: 120, radius: 80, startAngle: -210, endAngle: 30 };
    function parseNumeric(value){
      const n = Number(value);
      return Number.isFinite(n) ? n : null;
    }
    function formatDecimal(value, maxDecimals=4){
      if(!Number.isFinite(value)) return '—';
      let txt = value.toFixed(maxDecimals);
      txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
      return txt;
    }
    function gaugePolar(angleDeg, radius){
      const rad = angleDeg * Math.PI / 180;
      return {
        x: gaugeGeom.centerX + Math.cos(rad) * radius,
        y: gaugeGeom.centerY + Math.sin(rad) * radius,
      };
    }
    function niceCeil(value){
      if(!Number.isFinite(value) || value === 0){ return 1; }
      const magnitude = Math.abs(value);
      const exponent = Math.floor(Math.log10(magnitude));
      const power = Math.pow(10, exponent);
      const scaled = magnitude / power;
      let nice;
      if(scaled <= 1){ nice = 1; }
      else if(scaled <= 2){ nice = 2; }
      else if(scaled <= 5){ nice = 5; }
      else { nice = 10; }
      return nice * power;
    }
    function updateDmmMode(){
      document.querySelectorAll('#card-dmm [data-mode]').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.mode === dmmMode);
      });
      document.querySelectorAll('#card-dmm .dmm-view').forEach(view=>{
        view.classList.toggle('active', view.dataset.view === dmmMode);
      });
    }
    function determineBinaryBitCount(value){
      if(!Number.isFinite(value)) return 8;
      const abs = Math.abs(value);
      if(abs < 16) return 8;
      if(abs < 256) return 8;
      if(abs < 4096) return 12;
      if(abs < 65536) return 16;
      if(abs < 16777216) return 24;
      return 32;
    }
    function updateDmmBinary(value){
      const grid = $('#dmm-binary');
      const meta = $('#dmm-binary-meta');
      const rawEl = $('#dmm-binary-value');
      if(!grid || !meta || !rawEl) return;
      grid.innerHTML = '';
      if(!Number.isFinite(value)){
        grid.innerHTML = '<div class="binary-empty">Aucune donnée</div>';
        rawEl.textContent = '—';
        meta.textContent = 'Valeur non disponible';
        return;
      }
      const rounded = Math.round(value);
      rawEl.textContent = formatDecimal(value, 6);
      const absValue = Math.abs(rounded);
      const bits = determineBinaryBitCount(absValue);
      const binary = absValue.toString(2).padStart(bits, '0');
      for(let i=0; i<bits; i++){
        const bitIndex = bits - 1 - i;
        const bit = binary[bitIndex];
        const cell = document.createElement('div');
        cell.className = 'binary-cell';
        const bitEl = document.createElement('div');
        bitEl.className = 'binary-bit' + (bit === '1' ? ' on' : '');
        bitEl.textContent = bit;
        cell.appendChild(bitEl);
        grid.appendChild(cell);
      }
      meta.textContent = `Bits : ${bits} • Arrondi : ${rounded}`;
    }
    function buildAutoGaugeRange(value){
      const base = Number.isFinite(value) ? value : 0;
      const magnitude = Math.max(Math.abs(base), 1);
      const max = niceCeil(magnitude);
      if(base >= 0){
        return {min: 0, max, explicit: false};
      }
      return {min: -max, max, explicit: false};
    }
    function getGaugeRange(ioId, meta, snapshot, numericValue){
      const candidatesMin = [meta?.min, meta?.minValue, meta?.minimum, meta?.rangeMin, meta?.range?.min, meta?.lower, meta?.low];
      const candidatesMax = [meta?.max, meta?.maxValue, meta?.maximum, meta?.rangeMax, meta?.range?.max, meta?.upper, meta?.high];
      const explicitMin = candidatesMin.map(parseNumeric).find(v=>v!==null);
      const explicitMax = candidatesMax.map(parseNumeric).find(v=>v!==null);
      if(explicitMin != null && explicitMax != null && explicitMin < explicitMax){
        const range = {min: explicitMin, max: explicitMax, explicit: true};
        dmmState.gaugeRanges[ioId] = range;
        return range;
      }
      const previous = dmmState.gaugeRanges[ioId];
      const baseRaw = parseNumeric(snapshot?.raw);
      const baseValue = Number.isFinite(numericValue) ? numericValue : (Number.isFinite(baseRaw) ? baseRaw : null);
      if(previous && previous.explicit){
        return previous;
      }
      if(previous && !Number.isFinite(baseValue)){
        return previous;
      }
      let range = previous;
      if(!range){
        range = buildAutoGaugeRange(baseValue);
      }else if(Number.isFinite(baseValue) && (baseValue < range.min || baseValue > range.max)){
        range = buildAutoGaugeRange(baseValue);
      }
      if(!range){
        range = {min: -1, max: 1, explicit: false};
      }
      if(range.max <= range.min){
        range = {min: range.min - 1, max: range.max + 1, explicit: range.explicit || false};
      }
      dmmState.gaugeRanges[ioId] = range;
      return range;
    }
    function updateGaugeTicks(range){
      const ticksGroup = document.getElementById('dmm-gauge-ticks');
      if(!ticksGroup) return;
      const arc = document.getElementById('dmm-gauge-arc');
      const largeArc = (gaugeGeom.endAngle - gaugeGeom.startAngle) > 180 ? 1 : 0;
      if(arc){
        const start = gaugePolar(gaugeGeom.startAngle, gaugeGeom.radius);
        const end = gaugePolar(gaugeGeom.endAngle, gaugeGeom.radius);
        arc.setAttribute('d', `M ${start.x.toFixed(2)} ${start.y.toFixed(2)} A ${gaugeGeom.radius} ${gaugeGeom.radius} 0 ${largeArc} 1 ${end.x.toFixed(2)} ${end.y.toFixed(2)}`);
      }
      ticksGroup.innerHTML = '';
      const majorCount = 5;
      const minorPerSegment = 4;
      const span = range.max - range.min;
      const labelDecimals = (()=>{
        if(span === 0) return 0;
        const step = span / (majorCount - 1);
        let decimals = 0, scaled = step;
        while(decimals < 3 && scaled > 0 && scaled < 1){ decimals += 1; scaled *= 10; }
        return decimals;
      })();
      const formatLabel = (value)=>{
        if(!Number.isFinite(value)) return '0';
        let txt = value.toFixed(labelDecimals);
        txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
        return txt;
      };
      const createLine = (angle, length, className)=>{
        const outer = gaugePolar(angle, gaugeGeom.radius);
        const inner = gaugePolar(angle, gaugeGeom.radius - length);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', inner.x.toFixed(2));
        line.setAttribute('y1', inner.y.toFixed(2));
        line.setAttribute('x2', outer.x.toFixed(2));
        line.setAttribute('y2', outer.y.toFixed(2));
        line.setAttribute('class', className);
        ticksGroup.appendChild(line);
      };
      for(let i=0;i<majorCount;i++){
        const ratio = i/(majorCount-1);
        const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
        createLine(angle, 14, 'gauge-tick');
        const labelPos = gaugePolar(angle, gaugeGeom.radius + 18);
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', labelPos.x.toFixed(2));
        text.setAttribute('y', labelPos.y.toFixed(2));
        text.setAttribute('text-anchor','middle');
        text.setAttribute('dominant-baseline','middle');
        text.setAttribute('class','gauge-label');
        text.textContent = formatLabel(range.min + ratio * span);
        ticksGroup.appendChild(text);
        if(i < majorCount-1){
          for(let m=1;m<=minorPerSegment;m++){
            const minorRatio = (i + m/(minorPerSegment+1)) / (majorCount-1);
            const minorAngle = gaugeGeom.startAngle + minorRatio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
            createLine(minorAngle, 8, 'gauge-tick minor');
          }
        }
      }
    }
    function updateDmmGauge(value, formatted, unit, meta, snapshot, ioId){
      const range = getGaugeRange(ioId, meta, snapshot, value);
      updateGaugeTicks(range);
      const needle = document.getElementById('dmm-gauge-needle');
      if(!needle) return;
      const span = range.max - range.min;
      const effectiveSpan = span === 0 ? 1 : span;
      const fallback = range.min + effectiveSpan / 2;
      const clamped = Number.isFinite(value) ? Math.min(Math.max(value, range.min), range.max) : fallback;
      const ratio = (clamped - range.min) / effectiveSpan;
      const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
      const tip = gaugePolar(angle, gaugeGeom.radius - 18);
      needle.setAttribute('x1', gaugeGeom.centerX.toFixed(2));
      needle.setAttribute('y1', gaugeGeom.centerY.toFixed(2));
      needle.setAttribute('x2', tip.x.toFixed(2));
      needle.setAttribute('y2', tip.y.toFixed(2));
      needle.setAttribute('opacity', Number.isFinite(value) ? '1' : '0.25');
    }
    function buildFallbackMeta(snapshot){
      return snapshot.map((ch, idx)=>({
        label: `CH${idx+1}`,
        io: ch.id || `CH${idx+1}`,
        mode: 'UDC',
        decimals: 2,
        unit: ch.unit || ''
      }));
    }
    function registerScopeChannelMetaFromDmm(metaList){
      if(!Array.isArray(metaList) || !metaList.length) return;
      let changed = false;
      metaList.forEach((meta)=>{
        if(!meta) return;
        const rawLabel = typeof meta.label === 'string' ? meta.label.trim() : '';
        const rawChannel = typeof meta.channel === 'string' ? meta.channel.trim() : '';
        const baseChannel = rawChannel || rawLabel || null;
        const io = typeof meta.io === 'string' ? meta.io.trim() : '';
        const display = typeof meta.display === 'string' ? meta.display.trim() : '';
        const description = typeof meta.description === 'string' ? meta.description : '';
        if(baseChannel){
          const before = scopeChannelMetadata[baseChannel] ? Object.assign({}, scopeChannelMetadata[baseChannel]) : null;
          mergeScopeChannelMeta(baseChannel, {
            label: rawLabel || baseChannel,
            io: io || null,
            display: display || null,
            description: description || null
          });
          const after = scopeChannelMetadata[baseChannel];
          if(!before || before.label !== after.label || before.io !== after.io || before.display !== after.display || before.description !== after.description){
            changed = true;
          }
        }
        if(io){
          const beforeIo = scopeChannelMetadata[io] ? Object.assign({}, scopeChannelMetadata[io]) : null;
          mergeScopeChannelMeta(io, {
            label: rawLabel || baseChannel || io,
            io,
            display: display || null,
            description: description || null
          });
          const afterIo = scopeChannelMetadata[io];
          if(!beforeIo || beforeIo.label !== afterIo.label || beforeIo.io !== afterIo.io || beforeIo.display !== afterIo.display || beforeIo.description !== afterIo.description){
            changed = true;
          }
        }
      });
      if(changed){
        refreshScopeChannelListDisplay();
      }
    }
    function ensureDmmOptions(snapshot){
      const sel = $('#dmm-select');
      if(!sel) return;
      const previous = sel.value;
      const metaList = dmmState.config.length ? dmmState.config : buildFallbackMeta(snapshot||[]);
      registerScopeChannelMetaFromDmm(metaList);
      if(!metaList.length){
        sel.innerHTML='';
        updateDmmHeader(null);
        return;
      }
      sel.innerHTML='';
      metaList.forEach(meta=>{
        const opt=document.createElement('option');
        opt.value = meta.io;
        const baseLabel = meta.label || meta.io || '—';
        const detail = meta.io && meta.io !== baseLabel ? ` — ${meta.io}` : '';
        const modeLabel = meta.mode ? ` (${meta.mode})` : '';
        opt.textContent = `${baseLabel}${detail}${modeLabel}`;
        sel.appendChild(opt);
      });
      if(previous && metaList.some(m=>m.io===previous)){
        sel.value = previous;
      }
      if(!sel.value){
        sel.value = metaList[0].io;
      }
      const currentMeta = metaList.find(m=>m.io===sel.value) || metaList[0];
      updateDmmHeader(currentMeta);
    }
    function renderDmm(){
      updateDmmMode();
      const sel = $('#dmm-select');
      if(!sel) return;
      const ioId = sel.value || dmmState.config[0]?.io || dmmState.snapshot[0]?.id || '';
      if(!sel.value && ioId) sel.value = ioId;
      const snapshot = dmmState.snapshot.find(ch=>ch.id===ioId) || dmmState.snapshot[0];
      const meta = getDmmMeta(ioId) || (snapshot ? {
        label: snapshot.id || '—',
        io: snapshot.id || '—',
        mode: 'UDC',
        decimals: 2,
        unit: snapshot.unit || ''
      } : null);
      if(meta) updateDmmHeader(meta);
      const unit = (snapshot?.unit ?? meta?.unit ?? '').toString();
      let formatted = '—.—';
      let numericValue = null;
      if(snapshot && snapshot.value !== undefined && snapshot.value !== null){
        const valueNumber = Number(snapshot.value);
        const decimals = typeof meta?.decimals === 'number' ? meta.decimals : null;
        if(Number.isFinite(valueNumber)){
          numericValue = valueNumber;
          formatted = decimals !== null ? valueNumber.toFixed(decimals) : valueNumber.toString();
        }else{
          formatted = String(snapshot.value);
        }
      }
      dmmState.lastNumericValue = Number.isFinite(numericValue) ? numericValue : null;
      const rawNumber = parseNumeric(snapshot?.raw);
      const binaryValue = Number.isFinite(rawNumber) ? rawNumber : dmmState.lastNumericValue;
      dmmState.lastBinaryValue = Number.isFinite(binaryValue) ? binaryValue : null;
      const displayFormatted = dmmHold && dmmState.holdValue !== null ? dmmState.holdValue : formatted;
      const displayUnit = dmmHold && dmmState.holdUnit !== null ? dmmState.holdUnit : unit;
      $('#dmm-value').textContent = displayFormatted;
      $('#dmm-unit-inline').textContent = displayUnit;
      const effectiveNumeric = dmmHold && dmmState.holdNumeric !== null ? dmmState.holdNumeric : dmmState.lastNumericValue;
      const effectiveBinary = dmmHold && dmmState.holdBinary !== null ? dmmState.holdBinary : dmmState.lastBinaryValue;
      const metaParts = [];
      metaParts.push('Entrée : ' + (meta?.io || snapshot?.id || '—'));
      metaParts.push('Mode : ' + (meta?.mode || '—'));
      metaParts.push('Décimales : ' + (typeof meta?.decimals === 'number' ? meta.decimals : '—'));
      $('#dmm-meta').textContent = metaParts.join(' • ');
      updateDmmBinary(effectiveBinary);
      updateDmmGauge(effectiveNumeric, displayFormatted, displayUnit, meta, snapshot, ioId);
    }
    async function loadDmmConfig(){
      try{
        const r = await j('/api/config?area=dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const cfg = await r.json();
        if(Array.isArray(cfg)){
          dmmState.config = cfg.map((entry, idx)=>{
            const mode = entry.mode || entry.acquisition || 'UDC';
            return {
              label: entry.name || `CH${idx+1}`,
              io: entry.io || `CH${idx+1}`,
              mode,
              decimals: typeof entry.decimals === 'number' ? entry.decimals : 2,
              unit: entry.unit || (mode === 'UDC' ? 'V' : ''),
            };
          });
        }else{
          dmmState.config = [];
        }
      }catch(e){
        console.warn(e);
        dmmState.config = [];
      }
      ensureDmmOptions(dmmState.snapshot);
      renderDmm();
    }
    async function loadDmm(){
      try{
        const r = await j('/api/dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        const channels = Array.isArray(data.channels) ? data.channels : [];
        dmmState.snapshot = channels.map((ch, idx)=>({
          id: ch.id || ch.name || `CH${idx+1}`,
          raw: ch.raw,
          value: ch.value,
          unit: ch.unit
        }));
        const sel = $('#dmm-select');
        if(sel && sel.options.length===0){
          ensureDmmOptions(dmmState.snapshot);
        }
        if(!dmmHold){
          dmmState.holdValue = null;
          dmmState.holdUnit = null;
          dmmState.holdNumeric = null;
          dmmState.holdBinary = null;
        }
        renderDmm();
      }catch(e){
        console.warn(e);
      }
    }
    $('#dmm-hold').addEventListener('click',()=>{
      dmmHold = !dmmHold;
      if(dmmHold){
        dmmState.holdValue = $('#dmm-value').textContent;
        dmmState.holdUnit = $('#dmm-unit-inline').textContent;
        dmmState.holdNumeric = dmmState.lastNumericValue;
        dmmState.holdBinary = dmmState.lastBinaryValue;
      }else{
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      $('#dmm-hold').textContent = dmmHold?'Hold (ON)':'Hold';
      renderDmm();
    });
    $('#dmm-select').addEventListener('change',(e)=>{
      const meta = getDmmMeta(e.target.value) || dmmState.config[0] || null;
      updateDmmHeader(meta);
      if(dmmHold){
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      renderDmm();
    });
    document.querySelectorAll('#card-dmm [data-mode]').forEach(b=>b.addEventListener('click',()=>{
      dmmMode = b.dataset.mode;
      updateDmmMode();
      renderDmm();
    }));
    updateDmmMode();

    /* --------- FUNCGEN --------- */
    const funcTargetSelect = $('#func-target');
    const funcWaveList = $('#func-wave-list');
    const funcOutputName = $('#func-output-name');
    const funcOutputType = $('#func-output-type');
    const funcRangePill = $('#func-range-pill');
    const funcValueLabel = $('#func-value-label');
    const funcValueMain = $('#func-value-main');
    const funcValueSecondary = $('#func-value-secondary');
    const funcParamButtons = $('#func-param-buttons');
    const funcMinusBtn = $('#func-minus');
    const funcPlusBtn = $('#func-plus');
    const funcAdjustScaleGroup = $('#func-adjust-scale');
    const funcSummary = $('#func-summary');
    const funcHint = $('#func-hint');
    const funcTargetPill = $('#func-target-pill');

    const FUNC_WAVE_CATALOG = {
      sine: {
        label: 'Sinus',
        icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12c3-10 5 10 10 0s7 10 10 0"/></svg>'
      },
      square: {
        label: 'Carré',
        icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="2,18 2,6 12,6 12,18 22,18 22,6"/></svg>'
      },
      triangle: {
        label: 'Triangle',
        icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="2,18 8,6 14,18 22,6"/></svg>'
      },
      saw: {
        label: 'Dent de scie',
        icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="2,18 10,6 10,18 18,6 18,18 22,12"/></svg>'
      },
      dc: {
        label: 'DC',
        icon: '<svg viewBox="0 0 24 24" aria-hidden="true"><line x1="2" y1="12" x2="22" y2="12"/></svg>'
      }
    };

    const FUNC_TYPE_PROFILES = {
      mcp4725: {
        label: 'DAC linéaire',
        description: 'Sortie analogique pilotée par MCP4725, idéale pour des signaux doux.',
        parameters: ['amp','offset','freq','phase'],
        waveforms: ['sine','square','triangle'],
        ranges: {
          freq: { min: 0.1, max: 2000, step: 0.1, decimals: 1 },
          amp: { step: 0.5, decimals: 1 },
          offset: { step: 0.5, decimals: 1 },
          phase: { step: 5 }
        },
        hint: 'Ajuste amplitude et offset pour rester dans la plage 0-3,3 V et créer des rampes ou des sinusoïdes analogiques.'
      },
      pwm_rc: {
        label: 'PWM lissée RC',
        description: 'Sortie PWM haute fréquence filtrée par réseau RC.',
        parameters: ['amp','offset','freq','duty'],
        waveforms: ['dc','sine','square','triangle','saw'],
        ranges: {
          freq: { min: 10, max: 20000, step: 10, decimals: 0 },
          amp: { step: 1, decimals: 0 },
          offset: { step: 1, decimals: 0 },
          duty: { min: 5, max: 95, step: 1 }
        },
        hint: 'Utilise la fréquence pour régler la vitesse du PWM et le ratio pour moduler la composante continue filtrée.'
      },
      pwm_0_10v: {
        label: 'Interface 0-10 V',
        description: 'Module PWM → 0-10 V pour variateurs et automates.',
        parameters: ['amp','offset','freq','duty'],
        waveforms: ['sine','square','triangle'],
        ranges: {
          freq: { min: 5, max: 5000, step: 5, decimals: 0 },
          amp: { step: 1, decimals: 0 },
          offset: { step: 1, decimals: 0 },
          duty: { min: 5, max: 95, step: 1 }
        },
        hint: 'Respecte la plage industrielle 0-10 V. Combine amplitude et offset pour appliquer un niveau précis.'
      },
      charge_pump_doubler: {
        label: 'Pompe de charge x2',
        description: 'Générateur basé sur pompe de charge pour charges légères.',
        parameters: ['amp','offset','freq','phase'],
        waveforms: ['sine','square','triangle'],
        ranges: {
          freq: { min: 10, max: 1000, step: 5, decimals: 0 },
          amp: { step: 1, decimals: 0 },
          offset: { step: 1, decimals: 0 },
          phase: { step: 10 }
        },
        hint: 'Pour éviter la saturation, centre ton signal grâce à l’offset et garde une fréquence modérée.'
      },
      default: {
        label: 'Sortie générique',
        description: 'Configuration standard amplitude / offset / fréquence.',
        parameters: ['amp','offset','freq'],
        waveforms: ['sine','square','triangle'],
        ranges: {
          freq: { min: 0.1, max: 1000, step: 0.1, decimals: 1 },
          amp: { step: 1, decimals: 0 },
          offset: { step: 1, decimals: 0 }
        },
        hint: 'Sélectionne une sortie pour accéder aux paramètres spécifiques et façonner ton signal.'
      }
    };

    const FUNC_PARAM_DEFS = {
      amp: {
        key: 'amp_pct',
        label: 'Amplitude',
        symbol: 'U',
        unit: '%',
        default: 50,
        min(ctx){ return ctx.profile?.ranges?.amp?.min ?? 0; },
        max(ctx){ return ctx.profile?.ranges?.amp?.max ?? 100; },
        step(ctx){
          const customStep = ctx.profile?.ranges?.amp?.step;
          if(typeof customStep === 'number' && Number.isFinite(customStep)) return customStep;
          const rawDecimals = ctx.profile?.ranges?.amp?.decimals;
          const decimals = rawDecimals !== undefined ? Math.max(rawDecimals, 2) : 2;
          const base = Math.pow(10, -decimals);
          return Number(base.toFixed(decimals));
        },
        decimals(ctx){
          const rawDecimals = ctx.profile?.ranges?.amp?.decimals;
          return rawDecimals !== undefined ? Math.max(rawDecimals, 2) : 2;
        },
        format(value, ctx){
          const decimalsSetting = ctx.profile?.ranges?.amp?.decimals;
          const decimals = decimalsSetting !== undefined ? Math.max(decimalsSetting, 2) : 2;
          const main = formatNumber(value, decimals);
          const range = ctx.range;
          let secondary = '';
          if(range && Number.isFinite(range.span)){
            const actual = percentToRange(value, range);
            const decimalsActual = range.span < 1 ? 3 : range.span < 5 ? 2 : 1;
            secondary = `≈ ${formatNumber(actual, decimalsActual)} ${range.unit || ''}`;
          }
          return { main, unit: '%', secondary };
        }
      },
      offset: {
        key: 'offset_pct',
        label: 'Offset',
        symbol: 'U₀',
        unit: '%',
        default: 0,
        min(ctx){
          if(ctx.profile?.ranges?.offset?.min !== undefined) return ctx.profile.ranges.offset.min;
          if(ctx.range && typeof ctx.range.min === 'number' && ctx.range.min >= 0) return 0;
          return -100;
        },
        max(ctx){ return ctx.profile?.ranges?.offset?.max ?? 100; },
        step(ctx){ return ctx.profile?.ranges?.offset?.step ?? 1; },
        decimals(ctx){ return ctx.profile?.ranges?.offset?.decimals ?? 1; },
        format(value, ctx){
          const decimals = ctx.profile?.ranges?.offset?.decimals ?? 1;
          const main = formatNumber(value, decimals);
          const range = ctx.range;
          let secondary = '';
          if(range && Number.isFinite(range.span)){
            const actual = percentToRange(value, range);
            const decimalsActual = range.span < 1 ? 3 : range.span < 5 ? 2 : 1;
            secondary = `≈ ${formatNumber(actual, decimalsActual)} ${range.unit || ''}`;
          }
          return { main, unit: '%', secondary };
        }
      },
      freq: {
        key: 'freq',
        label: 'Fréquence',
        symbol: 'f',
        unit: 'Hz',
        default: 50,
        min(ctx){ return ctx.profile?.ranges?.freq?.min ?? 0.1; },
        max(ctx){ return ctx.profile?.ranges?.freq?.max ?? 20000; },
        step(ctx){ return ctx.profile?.ranges?.freq?.step ?? 1; },
        decimals(ctx, value){
          if(ctx.profile?.ranges?.freq?.decimals !== undefined) return ctx.profile.ranges.freq.decimals;
          if(value < 1) return 2;
          if(value < 10) return 1;
          return 0;
        },
        format(value){
          let unit = 'Hz';
          let mainValue = value;
          if(value >= 1000){
            unit = 'kHz';
            mainValue = value / 1000;
          }
          const decimals = value >= 1000 ? (value >= 10000 ? 1 : 2) : (value < 1 ? 2 : value < 10 ? 1 : 0);
          const main = formatNumber(mainValue, decimals);
          const secondary = value >= 1000 ? `(${formatNumber(value, 0)} Hz)` : '';
          return { main, unit, secondary };
        }
      },
      phase: {
        key: 'phase_deg',
        label: 'Déphasage',
        symbol: 'φ',
        unit: '°',
        default: 0,
        min(){ return 0; },
        max(){ return 360; },
        step(ctx){ return ctx.profile?.ranges?.phase?.step ?? 10; },
        decimals(){ return 0; },
        wrap: true,
        format(value){
          return { main: formatNumber(value, 0), unit: '°', secondary: '' };
        }
      },
      duty: {
        key: 'duty_pct',
        label: 'Ratio',
        symbol: 'D',
        unit: '%',
        default: 50,
        min(ctx){ return ctx.profile?.ranges?.duty?.min ?? 0; },
        max(ctx){ return ctx.profile?.ranges?.duty?.max ?? 100; },
        step(ctx){ return ctx.profile?.ranges?.duty?.step ?? 1; },
        decimals(ctx){ return ctx.profile?.ranges?.duty?.decimals ?? 0; },
        format(value){
          return { main: formatNumber(value, 0), unit: '%', secondary: '' };
        }
      }
    };

    let funcOutputs = [];
    let funcCurrentOutput = null;
    let funcCurrentProfile = FUNC_TYPE_PROFILES.default;
    let funcAdjustScales = [1];
    let funcAdjustScaleIndex = 0;
    let funcAdjustBaseStep = 1;
    const funcState = {
      target: '',
      type: '',
      wave: 'sine',
      currentParam: 'amp',
      freq: 50,
      amp_pct: 50,
      offset_pct: 0,
      duty_pct: 50,
      phase_deg: 0
    };

    function formatNumber(value, decimals){
      const safeDecimals = Math.max(0, Math.min(6, Math.round(decimals ?? 0)));
      return Number.isFinite(value) ? new Intl.NumberFormat('fr-FR', { minimumFractionDigits: safeDecimals, maximumFractionDigits: safeDecimals }).format(value) : '—';
    }
    function percentToRange(percent, range){
      if(!range) return null;
      const span = Number(range.span);
      if(!Number.isFinite(span)) return null;
      return range.min + span * (percent/100);
    }
    function getOutputRange(output){
      if(!output || !output.config) return null;
      const range = output.config.range;
      if(!range || typeof range.min !== 'number' || typeof range.max !== 'number') return null;
      const unit = typeof range.unit === 'string' ? range.unit : '';
      const span = range.max - range.min;
      return { min: range.min, max: range.max, unit, span };
    }
    function getProfileForType(type){
      return FUNC_TYPE_PROFILES[type] || FUNC_TYPE_PROFILES.default;
    }
    function getFuncContext(){
      return { profile: funcCurrentProfile || FUNC_TYPE_PROFILES.default, output: funcCurrentOutput, range: getOutputRange(funcCurrentOutput) };
    }
    function getActiveParams(profile){
      const base = Array.isArray(profile?.parameters) && profile.parameters.length ? profile.parameters.slice() : ['amp','offset','freq'];
      const existing = base.filter((param, index, array)=>array.indexOf(param) === index && FUNC_PARAM_DEFS[param]);
      const wave = funcState.wave;
      let filtered = existing;
      if(wave === 'dc'){
        filtered = existing.filter(param=>!['offset','freq','duty','phase'].includes(param));
      }
      if(!filtered.length){
        if(existing.includes('amp')){
          filtered = ['amp'];
        }else if(existing.length){
          filtered = [existing[0]];
        }else{
          filtered = ['amp'];
        }
      }
      return filtered.filter(param=>FUNC_PARAM_DEFS[param]);
    }
    function describeScale(scale){
      const map = {
        1000: 'milliers',
        100: 'centaines',
        10: 'dizaines',
        1: 'unités',
        0.1: 'dixièmes',
        0.01: 'centièmes',
        0.001: 'millièmes',
        0.0001: 'dix-millièmes'
      };
      const rounded = Number(scale.toFixed(4));
      if(map[rounded]) return map[rounded];
      if(scale > 1){
        return `×${formatNumber(scale, 0)}`;
      }
      const decimals = Math.round(Math.abs(Math.log10(scale)));
      if(!Number.isFinite(decimals)) return formatNumber(scale, 0);
      if(decimals === 0) return 'unités';
      if(decimals === 1) return 'dixièmes';
      if(decimals === 2) return 'centièmes';
      if(decimals === 3) return 'millièmes';
      return `10^-${decimals}`;
    }
    function formatScaleLabel(scale){
      if(scale >= 1){
        return formatNumber(scale, 0);
      }
      const decimals = Math.max(1, Math.round(Math.abs(Math.log10(scale))));
      return formatNumber(scale, decimals);
    }
    function buildAdjustScaleList(def, ctx){
      if(!def) return [1];
      const value = funcState[def.key];
      const min = typeof def.min === 'function' ? def.min(ctx, value) : def.min;
      const max = typeof def.max === 'function' ? def.max(ctx, value) : def.max;
      const magnitudes = [];
      if(Number.isFinite(value)) magnitudes.push(Math.abs(value));
      if(Number.isFinite(min)) magnitudes.push(Math.abs(min));
      if(Number.isFinite(max)) magnitudes.push(Math.abs(max));
      let absoluteMax = magnitudes.length ? Math.max(...magnitudes) : 0;
      if(!Number.isFinite(absoluteMax) || absoluteMax <= 0){
        absoluteMax = 1;
      }
      let highest = 1;
      while(highest * 10 <= absoluteMax){
        highest *= 10;
      }
      const scales = new Set();
      for(let scale = highest; scale >= 1; scale /= 10){
        const rounded = Number(scale.toFixed(0));
        scales.add(rounded);
        if(scale === 1) break;
      }
      const decimals = Math.max(0, Math.min(6, typeof def.decimals === 'function' ? def.decimals(ctx, value) : (def.decimals ?? 0)));
      for(let i = 1; i <= decimals; i += 1){
        const fraction = Number(Math.pow(10, -i).toFixed(i));
        scales.add(fraction);
      }
      if(!scales.size) scales.add(1);
      return Array.from(scales).sort((a,b)=>b-a);
    }
    function renderAdjustScaleButtons(){
      if(!funcAdjustScaleGroup) return;
      const hadFocus = funcAdjustScaleGroup.contains(document.activeElement);
      funcAdjustScaleGroup.innerHTML = '';
      funcAdjustScales.forEach((scale, index)=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'func-scale-btn' + (index === funcAdjustScaleIndex ? ' active' : '');
        btn.dataset.scale = String(scale);
        btn.setAttribute('role','radio');
        btn.setAttribute('aria-checked', index === funcAdjustScaleIndex ? 'true' : 'false');
        const label = formatScaleLabel(scale);
        const description = describeScale(scale);
        btn.setAttribute('title', `Pas ${description} (×${label})`);
        btn.setAttribute('aria-label', `Pas ${description} (×${label})`);
        btn.tabIndex = index === funcAdjustScaleIndex ? 0 : -1;
        btn.innerHTML = `<span class="arrow" aria-hidden="true">▲</span><span class="func-scale-text">${label}</span><span class="arrow" aria-hidden="true">▼</span>`;
        btn.addEventListener('click', ()=>{
          funcAdjustScaleIndex = index;
          renderAdjustScaleButtons();
        });
        funcAdjustScaleGroup.appendChild(btn);
      });
      if(hadFocus){
        const activeBtn = funcAdjustScaleGroup.querySelector('.func-scale-btn.active');
        if(activeBtn) activeBtn.focus();
      }
    }
    function updateAdjustScaleState(param, ctx){
      if(!funcAdjustScaleGroup) return;
      const def = FUNC_PARAM_DEFS[param];
      if(!def){
        funcAdjustScales = [1];
        funcAdjustScaleIndex = 0;
        funcAdjustBaseStep = 1;
        funcAdjustScaleGroup.innerHTML = '';
        return;
      }
      const value = funcState[def.key];
      const baseStepRaw = typeof def.step === 'function' ? def.step(ctx, value) : (def.step ?? 1);
      funcAdjustBaseStep = Number.isFinite(baseStepRaw) && baseStepRaw !== 0 ? Math.abs(baseStepRaw) : 1;
      const scales = buildAdjustScaleList(def, ctx);
      const previousScale = funcAdjustScales[funcAdjustScaleIndex];
      funcAdjustScales = scales.length ? scales : [1];
      let desired = previousScale && funcAdjustScales.includes(previousScale) ? previousScale : null;
      if(!desired){
        desired = funcAdjustScales.includes(1) ? 1 : funcAdjustScales[0];
      }
      funcAdjustScaleIndex = Math.max(0, funcAdjustScales.indexOf(desired));
      renderAdjustScaleButtons();
    }
    function getCurrentAdjustScale(){
      return funcAdjustScales[funcAdjustScaleIndex] || 1;
    }
    function ensureParamWithinBounds(param, value){
      const def = FUNC_PARAM_DEFS[param];
      if(!def) return value;
      const ctx = getFuncContext();
      const min = typeof def.min === 'function' ? def.min(ctx, value) : (def.min ?? -Infinity);
      const max = typeof def.max === 'function' ? def.max(ctx, value) : (def.max ?? Infinity);
      if(def.wrap){
        const span = max - min;
        if(span <= 0) return Math.min(Math.max(value, min), max);
        let wrapped = value;
        while(wrapped < min) wrapped += span;
        while(wrapped > max) wrapped -= span;
        return wrapped;
      }
      return Math.min(Math.max(value, min), max);
    }
    function formatParam(param, ctx){
      const def = FUNC_PARAM_DEFS[param];
      if(!def) return { main: '—', unit: '', secondary: '' };
      const key = def.key;
      let value = funcState[key];
      if(!Number.isFinite(value)){
        const fallback = typeof def.default === 'function' ? def.default(ctx) : def.default;
        value = Number.isFinite(fallback) ? fallback : 0;
      }
      if(typeof def.format === 'function'){
        return def.format(value, ctx);
      }
      const decimals = typeof def.decimals === 'function' ? def.decimals(ctx, value) : (def.decimals ?? 0);
      return { main: formatNumber(value, decimals), unit: def.unit || '', secondary: '' };
    }
    function updateWaveButtons(){
      if(!funcWaveList) return;
      funcWaveList.querySelectorAll('button').forEach(btn=>{
        const active = btn.dataset.wave === funcState.wave;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-checked', active ? 'true' : 'false');
      });
    }
    function updateFuncSummary(){
      if(!funcSummary) return;
      const ctx = getFuncContext();
      const profile = ctx.profile;
      const params = getActiveParams(profile);
      funcSummary.innerHTML = '';
      funcSummary.classList.remove('empty');
      if(!profile || !params.length){
        funcSummary.classList.add('empty');
        const empty = document.createElement('span');
        empty.className = 'func-summary-item func-summary-empty';
        empty.setAttribute('role','listitem');
        empty.textContent = '—';
        funcSummary.appendChild(empty);
        return;
      }
      let hasItem = false;
      let itemCount = 0;
      params.forEach(param=>{
        const def = FUNC_PARAM_DEFS[param];
        if(!def) return;
        const formatted = formatParam(param, ctx);
        const item = document.createElement('span');
        item.className = 'func-summary-item' + (param === funcState.currentParam ? ' current' : '');
        item.setAttribute('role','listitem');
        const labelText = def.label || param;
        const mainText = formatted.unit ? `${formatted.main} ${formatted.unit}` : formatted.main;
        let description = `${labelText}: ${mainText}`;
        if(formatted.secondary){
          description += ` (${formatted.secondary})`;
        }
        item.setAttribute('title', description);
        item.setAttribute('aria-label', description);
        item.dataset.param = param;
        if(itemCount > 0){
          const separator = document.createElement('span');
          separator.className = 'func-summary-separator';
          separator.textContent = '•';
          separator.setAttribute('aria-hidden', 'true');
          funcSummary.appendChild(separator);
        }
        const value = document.createElement('span');
        value.className = 'func-summary-value';
        value.textContent = formatted.main;
        if(formatted.unit){
          const unit = document.createElement('span');
          unit.className = 'unit';
          unit.textContent = formatted.unit;
          value.appendChild(unit);
        }
        item.appendChild(value);
        if(formatted.secondary){
          const secondary = document.createElement('span');
          secondary.className = 'func-summary-secondary';
          secondary.textContent = formatted.secondary;
          item.appendChild(secondary);
        }
        funcSummary.appendChild(item);
        hasItem = true;
        itemCount += 1;
      });
      if(!hasItem){
        funcSummary.classList.add('empty');
        const empty = document.createElement('span');
        empty.className = 'func-summary-item func-summary-empty';
        empty.setAttribute('role','listitem');
        empty.textContent = '—';
        funcSummary.appendChild(empty);
      }
    }
    function renderFuncParamButtons(profile){
      if(!funcParamButtons) return;
      funcParamButtons.innerHTML = '';
      const params = getActiveParams(profile);
      if(!params.length) return;
      if(!params.includes(funcState.currentParam)){
        funcState.currentParam = params[0];
      }
      params.forEach(param=>{
        const def = FUNC_PARAM_DEFS[param];
        if(!def) return;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'func-param-btn' + (funcState.currentParam === param ? ' active' : '');
        btn.dataset.param = param;
        const tooltip = def.label || param;
        btn.dataset.tooltip = tooltip;
        btn.setAttribute('aria-label', tooltip);
        btn.setAttribute('title', tooltip);
        const symbol = document.createElement('span');
        symbol.className = 'symbol';
        symbol.textContent = def.symbol || (tooltip ? tooltip.charAt(0) : param.charAt(0)).toUpperCase();
        const sr = document.createElement('span');
        sr.className = 'sr-only';
        sr.textContent = tooltip;
        btn.append(symbol, sr);
        btn.addEventListener('click', ()=>{
          funcState.currentParam = param;
          updateFuncDisplay();
        });
        funcParamButtons.appendChild(btn);
      });
    }
    function renderFuncWaveButtons(profile){
      if(!funcWaveList) return;
      funcWaveList.innerHTML = '';
      const waves = Array.isArray(profile?.waveforms) && profile.waveforms.length ? profile.waveforms : ['sine','square','triangle'];
      if(!waves.includes(funcState.wave)){
        funcState.wave = waves[0];
      }
      waves.forEach(wave=>{
        const meta = FUNC_WAVE_CATALOG[wave] || { label: wave, icon: '' };
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'func-wave-btn' + (funcState.wave === wave ? ' active' : '');
        btn.dataset.wave = wave;
        btn.setAttribute('role','radio');
        btn.setAttribute('aria-checked', funcState.wave === wave ? 'true' : 'false');
        btn.innerHTML = `${meta.icon || ''}<span>${meta.label}</span>`;
        btn.addEventListener('click', ()=>{
          if(funcState.wave !== wave){
            funcState.wave = wave;
            updateWaveButtons();
            renderFuncParamButtons(funcCurrentProfile);
            updateFuncDisplay();
          }
        });
        funcWaveList.appendChild(btn);
      });
      updateWaveButtons();
    }
    function applyParamDefaults(profile){
      if(!profile) return;
      const ctx = getFuncContext();
      const params = Array.isArray(profile.parameters) && profile.parameters.length ? profile.parameters : ['amp','offset','freq'];
      params.forEach(param=>{
        const def = FUNC_PARAM_DEFS[param];
        if(!def) return;
        const key = def.key;
        let value = funcState[key];
        if(!Number.isFinite(value)){
          const fallback = typeof def.default === 'function' ? def.default(ctx) : def.default;
          value = Number.isFinite(fallback) ? fallback : 0;
        }
        value = ensureParamWithinBounds(param, value);
        funcState[key] = value;
      });
    }
    function updateFuncDisplay(){
      const ctx = getFuncContext();
      const activeParams = getActiveParams(ctx.profile);
      if(activeParams.length && !activeParams.includes(funcState.currentParam)){
        funcState.currentParam = activeParams[0];
      }
      const currentParam = funcState.currentParam;
      updateAdjustScaleState(currentParam, ctx);
      const def = FUNC_PARAM_DEFS[currentParam];
      if(def){
        const formatted = formatParam(currentParam, ctx);
        if(funcValueLabel) funcValueLabel.textContent = def.label;
        if(funcValueMain) funcValueMain.innerHTML = `${formatted.main}<span class="unit">${formatted.unit || ''}</span>`;
        if(funcValueSecondary){
          funcValueSecondary.textContent = formatted.secondary || ' ';
          funcValueSecondary.style.opacity = formatted.secondary ? '1' : '0.4';
        }
      }
      if(funcParamButtons){
        funcParamButtons.querySelectorAll('button').forEach(btn=>{
          btn.classList.toggle('active', btn.dataset.param === currentParam);
        });
      }
      updateFuncSummary();
      updateWaveButtons();
    }
    function setFuncTarget(id){
      const output = funcOutputs.find(entry=>entry.id === id) || null;
      funcCurrentOutput = output;
      funcCurrentProfile = getProfileForType(output?.type);
      funcState.target = output ? output.id : '';
      funcState.type = output ? output.type : '';
      if(funcTargetSelect && funcTargetSelect.value !== (funcState.target || '')){
        funcTargetSelect.value = funcState.target || '';
      }
      if(funcTargetPill) funcTargetPill.textContent = 'cible : ' + (funcState.target || '—');
      const ctx = getFuncContext();
      applyParamDefaults(funcCurrentProfile);
      if(funcOutputName) funcOutputName.textContent = output ? (output.name || output.id) : '—';
      if(funcOutputType) funcOutputType.textContent = funcCurrentProfile.description || funcCurrentProfile.label || (output?.type || 'type inconnu');
      const range = ctx.range;
      if(funcRangePill){
        if(range){
          const decimals = range.span < 1 ? 3 : range.span < 5 ? 2 : 1;
          funcRangePill.textContent = `Plage : ${formatNumber(range.min, decimals)} – ${formatNumber(range.max, decimals)} ${range.unit || ''}`;
        }else{
          funcRangePill.textContent = 'Plage : —';
        }
      }
      if(funcHint) funcHint.textContent = funcCurrentProfile.hint || FUNC_TYPE_PROFILES.default.hint;
      renderFuncWaveButtons(funcCurrentProfile);
      renderFuncParamButtons(funcCurrentProfile);
      updateFuncDisplay();
    }
    function adjustFuncParam(direction){
      const param = funcState.currentParam;
      const def = FUNC_PARAM_DEFS[param];
      if(!def) return;
      const ctx = getFuncContext();
      const rawStep = typeof def.step === 'function' ? def.step(ctx, funcState[def.key]) : (def.step ?? 1);
      const baseStep = Number.isFinite(rawStep) && rawStep !== 0 ? Math.abs(rawStep) : funcAdjustBaseStep || 1;
      const scale = getCurrentAdjustScale();
      const multiplier = Number.isFinite(scale) && scale > 0 ? scale : 1;
      const step = baseStep * multiplier;
      let current = funcState[def.key];
      if(!Number.isFinite(current)){
        const fallback = typeof def.default === 'function' ? def.default(ctx) : def.default;
        current = Number.isFinite(fallback) ? fallback : 0;
      }
      let next = current + direction * step;
      next = ensureParamWithinBounds(param, next);
      const decimals = typeof def.decimals === 'function' ? def.decimals(ctx, next) : (def.decimals ?? 0);
      funcState[def.key] = Number.isFinite(next) ? parseFloat(next.toFixed(Math.min(6, Math.max(decimals, 2)))) : current;
      updateFuncDisplay();
    }
    function normaliseOutputEntry(entry){
      if(!entry || typeof entry !== 'object') return null;
      const id = typeof entry.id === 'string' ? entry.id : '';
      if(!id) return null;
      return {
        id,
        type: typeof entry.type === 'string' ? entry.type : '',
        name: typeof entry.name === 'string' ? entry.name : (typeof entry.label === 'string' ? entry.label : id),
        config: typeof entry.config === 'object' && entry.config ? entry.config : {}
      };
    }
    function parseOutputList(data){
      if(Array.isArray(data)) return data.map(normaliseOutputEntry).filter(Boolean);
      if(data && Array.isArray(data.outputs)) return data.outputs.map(normaliseOutputEntry).filter(Boolean);
      return [];
    }
    async function fetchFuncOutputs(){
      let list = [];
      try{
        const resp = await j('/api/config?area=outputs');
        if(resp.ok){
          const payload = await resp.json();
          list = parseOutputList(payload);
        }
      }catch(err){
        console.warn(err);
      }
      if(!list.length){
        try{
          const fallback = await fetch('outputs.json',{cache:'no-cache'});
          if(fallback.ok){
            const payload = await fallback.json();
            list = parseOutputList(payload);
          }
        }catch(err){
          console.warn(err);
        }
      }
      return list;
    }
    if(funcMinusBtn) funcMinusBtn.addEventListener('click', ()=>adjustFuncParam(-1));
    if(funcPlusBtn) funcPlusBtn.addEventListener('click', ()=>adjustFuncParam(1));
    if(funcAdjustScaleGroup){
      funcAdjustScaleGroup.addEventListener('keydown', event=>{
        if(!funcAdjustScales.length) return;
        let delta = 0;
        if(event.key === 'ArrowLeft' || event.key === 'ArrowUp') delta = -1;
        else if(event.key === 'ArrowRight' || event.key === 'ArrowDown') delta = 1;
        if(delta !== 0){
          event.preventDefault();
          const nextIndex = Math.max(0, Math.min(funcAdjustScales.length - 1, funcAdjustScaleIndex + delta));
          if(nextIndex !== funcAdjustScaleIndex){
            funcAdjustScaleIndex = nextIndex;
            renderAdjustScaleButtons();
          }
        }
      });
    }
    if(funcTargetSelect) funcTargetSelect.addEventListener('change', ()=>setFuncTarget(funcTargetSelect.value));

    async function loadIOForFunc(){
      if(!funcTargetSelect) return;
      funcOutputs = await fetchFuncOutputs();
      funcTargetSelect.innerHTML = '';
      if(funcOutputs.length){
        funcOutputs.forEach(output=>{
          const opt = document.createElement('option');
          opt.value = output.id;
          const profile = getProfileForType(output.type);
          opt.textContent = `${output.id} — ${profile.label}`;
          funcTargetSelect.appendChild(opt);
        });
      }else{
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = '—';
        funcTargetSelect.appendChild(opt);
      }
      let cfg = null;
      try{
        const cfgResp = await j('/api/config?area=funcgen');
        if(cfgResp.ok){
          cfg = await cfgResp.json();
        }
      }catch(err){
        console.warn(err);
      }
      if(!cfg){
        try{
          const fallback = await fetch('funcgen.json',{cache:'no-cache'});
          if(fallback.ok){
            cfg = await fallback.json();
          }
        }catch(err){
          console.warn(err);
        }
      }
      if(cfg && typeof cfg === 'object'){
        if(typeof cfg.freq === 'number') funcState.freq = cfg.freq;
        if(typeof cfg.amp_pct === 'number') funcState.amp_pct = cfg.amp_pct;
        if(typeof cfg.offset_pct === 'number') funcState.offset_pct = cfg.offset_pct;
        if(typeof cfg.duty_pct === 'number') funcState.duty_pct = cfg.duty_pct;
        if(typeof cfg.phase_deg === 'number') funcState.phase_deg = cfg.phase_deg;
        if(typeof cfg.type === 'string') funcState.wave = cfg.type;
        if(typeof cfg.target === 'string') funcState.target = cfg.target;
      }
      if(funcOutputs.length){
        const preferred = funcState.target && funcOutputs.some(o=>o.id === funcState.target) ? funcState.target : funcOutputs[0].id;
        funcTargetSelect.value = preferred;
      }else{
        funcTargetSelect.value = '';
      }
      setFuncTarget(funcTargetSelect.value);
    }
    async function applyFunc(){
      const target = funcTargetSelect ? funcTargetSelect.value : funcState.target;
      if(target) funcState.target = target;
      const payload = {
        type: funcState.wave || 'sine',
        freq: Number.isFinite(funcState.freq) ? funcState.freq : 0,
        amp_pct: Number.isFinite(funcState.amp_pct) ? funcState.amp_pct : 0,
        offset_pct: Number.isFinite(funcState.offset_pct) ? funcState.offset_pct : 0,
        enabled: true
      };
      if(Number.isFinite(funcState.duty_pct)) payload.duty_pct = funcState.duty_pct;
      if(Number.isFinite(funcState.phase_deg)) payload.phase_deg = funcState.phase_deg;
      if(target) payload.target = target;
      try{
        const r = await j('/api/funcgen',{method:'POST', body: JSON.stringify(payload)});
        let ok = null;
        if(r.ok){
          ok = await r.json().catch(()=>({}));
        }
        const success = r.ok && ok && (ok.ok === true || ok.success === true || ok.status === 'ok');
        if(funcTargetPill) funcTargetPill.textContent = 'cible : ' + (target || '—');
      }catch(e){
        console.warn(e);
        if(funcTargetPill) funcTargetPill.textContent = 'cible : ' + (target || '—');
      }
    }
    $('#func-apply').addEventListener('click', applyFunc);

    /* --------- SCOPE (aperçu 1 canal) --------- */
    const scopeMeta = $('#scope-meta');
    const scopeTraceInfo = $('#scope-trace-info');
    const scopeTimebaseSelect = $('#scope-timebase-select');
    const scopeVoltSelect = $('#scope-volt-select');
    const scopeVoltStatus = $('#scope-volt-status');
    const scopeTimebaseStatus = $('#scope-timebase-status');
    const scopeTraceStatus = $('#scope-trace-status');
    const scopeTimebasePill = $('#scope-timebase');
    const scopeVoltageLabel = $('#scope-voltage-scale');
    const scopeTimeLabel = $('#scope-time-scale');
    const scopeTracePath = $('#scope-trace-path');
    const scopeTraceModal = $('#scope-trace-modal');
    const scopeTraceForm = $('#scope-trace-form');
    const scopeTraceChannelSelect = $('#scope-trace-channel');
    const scopeTraceColor = $('#scope-trace-color');
    const scopeTraceOffsetX = $('#scope-trace-offset-x');
    const scopeTraceOffsetY = $('#scope-trace-offset-y');
    const scopeTraceOpen = $('#scope-trace-open');
    const scopeTraceCancel = $('#scope-trace-cancel');
    const scopeChannelBadge = $('#scope-chan');
    const scopeDebugValue = $('#scope-debug-value');
    const scopeVoltsPerDivValues = [0.01,0.02,0.05,0.1,0.2,0.5,1,2,5,10];
    const scopeTimebaseValues = [0.05,0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,2000];
    const scopeColorPalette = ['#64ffda','#ffd74d','#3dff70','#ff5f85','#00d2ff','#b19cff'];
    const scopeGridSize = {width:500, height:500};
    const scopeDivisions = {horizontal:10, vertical:8};
    const scopeOffsetLimits = {horizontal:5, vertical:5};

    let scopeSelectedChannel = null;
    let scopeChannelColors = {};
    let scopeLatestSamples = [];
    let scopeChannelsData = {};
    let scopeLastScopeData = null;
    let scopeUsingFallback = false;
    let scopeNextScopeApiRetry = 0;
    let scopeFallbackCache = null;
    let scopeApiUnavailable = false;
    let scopeChannelOffsets = {};
    let scopeConfigCache = null;
    let scopeConfigUnavailable = false;
    let scopeManualVoltPerDiv = null;
    let scopeManualTimebase = null;

    function getScopeChannelMeta(channel){
      if(!channel) return null;
      return scopeChannelMetadata[channel] || null;
    }

    function getScopeChannelBaseLabel(channel){
      const meta = getScopeChannelMeta(channel);
      if(meta && typeof meta.label === 'string' && meta.label){
        return meta.label;
      }
      return channel || '—';
    }

    function formatScopeChannelOptionLabel(channel){
      if(!channel) return '—';
      const meta = getScopeChannelMeta(channel);
      if(!meta) return channel;
      if(typeof meta.display === 'string' && meta.display){
        return meta.display;
      }
      const base = meta.label || channel;
      const io = meta.io && meta.io !== base ? meta.io : null;
      return io ? `${base} — ${io}` : base;
    }

    function buildScopeChannelTooltip(channel){
      const meta = getScopeChannelMeta(channel);
      if(!meta) return '';
      const parts = [];
      if(meta.io) parts.push(`Entrée : ${meta.io}`);
      if(meta.description) parts.push(meta.description);
      return parts.join(' • ');
    }

    function refreshScopeChannelListDisplay(){
      if(!scopeTraceChannelSelect) return;
      const channels = Object.keys(scopeChannelsData || {});
      if(!channels.length) return;
      setScopeChannelList(channels);
      refreshScopeChannelBadge();
    }

    function extractScopeChannelMetaFromRaw(entry, channel){
      if(!entry || typeof entry !== 'object' || Array.isArray(entry)) return null;
      const info = {};
      const labelCandidates = [entry.display, entry.label, entry.name, entry.title, entry.caption];
      const ioCandidates = [entry.io, entry.input, entry.source, entry.pin, entry.id];
      const descriptionCandidates = [entry.description, entry.details, entry.note];
      labelCandidates.forEach((candidate)=>{
        if(!info.label && typeof candidate === 'string' && candidate.trim()){
          info.label = candidate.trim();
        }
      });
      ioCandidates.forEach((candidate)=>{
        if(!info.io && typeof candidate === 'string' && candidate.trim()){
          const value = candidate.trim();
          if(!channel || value !== channel){
            info.io = value;
          }
        }
      });
      descriptionCandidates.forEach((candidate)=>{
        if(!info.description && typeof candidate === 'string' && candidate.trim()){
          info.description = candidate.trim();
        }
      });
      if(typeof entry.display === 'string' && entry.display.trim()){
        info.display = entry.display.trim();
      }
      const nestedSources = [entry.meta, entry.info, entry.details_meta];
      for(const nested of nestedSources){
        if(nested && typeof nested === 'object'){
          const nestedInfo = extractScopeChannelMetaFromRaw(nested, channel);
          if(nestedInfo){
            if(nestedInfo.label && !info.label) info.label = nestedInfo.label;
            if(nestedInfo.io && !info.io) info.io = nestedInfo.io;
            if(nestedInfo.display && !info.display) info.display = nestedInfo.display;
            if(nestedInfo.description && !info.description) info.description = nestedInfo.description;
          }
        }
      }
      return (info.label || info.io || info.display || info.description) ? info : null;
    }

    function updateScopeChannelMetadataFromConfig(cfg){
      if(!cfg || typeof cfg !== 'object') return;
      let changed = false;
      const register = (channel, meta)=>{
        if(!channel) return;
        const before = scopeChannelMetadata[channel] ? Object.assign({}, scopeChannelMetadata[channel]) : null;
        mergeScopeChannelMeta(channel, meta || {});
        const after = scopeChannelMetadata[channel];
        if(!before || before.label !== after.label || before.io !== after.io || before.display !== after.display || before.description !== after.description){
          changed = true;
        }
      };
      if(Array.isArray(cfg.channels)){
        cfg.channels.forEach((entry, idx)=>{
          if(entry && typeof entry === 'object'){
            const channel = typeof entry.channel === 'string' && entry.channel.trim()
              ? entry.channel.trim()
              : (typeof entry.id === 'string' && entry.id.trim() ? entry.id.trim() : `CH${idx+1}`);
            const meta = extractScopeChannelMetaFromRaw(entry, channel) || {};
            if(!meta.io && typeof entry.io === 'string' && entry.io.trim()){
              meta.io = entry.io.trim();
            }
            register(channel, meta);
          }else if(typeof entry === 'string' && entry.trim()){
            register(entry.trim(), {label: entry.trim()});
          }
        });
      }
      if(cfg.channel_map && typeof cfg.channel_map === 'object'){
        Object.entries(cfg.channel_map).forEach(([channel, entry])=>{
          if(typeof entry === 'string' && entry.trim()){
            register(channel, {io: entry.trim()});
          }else if(entry && typeof entry === 'object'){
            const meta = extractScopeChannelMetaFromRaw(entry, channel) || {};
            if(!meta.io && typeof entry.io === 'string' && entry.io.trim()){
              meta.io = entry.io.trim();
            }
            register(channel, meta);
          }
        });
      }
      if(cfg.channel_meta && typeof cfg.channel_meta === 'object'){
        Object.entries(cfg.channel_meta).forEach(([channel, entry])=>{
          if(entry && typeof entry === 'object'){
            const meta = extractScopeChannelMetaFromRaw(entry, channel) || {};
            register(channel, meta);
          }
        });
      }
      if(typeof cfg.channel === 'string' && cfg.channel.trim()){
        const singleMeta = {};
        if(typeof cfg.io === 'string' && cfg.io.trim()) singleMeta.io = cfg.io.trim();
        if(typeof cfg.input === 'string' && cfg.input.trim()) singleMeta.io = cfg.input.trim();
        if(typeof cfg.label === 'string' && cfg.label.trim()) singleMeta.label = cfg.label.trim();
        if(typeof cfg.display === 'string' && cfg.display.trim()) singleMeta.display = cfg.display.trim();
        register(cfg.channel.trim(), singleMeta);
      }
      if(changed){
        refreshScopeChannelListDisplay();
      }
    }

    function formatVolt(value, suffix=''){
      if(value === null || value === undefined || Number.isNaN(value)) return '—';
      const abs = Math.abs(value);
      if(abs >= 1000){ return `${(value/1000).toFixed(2)} kV${suffix}`; }
      if(abs >= 1){ return `${value.toFixed(abs >= 10 ? 1 : 2)} V${suffix}`; }
      if(abs >= 0.001){ return `${(value*1000).toFixed(abs >= 0.01 ? 1 : 2)} mV${suffix}`; }
      return `${(value*1e6).toFixed(1)} µV${suffix}`;
    }

    function formatTimebase(ms){
      if(ms === null || ms === undefined || Number.isNaN(ms)) return '—';
      if(ms >= 1000){
        const value = ms/1000;
        const digits = value >= 10 ? 0 : 2;
        return `${value.toFixed(digits)} s/div`;
      }
      if(ms >= 1){
        const digits = ms >= 10 ? 0 : 2;
        return `${ms.toFixed(digits)} ms/div`;
      }
      const us = ms*1000;
      const digits = us >= 10 ? 0 : 2;
      return `${us.toFixed(digits)} µs/div`;
    }

    function formatVoltPerDiv(v){
      if(v === null || v === undefined || Number.isNaN(v)) return '—';
      if(v >= 1){
        const digits = v >= 10 ? 0 : 1;
        return `${v.toFixed(digits)} V/div`;
      }
      if(v >= 0.001){
        const mv = v*1000;
        const digits = mv >= 10 ? 0 : 1;
        return `${mv.toFixed(digits)} mV/div`;
      }
      return `${(v*1e6).toFixed(0)} µV/div`;
    }

    function populateSelect(select, values, formatter){
      if(!select) return;
      select.innerHTML = '';
      values.forEach((val)=>{
        const opt = document.createElement('option');
        opt.value = String(val);
        opt.textContent = formatter(val);
        select.appendChild(opt);
      });
    }

    populateSelect(scopeTimebaseSelect, scopeTimebaseValues, (ms)=>formatTimebase(ms));
    populateSelect(scopeVoltSelect, scopeVoltsPerDivValues, (v)=>formatVoltPerDiv(v));

    function updateTimebaseDisplay(ms){
      const hasValue = typeof ms === 'number' && !Number.isNaN(ms);
      const label = hasValue ? formatTimebase(ms) : '— ms/div';
      if(scopeTimebasePill){
        scopeTimebasePill.textContent = label;
        scopeTimebasePill.classList.toggle('offline', scopeUsingFallback || scopeApiUnavailable || scopeConfigUnavailable);
      }
      if(scopeTimeLabel){
        scopeTimeLabel.textContent = hasValue ? label.replace('/div','') : '—';
      }
    }

    function updateVoltDisplay(v){
      const label = formatVoltPerDiv(v);
      if(scopeVoltageLabel){ scopeVoltageLabel.textContent = label; }
    }

    async function ensureScopeConfig(){
      if(scopeConfigUnavailable) return null;
      if(scopeConfigCache) return scopeConfigCache;
      try{
        const r = await j('/api/config?area=scope');
        if(!r.ok){
          if(r.status === 404){
            scopeConfigUnavailable = true;
            return null;
          }
          throw new Error('bad status');
        }
        const cfg = await r.json();
        scopeConfigCache = Object.assign({}, cfg || {});
        if(scopeConfigCache){
          updateScopeChannelMetadataFromConfig(scopeConfigCache);
        }
        return scopeConfigCache;
      }catch(err){
        console.warn(err);
        scopeConfigUnavailable = true;
        return null;
      }
    }

    async function saveScopeConfigPatch(patch){
      if(scopeConfigUnavailable) return false;
      const base = (await ensureScopeConfig()) || {};
      if(scopeConfigUnavailable) return false;
      const merged = Object.assign({}, base, patch);
      try{
        const r = await j('/api/config?area=scope',{method:'PUT', body: JSON.stringify(merged)});
        if(!r.ok){
          if(r.status === 404){
            scopeConfigUnavailable = true;
            return false;
          }
          throw new Error('bad status');
        }
        scopeConfigCache = merged;
        return true;
      }catch(err){
        console.warn(err);
        return false;
      }
    }

    function findClosestIndex(values, target){
      if(!values.length || typeof target !== 'number' || !isFinite(target)) return 0;
      let bestIdx = 0;
      let bestDiff = Math.abs(values[0]-target);
      for(let i=1;i<values.length;i++){
        const diff = Math.abs(values[i]-target);
        if(diff < bestDiff){
          bestDiff = diff;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    function getCurrentTimebase(){
      if(!scopeTimebaseSelect) return null;
      return parseFloat(scopeTimebaseSelect.value);
    }

    function getCurrentVoltPerDiv(){
      if(!scopeVoltSelect) return scopeVoltsPerDivValues[scopeVoltsPerDivValues.length-1];
      return parseFloat(scopeVoltSelect.value);
    }

    function getChannelOffsets(channel){
      if(!channel) return {horizontal:0, vertical:0};
      if(!scopeChannelOffsets[channel]){
        scopeChannelOffsets[channel] = {horizontal:0, vertical:0};
      }
      return scopeChannelOffsets[channel];
    }

    function clampOffset(value, limit){
      if(typeof value !== 'number' || Number.isNaN(value)) return 0;
      return Math.min(Math.max(value, -limit), limit);
    }

    function normalizeSampleValue(sample){
      if(typeof sample === 'number' && Number.isFinite(sample)) return sample;
      if(typeof sample === 'string'){
        const parsed = parseFloat(sample);
        return Number.isNaN(parsed) ? null : parsed;
      }
      if(sample && typeof sample === 'object'){
        if(typeof sample.value === 'number') return sample.value;
        if(typeof sample.voltage === 'number') return sample.voltage;
        if(typeof sample.v === 'number') return sample.v;
        if(typeof sample.y === 'number') return sample.y;
      }
      return null;
    }

    function toSampleArray(raw){
      if(Array.isArray(raw)) return raw;
      if(raw && typeof raw === 'object'){
        const candidates = ['samples','data','values','points'];
        for(const key of candidates){
          if(Array.isArray(raw[key])) return raw[key];
        }
        if(typeof raw[Symbol.iterator] === 'function'){
          try{ return Array.from(raw); }catch(e){ return []; }
        }
        const keys = Object.keys(raw);
        if(keys.length && keys.every(k=>/^\d+$/.test(k))){
          return keys.sort((a,b)=>Number(a)-Number(b)).map(k=>raw[k]);
        }
      }
      if(typeof raw === 'number' || typeof raw === 'string'){
        return [raw];
      }
      return [];
    }

    function normalizeSamples(raw){
      const src = toSampleArray(raw);
      const out = [];
      for(const entry of src){
        if(entry === null || entry === undefined) continue;
        if(Array.isArray(entry)){
          for(const nested of entry){
            const val = normalizeSampleValue(nested);
            if(val !== null) out.push(val);
          }
          continue;
        }
        const val = normalizeSampleValue(entry);
        if(val !== null) out.push(val);
      }
      return out;
    }

    function updateScopeDebugValue(value){
      if(!scopeDebugValue) return;
      if(typeof value === 'number' && Number.isFinite(value)){
        scopeDebugValue.textContent = `Valeur trace : ${formatVolt(value)}`;
        scopeDebugValue.classList.remove('empty');
      }else{
        scopeDebugValue.textContent = 'Valeur trace : —';
        scopeDebugValue.classList.add('empty');
      }
    }

    function plot(samples, color, voltsPerDiv, offsets){
      if(!scopeTracePath){ return null; }
      if(!samples || !samples.length){
        scopeTracePath.setAttribute('d','');
        updateScopeDebugValue(null);
        return null;
      }
      const width = scopeGridSize.width;
      const height = scopeGridSize.height;
      const verticalPixelsPerDiv = height / scopeDivisions.vertical;
      const horizontalPixelsPerDiv = width / scopeDivisions.horizontal;
      const clamp = (val, min, max)=>Math.min(Math.max(val, min), max);
      const len = samples.length;
      let min = samples[0];
      let max = samples[0];
      let sum = 0;
      let d = '';
      const horizontalOffset = offsets ? clampOffset(offsets.horizontal || 0, scopeOffsetLimits.horizontal) : 0;
      const verticalOffset = offsets ? clampOffset(offsets.vertical || 0, scopeOffsetLimits.vertical) : 0;
      const xShift = horizontalOffset * horizontalPixelsPerDiv;
      const yShift = verticalOffset * verticalPixelsPerDiv;
      if(len === 1){
        const v = samples[0];
        scopeTracePath.setAttribute('d','');
        updateScopeDebugValue(v);
        return {min: v, max: v, mean: v, voltsPerDiv, offsets: {horizontal: horizontalOffset, vertical: verticalOffset}};
      }
      for(let i=0;i<len;i++){
        const v = samples[i];
        if(v < min) min = v;
        if(v > max) max = v;
        sum += v;
        const x = (i/(len-1)) * width + xShift;
        const y = height/2 - (v/voltsPerDiv) * verticalPixelsPerDiv - yShift;
        const yClamped = clamp(y, 0, height);
        d += `${i === 0 ? 'M' : 'L'}${x.toFixed(2)},${yClamped.toFixed(2)} `;
      }
      scopeTracePath.setAttribute('d', d.trim());
      scopeTracePath.setAttribute('stroke', color || '#64ffda');
      updateScopeDebugValue(samples[samples.length-1]);
      return {min, max, mean: sum/len, voltsPerDiv, offsets: {horizontal: horizontalOffset, vertical: verticalOffset}};
    }

    function updateScopeDetails(meta, count){
      let lines = '—';
      if(meta){
        lines = [
          `Points : ${count}`,
          `Min : ${formatVolt(meta.min)}`,
          `Max : ${formatVolt(meta.max)}`,
          `Moyenne : ${formatVolt(meta.mean)}`,
          meta.voltsPerDiv ? `1 div = ${formatVolt(meta.voltsPerDiv)}` : null
        ].filter(Boolean).join('\n');
      }else if(count){
        lines = `Points : ${count}`;
      }
      if(scopeMeta){ scopeMeta.setAttribute('data-tooltip', lines || '—'); }

      const traceLines = meta ? [
        `Vpp : ${formatVolt(meta.max - meta.min)}`,
        meta.voltsPerDiv ? `Échelle : ${formatVolt(meta.voltsPerDiv, '/div')}` : null,
        meta.offsets ? `Offset H : ${meta.offsets.horizontal.toFixed(1)} div` : null,
        meta.offsets ? `Offset V : ${meta.offsets.vertical.toFixed(1)} div` : null
      ].filter(Boolean).join('\n') : '—';
      if(scopeTraceInfo){ scopeTraceInfo.setAttribute('data-tooltip', traceLines || '—'); }
    }

    async function applyScopeTimebase(ms){
      if(!scopeTimebaseSelect) return;
      updateTimebaseDisplay(ms);
      if(scopeApiUnavailable || scopeUsingFallback || scopeConfigUnavailable){
        scopeManualTimebase = ms;
        if(scopeTimebaseStatus){
          scopeTimebaseStatus.textContent = 'Réglage local (hors ligne).';
          setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 2000);
        }
        return;
      }
      scopeManualTimebase = null;
      if(scopeTimebaseStatus){ scopeTimebaseStatus.textContent = 'Envoi…'; }
      const patch = {
        timebase: ms,
        timebase_ms_per_div: ms,
        ms_per_div: ms
      };
      if(scopeSelectedChannel){
        patch.channel = scopeSelectedChannel;
      }
      const ok = await saveScopeConfigPatch(patch);
      if(!ok){
        if(scopeTimebaseStatus){
          scopeTimebaseStatus.textContent = scopeConfigUnavailable ? 'Mode hors ligne.' : 'Erreur de réglage.';
          setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 2000);
        }
        return;
      }
      if(scopeTimebaseStatus){
        scopeTimebaseStatus.textContent = 'Synchronisé';
        setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 1500);
      }
    }

    async function applyScopeVoltPerDiv(volts){
      if(!scopeVoltSelect) return;
      updateVoltDisplay(volts);
      if(scopeApiUnavailable || scopeUsingFallback || scopeConfigUnavailable){
        scopeManualVoltPerDiv = volts;
        if(scopeVoltStatus){
          scopeVoltStatus.textContent = 'Réglage local (hors ligne).';
          setTimeout(()=>{ if(scopeVoltStatus) scopeVoltStatus.textContent=''; }, 2000);
        }
        return;
      }
      scopeManualVoltPerDiv = null;
      if(scopeVoltStatus){ scopeVoltStatus.textContent = 'Envoi…'; }
      const patch = {
        volts_per_div: volts,
        vdiv: volts
      };
      if(scopeSelectedChannel){
        patch.channel = scopeSelectedChannel;
      }
      const ok = await saveScopeConfigPatch(patch);
      if(!ok){
        if(scopeVoltStatus){
          scopeVoltStatus.textContent = scopeConfigUnavailable ? 'Mode hors ligne.' : 'Erreur de réglage.';
          setTimeout(()=>{ if(scopeVoltStatus) scopeVoltStatus.textContent=''; }, 2000);
        }
        return;
      }
      if(scopeVoltStatus){
        scopeVoltStatus.textContent = 'Synchronisé';
        setTimeout(()=>{ if(scopeVoltStatus) scopeVoltStatus.textContent=''; }, 1500);
      }
    }

    function refreshScopeChannelBadge(){
      if(!scopeChannelBadge) return;
      const channel = scopeSelectedChannel;
      const label = getScopeChannelBaseLabel(channel);
      scopeChannelBadge.textContent = label;
      const color = channel ? (scopeChannelColors[channel] || scopeColorPalette[0]) : '';
      scopeChannelBadge.style.color = color || 'var(--text)';
      const tooltip = buildScopeChannelTooltip(channel);
      if(tooltip){
        scopeChannelBadge.setAttribute('title', tooltip);
      }else{
        scopeChannelBadge.removeAttribute('title');
      }
    }

    function renderScope(){
      const voltsPerDiv = getCurrentVoltPerDiv();
      updateVoltDisplay(voltsPerDiv);
      if(!scopeSelectedChannel){
        if(scopeTracePath){ scopeTracePath.setAttribute('d',''); }
        updateScopeDebugValue(null);
        updateScopeDetails(null, 0);
        return;
      }
      const color = scopeChannelColors[scopeSelectedChannel] || scopeColorPalette[0];
      const offsets = getChannelOffsets(scopeSelectedChannel);
      const meta = plot(scopeLatestSamples, color, voltsPerDiv, offsets);
      updateScopeDetails(meta, scopeLatestSamples ? scopeLatestSamples.length : 0);
    }

    function setScopeChannelList(channels){
      if(!scopeTraceChannelSelect) return;
      const previouslySelected = scopeSelectedChannel;
      scopeTraceChannelSelect.innerHTML = '';
      channels.forEach((name, idx)=>{
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = formatScopeChannelOptionLabel(name);
        const optionTooltip = buildScopeChannelTooltip(name);
        if(optionTooltip){
          opt.title = optionTooltip;
        }
        if(name === previouslySelected || (!previouslySelected && idx === 0)){
          opt.selected = true;
        }
        scopeTraceChannelSelect.appendChild(opt);
        if(!scopeChannelColors[name]){
          scopeChannelColors[name] = scopeColorPalette[idx % scopeColorPalette.length];
        }
        if(!scopeChannelOffsets[name]){
          scopeChannelOffsets[name] = {horizontal:0, vertical:0};
        }
      });
      if(!channels.includes(previouslySelected)){
        scopeSelectedChannel = channels[0] || null;
      }
      if(scopeTraceColor && scopeSelectedChannel){
        scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel];
      }
      const selectTooltip = buildScopeChannelTooltip(scopeSelectedChannel);
      if(selectTooltip){
        scopeTraceChannelSelect.title = selectTooltip;
      }else{
        scopeTraceChannelSelect.removeAttribute('title');
      }
      refreshScopeChannelBadge();
    }

    function openTraceModal(){
      if(!scopeTraceModal) return;
      scopeTraceModal.classList.remove('hidden');
      scopeTraceModal.setAttribute('aria-hidden','false');
      if(scopeTraceChannelSelect && scopeSelectedChannel){
        scopeTraceChannelSelect.value = scopeSelectedChannel;
      }
      if(scopeTraceColor && scopeSelectedChannel){
        scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel] || scopeTraceColor.value;
      }
      if(scopeTraceOffsetX && scopeTraceOffsetY){
        const offsets = getChannelOffsets(scopeSelectedChannel);
        scopeTraceOffsetX.value = offsets.horizontal.toFixed(1);
        scopeTraceOffsetY.value = offsets.vertical.toFixed(1);
      }
      const targetFocus = scopeTraceChannelSelect || scopeTraceModal.querySelector('input, select, button');
      if(targetFocus){
        setTimeout(()=>{ targetFocus.focus(); }, 0);
      }
    }

    function closeTraceModal(){
      if(!scopeTraceModal) return;
      if(scopeTraceModal.contains(document.activeElement)){
        if(scopeTraceOpen){
          scopeTraceOpen.focus();
        }else if(document.activeElement && typeof document.activeElement.blur === 'function'){
          document.activeElement.blur();
        }
      }
      scopeTraceModal.classList.add('hidden');
      scopeTraceModal.setAttribute('aria-hidden','true');
    }

    if(scopeTraceOpen){
      scopeTraceOpen.addEventListener('click', ()=>{
        openTraceModal();
      });
    }
    if(scopeTraceCancel){
      scopeTraceCancel.addEventListener('click', ()=>{
        closeTraceModal();
      });
    }
    if(scopeTraceModal){
      scopeTraceModal.addEventListener('click', (ev)=>{
        if(ev.target === scopeTraceModal){
          closeTraceModal();
        }
      });
    }
    function updateModalOffsetsForChannel(channel){
      if(scopeTraceOffsetX && scopeTraceOffsetY){
        const offsets = getChannelOffsets(channel);
        scopeTraceOffsetX.value = offsets.horizontal.toFixed(1);
        scopeTraceOffsetY.value = offsets.vertical.toFixed(1);
      }
    }

    if(scopeTraceChannelSelect && scopeTraceColor){
      scopeTraceChannelSelect.addEventListener('change', ()=>{
        const channel = scopeTraceChannelSelect.value;
        scopeTraceColor.value = scopeChannelColors[channel] || scopeColorPalette[0];
        updateModalOffsetsForChannel(channel);
        const tooltip = buildScopeChannelTooltip(channel);
        if(tooltip){
          scopeTraceChannelSelect.title = tooltip;
        }else{
          scopeTraceChannelSelect.removeAttribute('title');
        }
      });
    }
    document.addEventListener('keydown', (ev)=>{
      if(ev.key === 'Escape' && scopeTraceModal && !scopeTraceModal.classList.contains('hidden')){
        closeTraceModal();
      }
    });
    if(scopeTraceForm){
      scopeTraceForm.addEventListener('submit', (ev)=>{
        ev.preventDefault();
        const channel = scopeTraceChannelSelect ? scopeTraceChannelSelect.value : null;
        const color = scopeTraceColor ? scopeTraceColor.value : '#64ffda';
        const offsets = {
          horizontal: scopeTraceOffsetX ? clampOffset(parseFloat(scopeTraceOffsetX.value), scopeOffsetLimits.horizontal) : 0,
          vertical: scopeTraceOffsetY ? clampOffset(parseFloat(scopeTraceOffsetY.value), scopeOffsetLimits.vertical) : 0
        };
        if(channel){
          scopeSelectedChannel = channel;
          scopeChannelColors[channel] = color;
          scopeChannelOffsets[channel] = offsets;
          scopeLatestSamples = scopeChannelsData[channel] || [];
          refreshScopeChannelBadge();
          renderScope();
          const selectTooltip = buildScopeChannelTooltip(channel);
          if(scopeTraceChannelSelect){
            if(selectTooltip){
              scopeTraceChannelSelect.title = selectTooltip;
            }else{
              scopeTraceChannelSelect.removeAttribute('title');
            }
          }
          if(scopeTraceStatus){
            const label = formatScopeChannelOptionLabel(channel);
            scopeTraceStatus.textContent = `Trace sur ${label}`;
            setTimeout(()=>{ if(scopeTraceStatus) scopeTraceStatus.textContent=''; }, 1800);
          }
        }
        closeTraceModal();
      });
    }
    if(scopeTraceColor){
      scopeTraceColor.addEventListener('input', ()=>{
        if(scopeTraceChannelSelect){
          const channel = scopeTraceChannelSelect.value;
          scopeChannelColors[channel] = scopeTraceColor.value;
          if(scopeSelectedChannel === channel){
            refreshScopeChannelBadge();
            renderScope();
          }
        }
      });
    }

    if(scopeTraceOffsetX){
      scopeTraceOffsetX.addEventListener('input', ()=>{
        if(!scopeTraceChannelSelect) return;
        const channel = scopeTraceChannelSelect.value;
        const offsets = getChannelOffsets(channel);
        offsets.horizontal = clampOffset(parseFloat(scopeTraceOffsetX.value), scopeOffsetLimits.horizontal);
        scopeTraceOffsetX.value = offsets.horizontal.toFixed(1);
        if(scopeSelectedChannel === channel){
          renderScope();
        }
      });
    }
    if(scopeTraceOffsetY){
      scopeTraceOffsetY.addEventListener('input', ()=>{
        if(!scopeTraceChannelSelect) return;
        const channel = scopeTraceChannelSelect.value;
        const offsets = getChannelOffsets(channel);
        offsets.vertical = clampOffset(parseFloat(scopeTraceOffsetY.value), scopeOffsetLimits.vertical);
        scopeTraceOffsetY.value = offsets.vertical.toFixed(1);
        if(scopeSelectedChannel === channel){
          renderScope();
        }
      });
    }

    if(scopeTimebaseSelect){
      scopeTimebaseSelect.addEventListener('change', ()=>{
        const ms = getCurrentTimebase();
        applyScopeTimebase(ms);
        updateTimebaseDisplay(ms);
      });
      scopeTimebaseSelect.value = String(scopeTimebaseValues[6]);
      updateTimebaseDisplay(getCurrentTimebase());
    }

    if(scopeVoltSelect){
      scopeVoltSelect.addEventListener('change', ()=>{
        const volts = getCurrentVoltPerDiv();
        applyScopeVoltPerDiv(volts);
        renderScope();
      });
      scopeVoltSelect.value = String(scopeVoltsPerDivValues[5]);
      updateVoltDisplay(getCurrentVoltPerDiv());
    }

    async function loadScopeFallback(){
      try{
        if(scopeFallbackCache){
          return {
            channels: Object.fromEntries(Object.entries(scopeFallbackCache.channels).map(([name, entry])=>{
              if(Array.isArray(entry)){
                return [name, Array.from(entry)];
              }
              if(entry && typeof entry === 'object'){
                const copy = Object.assign({}, entry);
                if(Array.isArray(copy.samples)){
                  copy.samples = Array.from(copy.samples);
                }
                return [name, copy];
              }
              return [name, entry];
            })),
            timebase_ms_per_div: scopeFallbackCache.timebase_ms_per_div,
            volts_per_div: scopeFallbackCache.volts_per_div
          };
        }
        const r = await fetch('scope.json', {cache: 'no-cache'});
        if(!r.ok) return null;
        const cfg = await r.json();
        if(cfg && typeof cfg === 'object'){
          updateScopeChannelMetadataFromConfig(cfg);
        }
        const channels = {};
        const registerEntry = (name, entry)=>{
          if(!name) return;
          if(entry && typeof entry === 'object' && !Array.isArray(entry)){
            const meta = extractScopeChannelMetaFromRaw(entry, name);
            if(meta){
              mergeScopeChannelMeta(name, meta);
            }
            const normalized = normalizeSamples(entry);
            channels[name] = Object.assign({}, entry, {samples: normalized});
          }else{
            const normalized = normalizeSamples(entry);
            channels[name] = normalized.length ? normalized : new Array(200).fill(0);
          }
        };
        if(cfg && Array.isArray(cfg.channels)){
          cfg.channels.forEach((entry, idx)=>{
            const channelName = entry && typeof entry === 'object' && typeof entry.channel === 'string' && entry.channel.trim()
              ? entry.channel.trim()
              : (entry && typeof entry === 'object' && typeof entry.name === 'string' && entry.name.trim()
                ? entry.name.trim()
                : `CH${idx+1}`);
            registerEntry(channelName, entry);
          });
        }else if(cfg && cfg.channels && typeof cfg.channels === 'object'){
          Object.entries(cfg.channels).forEach(([name, entry])=>{
            registerEntry(name, entry);
          });
        }else{
          const channelName = cfg && typeof cfg === 'object' && typeof cfg.channel === 'string' && cfg.channel.trim()
            ? cfg.channel.trim()
            : 'CH1';
          const fallbackMeta = extractScopeChannelMetaFromRaw(cfg, channelName);
          if(fallbackMeta){
            mergeScopeChannelMeta(channelName, fallbackMeta);
          }
          const normalized = normalizeSamples(cfg && typeof cfg === 'object' ? cfg.samples : cfg);
          channels[channelName] = normalized.length ? normalized : new Array(200).fill(0);
        }
        const timebaseFromCfg = cfg && typeof cfg === 'object'
          ? (typeof cfg.timebase_ms_per_div === 'number' ? cfg.timebase_ms_per_div : (typeof cfg.timebase === 'number' ? cfg.timebase : null))
          : null;
        const voltsFromCfg = cfg && typeof cfg === 'object'
          ? (typeof cfg.volts_per_div === 'number' ? cfg.volts_per_div : (typeof cfg.vdiv === 'number' ? cfg.vdiv : null))
          : null;
        const result = {
          channels,
          timebase_ms_per_div: timebaseFromCfg,
          volts_per_div: voltsFromCfg,
        };
        scopeFallbackCache = {
          channels: Object.fromEntries(Object.entries(channels).map(([name, entry])=>{
            if(Array.isArray(entry)){
              return [name, Array.from(entry)];
            }
            if(entry && typeof entry === 'object'){
              const copy = Object.assign({}, entry);
              if(Array.isArray(copy.samples)){
                copy.samples = Array.from(copy.samples);
              }
              return [name, copy];
            }
            return [name, entry];
          })),
          timebase_ms_per_div: result.timebase_ms_per_div,
          volts_per_div: result.volts_per_div
        };
        return result;
      }catch(err){
        return null;
      }
    }

    function applyScopeData(data){
      if(!scopeUsingFallback && !scopeApiUnavailable){
        scopeManualVoltPerDiv = null;
        scopeManualTimebase = null;
      }

      const rawChannels = data.channels && typeof data.channels === 'object' ? data.channels : {};
      const normalizedChannels = {};
      Object.entries(rawChannels).forEach(([name, samples])=>{
        const metaFromEntry = extractScopeChannelMetaFromRaw(samples, name);
        if(metaFromEntry){
          mergeScopeChannelMeta(name, metaFromEntry);
        }
        normalizedChannels[name] = normalizeSamples(samples);
      });
      scopeLastScopeData = Object.assign({}, data, {channels: normalizedChannels});
      scopeChannelsData = scopeLastScopeData.channels;
      const chNames = Object.keys(scopeChannelsData);
      scopeChannelOffsets = chNames.reduce((acc, name)=>{
        acc[name] = scopeChannelOffsets[name] || {horizontal:0, vertical:0};
        return acc;
      }, {});
      if(chNames.length){
        setScopeChannelList(chNames);
        if(!scopeSelectedChannel){
          scopeSelectedChannel = chNames[0];
        }
        refreshScopeChannelBadge();
        scopeLatestSamples = scopeChannelsData[scopeSelectedChannel] || [];
        if(scopeTraceColor && scopeSelectedChannel){
          scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel];
        }
      }else{
        scopeSelectedChannel = null;
        scopeLatestSamples = [];
        refreshScopeChannelBadge();
      }

      const timebaseFromData = typeof data.timebase_ms_per_div === 'number' ? data.timebase_ms_per_div : null;
      const effectiveTimebase = scopeManualTimebase !== null ? scopeManualTimebase : timebaseFromData;
      if(scopeTimebaseSelect && effectiveTimebase !== null){
        const idx = findClosestIndex(scopeTimebaseValues, effectiveTimebase);
        scopeTimebaseSelect.value = String(scopeTimebaseValues[idx]);
      }
      updateTimebaseDisplay(effectiveTimebase);
      if(scopeTimebaseStatus){
        scopeTimebaseStatus.textContent = scopeTimebaseStatus.textContent === 'Synchronisé' ? scopeTimebaseStatus.textContent : '';
      }

      const voltsFromData = typeof data.volts_per_div === 'number' ? data.volts_per_div : null;
      const effectiveVolts = scopeManualVoltPerDiv !== null ? scopeManualVoltPerDiv : voltsFromData;
      if(scopeVoltSelect && effectiveVolts !== null){
        const idx = findClosestIndex(scopeVoltsPerDivValues, effectiveVolts);
        scopeVoltSelect.value = String(scopeVoltsPerDivValues[idx]);
      }
      if(effectiveVolts !== null){
        updateVoltDisplay(effectiveVolts);
      }else{
        updateVoltDisplay(getCurrentVoltPerDiv());
      }

      if(!scopeConfigUnavailable){
        const configFromScope = Object.assign({}, scopeConfigCache || {});
        if(effectiveTimebase !== null){
          configFromScope.timebase = effectiveTimebase;
          configFromScope.timebase_ms_per_div = effectiveTimebase;
          configFromScope.ms_per_div = effectiveTimebase;
        }
        if(effectiveVolts !== null){
          configFromScope.volts_per_div = effectiveVolts;
          configFromScope.vdiv = effectiveVolts;
        }
        if(scopeSelectedChannel){
          configFromScope.channel = scopeSelectedChannel;
        }
        scopeConfigCache = configFromScope;
      }

      renderScope();
    }

    async function loadScope(){
      const now = Date.now();
      const shouldTryApi = !scopeApiUnavailable && (!scopeUsingFallback || now >= scopeNextScopeApiRetry);
      let data = null;

      if(shouldTryApi){
        try{
          const r = await j('/api/scope');
          if(!r.ok){
            if(r.status === 404){
              scopeApiUnavailable = true;
              scopeUsingFallback = true;
              scopeNextScopeApiRetry = Number.POSITIVE_INFINITY;
            }else{
              scopeUsingFallback = true;
              scopeNextScopeApiRetry = Date.now() + 5000;
            }
          }else{
            data = await r.json();
            scopeUsingFallback = false;
            scopeFallbackCache = null;
            scopeApiUnavailable = false;
          }
        }catch(e){
          console.warn(e);
          scopeUsingFallback = true;
          if(!scopeApiUnavailable){
            scopeNextScopeApiRetry = Date.now() + 5000;
          }
        }
      }

      if(!data){
        if(scopeUsingFallback && scopeLastScopeData){
          applyScopeData(scopeLastScopeData);
          return;
        }
        const fallback = await loadScopeFallback();
        if(fallback){
          data = fallback;
          scopeUsingFallback = true;
          scopeNextScopeApiRetry = Date.now() + 5000;
        }else{
          scopeSelectedChannel = null;
          scopeLatestSamples = [];
          scopeChannelsData = {};
          scopeLastScopeData = null;
          scopeUsingFallback = false;
          scopeChannelOffsets = {};
          refreshScopeChannelBadge();
          updateScopeDetails(null, 0);
          updateTimebaseDisplay(null);
          return;
        }
      }

      applyScopeData(data);
    }
    /* --------- MATH EDITOR --------- */
    async function loadMath(){
      try{
        const r = await j('/api/config?area=math');
        if(r.ok){
          const cfg = await r.json();
          const expressions = cfg && Array.isArray(cfg.expressions) ? cfg.expressions : [];
          const expr = expressions.length ? expressions.join('\n') : '';
          $('#math-text').value = expr;
          $('#math-status').textContent='Config chargée.';
          return;
        }
      }catch(e){
        console.warn(e);
      }
      try{
        const fallback = await fetch('math.json',{cache:'no-cache'});
        if(fallback.ok){
          const cfg = await fallback.json();
          const expressions = Array.isArray(cfg)
            ? cfg
            : (cfg && Array.isArray(cfg.expressions) ? cfg.expressions : []);
          const expr = expressions.length ? expressions.join('\n') : '';
          $('#math-text').value = expr;
          $('#math-status').textContent='Config locale chargée.';
          return;
        }
      }catch(e){
        console.warn(e);
      }
      $('#math-status').textContent='Impossible de charger la config.';
    }
    async function saveMath(){
      const lines = $('#math-text').value.split('\n').map(s=>s.trim()).filter(Boolean);
      const body = JSON.stringify({expressions: lines});
      try{
        const r = await j('/api/config?area=math',{method:'PUT', body});
        $('#math-status').textContent = r.ok ? 'Enregistré.' : 'Erreur d’enregistrement.';
      }catch(e){
        console.warn(e);
        $('#math-status').textContent='Erreur réseau.';
      }
    }
    $('#math-load').addEventListener('click', loadMath);
    $('#math-save').addEventListener('click', saveMath);

    /* --------- Boot --------- */
    async function boot(){
      await loadDmmConfig();
      await loadDmm();
      loadIOForFunc();
      loadMath();
      await ensureScopeConfig();
      loadScope();
      setInterval(()=>{ loadDmm(); }, 2000);   // DMM 2 Hz
      setInterval(()=>{ loadScope(); }, 150);  // Scope ~6-7 fps (léger)
    }
    document.addEventListener('DOMContentLoaded', ()=>{ boot(); });
  </script>
</body>
</html>
