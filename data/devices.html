<!DOCTYPE html>
<html lang="fr">
<!--
  devices.html

  Cette page regroupe les quatre appareils principaux du MiniLabo dans
  une interface unique composée de quatre cadrans : multimètre,
  générateur de fonctions, oscilloscope et éditeur d’équations
  mathématiques.  Elle est destinée à servir d’écran de contrôle
  « console » rappelant un banc de mesures complet.  Chaque cadran
  fonctionne indépendamment : le multimètre lit les valeurs exposées
  par l’API DMM, le générateur permet d’ajuster amplitude, offset,
  fréquence et forme sur une sortie, l’oscilloscope trace un canal en
  direct et l’éditeur math gère des formules créant des IO
  dérivées.

  TODO:
  – Brancher chaque cadran sur les appels API correspondants.  Voir
    les fonctions loadDmm(), loadIOForFunc(), loadScope() et
    loadMath() plus bas pour des squelettes d’implémentation.  Ces
    fonctions interrogent respectivement /api/dmm, /api/io,
    /api/scope et /api/config?area=math.
  – Gérer les modes d’affichage du multimètre (binaire et cadran
    analogique) : seuls les chiffres sont affichés pour l’instant.
  – Implémenter la mise à jour en temps réel de l’oscilloscope selon
    la base de temps et l’échelle verticale définies dans
    scope.json.  Actuellement un auto‑scale basique est utilisé.
  – Ajouter un panneau de logs ou de messages de statut si
    nécessaire.
  – Cette page n’est pas liée par défaut dans index.html ; ajoutez
    simplement un lien vers devices.html si vous souhaitez
    l’utiliser comme tableau de bord.
-->
<head>
  <meta charset="utf-8" />
  <title>MiniLabo — Console 4 cadrans</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0c0f14;
      --panel:#121722;
      --panel-2:#0f141d;
      --bezel:#1a2230;
      --accent:#36d399;
      --accent-2:#4cc3ff;
      --warn:#ffb86b;
      --danger:#ff6b6b;
      --text:#e5e7eb;
      --sub:#98a2b3;
      --grid:#1f2a3a;
      --grid-sub:#162030;
      --shadow: 0 10px 25px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
      background: radial-gradient(1200px 800px at 70% -200px, #111827 0%, #0b0e13 60%, #090c11 100%);
      color:var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 20px; border-bottom:1px solid #1f2937;
      background:linear-gradient(180deg,#101522 0%, #0e1220 100%);
      position:sticky; top:0; z-index:10;
    }
    header h1{margin:0; font-size:18px; letter-spacing:.3px; font-weight:600}
    header .led{
      width:10px;height:10px;border-radius:50%;
      box-shadow:0 0 12px rgba(54,211,153,.55), inset 0 0 4px rgba(0,0,0,.6);
      background:radial-gradient(circle at 30% 30%, #7fffbf, #11a86e);
      margin-right:8px; display:inline-block; vertical-align:middle;
    }
    .wrap{
      padding:18px; max-width:1400px; margin:0 auto;
    }
    .grid{
      display:grid; gap:18px;
      grid-template-columns: repeat(2, minmax(300px, 1fr));
      grid-auto-rows: minmax(320px, 1fr);
    }
    .card{
      background: linear-gradient(145deg, var(--panel) 0%, var(--panel-2) 100%);
      border:1px solid #1b2636;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative; overflow:hidden;
    }
    .bezel{
      position:absolute; inset:0; pointer-events:none;
      border-radius: var(--radius);
      box-shadow: inset 0 0 0 2px #0c121b, inset 0 0 0 3px #1e293b, inset 0 0 60px rgba(0,0,0,.35);
    }
    .screw{
      position:absolute; width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #a3b2c7, #6d7b91 60%, #425067);
      box-shadow: inset 0 0 2px rgba(0,0,0,.6); opacity:.65;
    }
    .screw::after{
      content:""; position:absolute; inset:3px 1px 3px 1px; background:#0f1420; transform:rotate(90deg);
      clip-path: polygon(0 45%,100% 45%,100% 55%,0 55%);
      opacity:.85;
    }
    .screw.tl{top:8px; left:10px}
    .screw.tr{top:8px; right:10px}
    .screw.bl{bottom:8px; left:10px}
    .screw.br{bottom:8px; right:10px}

    .card h2{
      margin:0; padding:12px 14px; font-size:14px; letter-spacing:.35px; font-weight:600;
      border-bottom:1px solid #1b2636;
      background: linear-gradient(180deg,#0f1522,#0c111c);
      display:flex; align-items:center; gap:10px;
    }
    .pill{display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; color:#0b1220; background:#b9f6da}
    .pill.blue{background:#bfe7ff}
    .content{padding:14px; display:grid; grid-template-columns: 1.2fr .8fr; gap:14px; height:calc(100% - 52px)}
    .content.dmm-vertical{display:flex; flex-direction:column; height:calc(100% - 52px)}
    .content.dmm-vertical .dmm-display{flex:3 1 0; min-height:0; width:100%}
    .content.dmm-vertical .dmm-controls{flex:1 1 0; margin-top:14px; width:100%}
    .content.single{grid-template-columns: 1fr}

    /* DMM styles */
    .dmm-display{
      background: radial-gradient(600px 200px at 50% -10%, #0c111b 0%, #0c111b 60%, #0a0f18 100%);
      border:1px solid #1a2332; border-radius:12px; padding:12px 14px; min-height:220px;
      display:flex; justify-content:center; align-items:center; position:relative; overflow:hidden;
      text-shadow: 0 0 6px rgba(54,211,153,0.2);
    }
    .dmm-view{display:none; flex-direction:column; align-items:center; justify-content:center; gap:12px; width:100%; height:100%; text-align:center}
    .dmm-view.active{display:flex}
    .digits{
      display:flex; align-items:flex-end; gap:12px;
    }
    .digits span{
      background: linear-gradient(180deg, #c7ffe7 0%, #7ef1c6 40%, #3bd098 60%, #1aaa73 100%);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      filter: drop-shadow(0 5px 12px rgba(54, 211, 153, .18));
      display:inline-flex; align-items:flex-end;
    }
    .digits-value{
      font-variant-numeric: tabular-nums;
      font-size:56px; line-height:1; font-weight:700; letter-spacing:1px;
    }
    .digits-unit{
      font-size:28px; font-weight:600; letter-spacing:1.2px; text-transform:uppercase; padding-bottom:6px;
    }
    .dmm-meta{font-size:12px; color:var(--sub)}
    .binary-readout{display:flex; flex-direction:column; gap:4px; align-items:center; font-size:12px; color:var(--sub)}
    .binary-value{font-size:32px; font-weight:600; letter-spacing:1px; color:#7ef1c6}
    .binary-caption{text-transform:uppercase; letter-spacing:.2em; font-size:10px; color:#637186}
    .binary-grid{display:flex; flex-wrap:wrap; gap:6px; justify-content:center; width:100%; max-width:320px}
    .binary-empty{flex:1 0 100%; font-size:12px; color:#5f6b7c; letter-spacing:.05em; text-transform:uppercase; text-align:center}
    .binary-cell{display:flex; align-items:center; justify-content:center}
    .binary-bit{padding:6px 10px; border-radius:6px; background:#0b1623; border:1px solid #1f2a3a; font-size:14px; font-weight:600; color:#c7d2e2; box-shadow: inset 0 1px 0 rgba(255,255,255,.05); text-align:center}
    .binary-bit.on{background:linear-gradient(180deg, rgba(126,241,198,.35) 0%, rgba(59,208,152,.35) 100%); color:#bff6dd; border-color:#2c4a3b}
    .binary-meta{font-size:11px; color:#8793a3; text-align:center}
    .gauge{width:100%; max-width:260px}
    #dmm-gauge-svg{width:100%; height:auto}
    .gauge-arc{fill:none; stroke:#1f2b3d; stroke-width:10; stroke-linecap:round}
    .gauge-needle{stroke:#4cc3ff; stroke-width:4; stroke-linecap:round; filter:drop-shadow(0 0 6px rgba(76,195,255,.6))}
    .gauge-hub{fill:#0b1220; stroke:#4cc3ff; stroke-width:2}
    .gauge-tick{stroke:#2a3546; stroke-width:2; stroke-linecap:round}
    .gauge-tick.minor{stroke-width:1; stroke:#1a2434}
    .gauge-label{fill:#7c8b9f; font-size:10px; font-weight:500; text-shadow:none}
    .gauge-readout{display:flex; align-items:baseline; gap:6px; font-variant-numeric: tabular-nums}
    .gauge-value{font-size:32px; font-weight:600; color:#7ef1c6}
    .gauge-unit{font-size:16px; font-weight:600; color:#bfe7ff}
    .dmm-controls{display:flex; flex-direction:column; gap:12px; height:100%}
    .dmm-controls .control-line{display:flex; gap:18px; align-items:stretch; height:100%}
    .dmm-controls .control-group{display:flex; flex-direction:column}
    .dmm-controls .control-group.channel{flex:0 0 25%; max-width:25%}
    .dmm-controls .control-group.display{flex:1 1 0}
    .dmm-controls label,
    .dmm-controls .control-label{display:block; font-size:12px; color:#b5c0cd; margin-bottom:6px}
    .info-label{position:relative; display:inline-flex; align-items:center; gap:6px; cursor:help}
    .info-icon{width:16px; height:16px; border-radius:50%; background:#1f2b3d; color:#bfe7ff; font-size:10px; font-weight:600; display:inline-flex; align-items:center; justify-content:center; box-shadow:0 0 0 1px rgba(79,89,110,.45)}
    .info-label::after{content:attr(data-tooltip); position:absolute; left:0; bottom:calc(100% + 10px); background:#0d1420; color:#d1d8e5; padding:8px 10px; border-radius:8px; border:1px solid #1f2b3d; box-shadow:0 12px 24px rgba(0,0,0,.45); width:220px; max-width:260px; opacity:0; transform:translateY(6px); pointer-events:none; transition:opacity .2s ease, transform .2s ease; line-height:1.4; white-space:pre-line}
    .info-label:hover::after,
    .info-label:focus-visible::after{opacity:1; transform:translateY(0)}
    .info-label:focus-visible{outline:2px solid rgba(76,195,255,.6); outline-offset:4px}
    .mode-row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .mode-buttons{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .mode-row>.btn.warn{margin-left:auto}
    .mode-buttons .btn-hold{padding:7px 10px; font-size:12px; white-space:nowrap}
    @media (max-width: 720px){
      .dmm-controls .control-line{flex-direction:column}
      .dmm-controls .control-group.channel{flex:1 1 100%; max-width:none}
      .dmm-controls .control-group.display{flex:1 1 100%}
      .mode-row{justify-content:flex-start}
      .mode-row>.btn.warn{margin-left:0}
    }

    .dmm-controls label{display:block; font-size:12px; color:#b5c0cd; margin:8px 0 4px}
    .select, input[type="number"], input[type="text"]{
      width:100%; padding:8px 10px; background:#0c121b; color:var(--text);
      border:1px solid #223044; border-radius:8px; outline:none;
    }
    .btn{
      appearance:none; border:1px solid #1f2b3d; background:linear-gradient(180deg,#1a2434,#121b27);
      color:var(--text); padding:9px 12px; border-radius:10px; cursor:pointer;
      box-shadow:0 6px 14px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .btn.primary{ border-color:#1f3b2f; background:linear-gradient(180deg,#1f3b2f,#15281f); color:#bff6dd}
    .btn.warn{ border-color:#3b2f1f; background:linear-gradient(180deg,#3b2f1f,#2a2117); color:#ffd7a7}
    .btn.active{border-color:#2f4b66; background:linear-gradient(180deg,#1d2738,#162131); box-shadow:0 0 0 1px rgba(76,195,255,.2), inset 0 1px 0 rgba(255,255,255,.08)}
    .row{display:flex; gap:10px}
    .row>*{flex:1}
    .row.compact>*{flex:0 0 auto}
    .row.compact .grow{flex:1 1 auto}
    .badge{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #334155; color:#cbd5e1; background:#0b1220; display:inline-block}

    /* Generator */
    .knob{
      display:flex; flex-direction:column; gap:6px; align-items:stretch;
      background:#0c121b; border:1px solid #1a2332; border-radius:10px; padding:10px;
    }
    input[type="range"]{ width:100% }
    input[type="range"]{
      -webkit-appearance:none; height:6px; background: #152030; border-radius:999px; outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; width:18px; height:18px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe7ff, #4ba8e6);
      box-shadow: 0 0 0 2px #0b1220, 0 8px 16px rgba(0,0,0,.5);
      border:1px solid #1e3a5f;
    }

    /* Scope */
    .scope-wrap{
      background:#050910;
      border:1px solid #162235;
      border-radius:12px;
      overflow:hidden;
      position:relative;
      display:flex;
    }
    .scope-body{display:flex; width:100%; min-height:230px}
    .scope-screen{flex:1 1 auto; position:relative; min-height:220px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding:14px; gap:12px}
    .scope-display{width:100%; max-width:520px}
    #scope-display{width:100%; height:auto; display:block}
    #scope-display .scope-grid rect{fill:#050910; stroke:#1b2d42; stroke-width:2}
    #scope-display .grid-lines{stroke:#1b2d42; stroke-width:1.5; fill:none}
    #scope-display .sub-division{stroke:#0c1521; stroke-width:1; fill:none}
    #scope-display .scope-axis{stroke:#2e4c68; stroke-width:2}
    #scope-display .reference-line{stroke:#ff6b6b; stroke-width:1.2; stroke-dasharray:6 4}
    #scope-display .reference-label{fill:#9fb5c9; font-size:12px; font-family:inherit}
    #scope-display .scope-legend text{fill:#9fb5c9; font-size:13px; font-family:inherit}
    .scope-popups{position:absolute; inset:0; pointer-events:none}
    .scope-popup{position:absolute; pointer-events:auto}
    .scope-popup.info-label{background:rgba(10,18,28,.85); border-radius:999px; padding:4px 10px; font-size:11px; color:#9fb5c9; border:1px solid rgba(60,97,132,.5); box-shadow:0 6px 18px rgba(0,0,0,.35)}
    #scope-ref-popup{top:14px; left:18px}
    #scope-scale-popup{bottom:18px; left:18px}
    #scope-zero-popup{top:50%; left:18px; transform:translateY(-50%)}
    .scope-controls{
      flex:0 0 200px;
      border-left:1px solid #162235;
      background:linear-gradient(180deg,#060b14 0%, #050910 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:22px;
      padding:20px 16px;
    }
    .scope-control{display:flex; flex-direction:column; align-items:center; gap:12px; width:100%}
    .scope-control .control-label{font-size:11px; text-transform:uppercase; letter-spacing:.1em; color:#8fa3b9; text-align:center}
    .scope-control select{
      width:100%;
      background:#0c1521;
      border:1px solid #1b2a3c;
      border-radius:8px;
      color:#d1e3f0;
      padding:8px 10px;
      font-size:13px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 8px 18px rgba(0,0,0,.3);
    }
    .scope-trace-button{
      width:100%;
      padding:10px;
      border-radius:8px;
      background:linear-gradient(180deg,#14263a 0%, #0d1725 100%);
      border:1px solid #1e2f44;
      color:#9be7ff;
      font-size:13px;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
      transition:transform .15s ease, box-shadow .15s ease;
    }
    .scope-trace-button:hover{transform:translateY(-1px); box-shadow:0 10px 22px rgba(0,0,0,.4);}
    .scope-trace-button:active{transform:translateY(0); box-shadow:0 4px 12px rgba(0,0,0,.35);}
    .scope-control-status{font-size:11px; text-align:center; color:#6e7d90; min-height:14px}

    .scope-modal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(3,7,13,.6); z-index:200; padding:20px}
    .scope-modal.hidden{display:none}
    .scope-modal-dialog{
      background:linear-gradient(180deg,#0f1726 0%, #0b101a 100%);
      border:1px solid #1e2a3c;
      border-radius:12px;
      padding:20px;
      width:100%;
      max-width:360px;
      box-shadow:0 30px 60px rgba(0,0,0,.45);
      color:#e5e7eb;
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .scope-modal h3{margin:0; font-size:16px; font-weight:600; text-align:left}
    .scope-modal form{display:flex; flex-direction:column; gap:16px}
    .scope-modal label{display:flex; flex-direction:column; gap:6px; font-size:13px; color:#b3c0d1; text-transform:uppercase; letter-spacing:.08em}
    .scope-modal select, .scope-modal input[type="color"]{
      width:100%;
      padding:10px;
      border-radius:8px;
      border:1px solid #1e2f44;
      background:#0c1521;
      color:#e5e7eb;
      font-size:14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .scope-modal input[type="color"]{height:40px; padding:0; cursor:pointer}
    .scope-modal-actions{display:flex; justify-content:flex-end; gap:10px}

    /* Math editor */
    .math{
      display:grid; gap:10px; grid-template-columns: 1fr;
      height:100%;
      grid-template-rows: auto 1fr auto;
    }
    textarea{
      width:100%; height:160px; resize:vertical; min-height:120px;
      background:#0c121b; color:#e5e7eb; border:1px solid #1a2332; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .hint{font-size:12px; color:#a6b1bf}
    .list{
      border:1px dashed #203047; border-radius:10px; padding:10px; color:#cbd5e1; font-size:13px; background:#0a0f16;
    }

    /* Utils */
    .right{justify-content:flex-end}
    .muted{color:#9aa7b7}
    .unit{font-weight:600; color:#bfe7ff; margin-left:8px}
    .spacer{height:6px}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <header>
    <h1><span class="led"></span> MiniLabo — Console</h1>
    <div class="muted">Session PIN via cookie – Web en ligne</div>
  </header>

  <div class="wrap">
    <div class="grid">

      <!-- DMM -->
      <section class="card" id="card-dmm">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Multimètre <span class="badge" id="dmm-channel">CH1</span> <span class="pill" id="dmm-mode-pill">UDC</span></h2>
        <div class="content dmm-vertical">
          <div class="dmm-display">
            <div class="dmm-view active" data-view="digits">
              <div class="digits"><span class="digits-value" id="dmm-value">—.—</span><span class="digits-unit" id="dmm-unit-inline">V</span></div>
              <div class="spacer"></div>
              <div class="dmm-meta" id="dmm-meta">Entrée : — • Mode : — • Décimales : —</div>
            </div>
            <div class="dmm-view" data-view="binary">
              <div class="binary-readout">
                <div class="binary-value" id="dmm-binary-value">—</div>
                <div class="binary-caption">Valeur brute</div>
              </div>
              <div class="binary-grid" id="dmm-binary"></div>
              <div class="binary-meta" id="dmm-binary-meta"></div>
            </div>
            <div class="dmm-view" data-view="gauge">
              <div class="gauge" id="dmm-gauge">
                <svg id="dmm-gauge-svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
                  <path id="dmm-gauge-arc" class="gauge-arc" d="M20 160 A80 80 0 0 1 180 160" />
                  <g id="dmm-gauge-ticks"></g>
                  <line id="dmm-gauge-needle" class="gauge-needle" x1="100" y1="120" x2="100" y2="40" />
                  <circle class="gauge-hub" cx="100" cy="120" r="6" />
                </svg>
              </div>
            </div>
          </div>
          <div class="dmm-controls">
            <div class="control-line">
              <div class="control-group channel">
                <label for="dmm-select">Canal</label>
                <select id="dmm-select" class="select"></select>
              </div>
              <div class="control-group display">
                <div class="control-label info-label" data-tooltip="Le DMM est actualisé toutes les 2 s. Les décimales sont définies par la config du canal." tabindex="0">Affichage <span class="info-icon" aria-hidden="true">i</span></div>
                <div class="mode-row">
                  <div class="mode-buttons">
                    <button class="btn" data-mode="digits">Numérique</button>
                    <button class="btn" data-mode="binary">Binaire</button>
                    <button class="btn" data-mode="gauge">Cadran</button>
                    <button class="btn warn btn-hold" id="dmm-hold">Hold</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- FUNCGEN -->
      <section class="card" id="card-func">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Générateur de fonctions <span class="pill blue" id="func-target-pill">cible : —</span></h2>
        <div class="content">
          <div class="knob">
            <div class="row">
              <div>
                <label>Amplitude (%)</label>
                <input id="func-amp" type="range" min="0" max="100" value="50" />
              </div>
              <div>
                <label>Offset (%)</label>
                <input id="func-off" type="range" min="0" max="100" value="0" />
              </div>
            </div>
            <div class="row">
              <div>
                <label>Fréquence (Hz)</label>
                <input id="func-freq" type="number" min="0.1" step="0.1" value="50" />
              </div>
              <div>
                <label>Forme</label>
                <select id="func-wave" class="select">
                  <option value="sine">Sinus</option>
                  <option value="square">Carré</option>
                  <option value="triangle">Triangle</option>
                </select>
              </div>
            </div>
            <div class="row">
              <div>
                <label>Cible IO</label>
                <select id="func-target" class="select"></select>
              </div>
              <div class="right" style="display:flex; align-items:flex-end">
                <button class="btn primary" id="func-apply">Appliquer</button>
              </div>
            </div>
            <div class="hint">La sortie est appliquée en % de l’échelle de l’IO cible (DAC/0‑10 V).</div>
          </div>
          <div>
            <div class="list" id="func-status">Prêt.</div>
            <div class="spacer"></div>
            <div class="hint">Astuce : définis une amplitude puis ajoute un offset pour centrer ton signal.</div>
          </div>
        </div>
      </section>

      <!-- SCOPE -->
      <section class="card" id="card-scope">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Oscilloscope <span class="badge" id="scope-chan">CH1</span> <span class="pill blue" id="scope-timebase">— ms/div</span></h2>
        <div class="content single">
          <div class="scope-wrap">
            <div class="scope-body">
              <div class="scope-screen" id="scope-screen">
                <div class="scope-display" role="img" aria-label="Affichage oscilloscope">
                  <svg id="scope-display" viewBox="0 0 500 528" xmlns="http://www.w3.org/2000/svg">
                    <g class="scope-grid">
                      <rect x="0" y="0" width="500" height="500"></rect>
                      <path class="grid-lines" d="M0,0 V500 M50,0 V500 M100,0 V500 M150,0 V500 M200,0 V500 M250,0 V500 M300,0 V500 M350,0 V500 M400,0 V500 M450,0 V500 M500,0 V500 M0,0 H500 M0,50 H500 M0,100 H500 M0,150 H500 M0,200 H500 M0,250 H500 M0,300 H500 M0,350 H500 M0,400 H500 M0,450 H500 M0,500 H500"></path>
                      <line class="scope-axis" x1="0" y1="250" x2="500" y2="250"></line>
                      <line class="scope-axis" x1="250" y1="0" x2="250" y2="500"></line>
                      <path class="sub-division" d="M0,245 V255 M10,245 V255 M20,245 V255 M30,245 V255 M40,245 V255 M50,245 V255 M60,245 V255 M70,245 V255 M80,245 V255 M90,245 V255 M100,245 V255 M110,245 V255 M120,245 V255 M130,245 V255 M140,245 V255 M150,245 V255 M160,245 V255 M170,245 V255 M180,245 V255 M190,245 V255 M200,245 V255 M210,245 V255 M220,245 V255 M230,245 V255 M240,245 V255 M250,245 V255 M260,245 V255 M270,245 V255 M280,245 V255 M290,245 V255 M300,245 V255 M310,245 V255 M320,245 V255 M330,245 V255 M340,245 V255 M350,245 V255 M360,245 V255 M370,245 V255 M380,245 V255 M390,245 V255 M400,245 V255 M410,245 V255 M420,245 V255 M430,245 V255 M440,245 V255 M450,245 V255 M460,245 V255 M470,245 V255 M480,245 V255 M490,245 V255 M500,245 V255 M245,0 H255 M245,10 H255 M245,20 H255 M245,30 H255 M245,40 H255 M245,50 H255 M245,60 H255 M245,70 H255 M245,80 H255 M245,90 H255 M245,100 H255 M245,110 H255 M245,120 H255 M245,130 H255 M245,140 H255 M245,150 H255 M245,160 H255 M245,170 H255 M245,180 H255 M245,190 H255 M245,200 H255 M245,210 H255 M245,220 H255 M245,230 H255 M245,240 H255 M245,250 H255 M245,260 H255 M245,270 H255 M245,280 H255 M245,290 H255 M245,300 H255 M245,310 H255 M245,320 H255 M245,330 H255 M245,340 H255 M245,350 H255 M245,360 H255 M245,370 H255 M245,380 H255 M245,390 H255 M245,400 H255 M245,410 H255 M245,420 H255 M245,430 H255 M245,440 H255 M245,450 H255 M245,460 H255 M245,470 H255 M245,480 H255 M245,490 H255 M245,500 H255"></path>
                      <line class="reference-line" x1="0" y1="250" x2="500" y2="250"></line>
                      <text class="reference-label" x="6" y="244">0 V (réf.)</text>
                    </g>
                    <g id="scope-traces">
                      <path id="scope-trace-path" fill="none" stroke="#64ffda" stroke-width="2"></path>
                    </g>
                    <g class="scope-legend">
                      <text x="10" y="522" id="scope-voltage-scale">—</text>
                      <text x="300" y="522" id="scope-time-scale">—</text>
                    </g>
                  </svg>
                </div>
                <div class="scope-popups">
                  <div class="scope-popup info-label" id="scope-ref-popup" data-tooltip="0 V (réf. lecture)" tabindex="0">Réf 0 V <span class="info-icon" aria-hidden="true">i</span></div>
                  <div class="scope-popup info-label" id="scope-zero-popup" data-tooltip="Ligne 0 V, utilisez l’offset pour centrer le signal." tabindex="0">0 V <span class="info-icon" aria-hidden="true">i</span></div>
                  <div class="scope-popup info-label" id="scope-scale-popup" data-tooltip="—" tabindex="0">Échelle <span class="info-icon" aria-hidden="true">i</span></div>
                </div>
              </div>
              <div class="scope-controls">
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Ajuste la durée affichée pour une division horizontale." tabindex="0">Base de temps <span class="info-icon" aria-hidden="true">i</span></div>
                  <select id="scope-timebase-select" aria-label="Base de temps (ms par division)"></select>
                  <div class="scope-control-status" id="scope-timebase-status" aria-live="polite"></div>
                </div>
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Sélectionne la tension représentée par une division verticale." tabindex="0">Échelle verticale <span class="info-icon" aria-hidden="true">i</span></div>
                  <select id="scope-volt-select" aria-label="Échelle verticale (volts par division)"></select>
                  <div class="scope-control-status" id="scope-volt-status" aria-live="polite"></div>
                </div>
                <div class="scope-control">
                  <div class="control-label info-label" data-tooltip="Choix du canal affiché et de sa couleur." tabindex="0">Trace <span class="info-icon" aria-hidden="true">i</span></div>
                  <button type="button" class="scope-trace-button" id="scope-trace-open">Configurer…</button>
                  <div class="scope-control-status" id="scope-trace-status" aria-live="polite"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- MATH EDITOR -->
      <section class="card" id="card-math">
        <div class="bezel"></div>
        <span class="screw tl"></span><span class="screw tr"></span><span class="screw bl"></span><span class="screw br"></span>
        <h2>Éditeur d’équations (IO math)</h2>
        <div class="content single">
          <div class="math">
            <div class="hint">Une équation par ligne → <code>io_out = (io_a0 * 3.3) + 0.1</code> • Variables = noms d’IO logiques • Fonctions autorisées basiques ( + − × ÷, abs, min, max ).</div>
            <textarea id="math-text" spellcheck="false" placeholder="ex: v_div = IO_A0 * 3.3&#10;v_out = v_div * 0.5"></textarea>
            <div class="row">
              <button class="btn" id="math-load">Charger</button>
              <button class="btn primary" id="math-save">Enregistrer</button>
            </div>
            <div class="list" id="math-status">Prêt.</div>
          </div>
        </div>
      </section>

    </div>
  </div>
  
  <div class="scope-modal hidden" id="scope-trace-modal" aria-hidden="true">
    <div class="scope-modal-dialog" role="dialog" aria-modal="true" aria-labelledby="scope-trace-title">
      <h3 id="scope-trace-title">Configurer la trace</h3>
      <form id="scope-trace-form">
        <label for="scope-trace-channel">Canal</label>
        <select id="scope-trace-channel" required></select>
        <label for="scope-trace-color">Couleur</label>
        <input type="color" id="scope-trace-color" value="#64ffda" />
        <div class="scope-modal-actions">
          <button type="button" class="btn" id="scope-trace-cancel">Annuler</button>
          <button type="submit" class="btn primary">Valider</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const $ = (q)=>document.querySelector(q);
    const j = (url,opts={})=>fetch(url,Object.assign({headers:{'Content-Type':'application/json'}},opts));

    /* --------- DMM --------- */
    let dmmHold = false, dmmMode = 'digits';
    const dmmState = {
      config: [],
      snapshot: [],
      holdValue: null,
      holdUnit: null,
      holdNumeric: null,
      holdBinary: null,
      lastNumericValue: null,
      lastBinaryValue: null,
      gaugeRanges: {}
    };

    function getDmmMeta(ioId){
      return dmmState.config.find(ch=>ch.io===ioId) || null;
    }
    function updateDmmHeader(meta){
      const badge = $('#dmm-channel');
      const pill = $('#dmm-mode-pill');
      if(badge) badge.textContent = meta?.label || meta?.io || '—';
      if(pill) pill.textContent = meta?.mode || '—';
    }
    const gaugeGeom = { centerX: 100, centerY: 120, radius: 80, startAngle: -210, endAngle: 30 };
    function parseNumeric(value){
      const n = Number(value);
      return Number.isFinite(n) ? n : null;
    }
    function formatDecimal(value, maxDecimals=4){
      if(!Number.isFinite(value)) return '—';
      let txt = value.toFixed(maxDecimals);
      txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
      return txt;
    }
    function gaugePolar(angleDeg, radius){
      const rad = angleDeg * Math.PI / 180;
      return {
        x: gaugeGeom.centerX + Math.cos(rad) * radius,
        y: gaugeGeom.centerY + Math.sin(rad) * radius,
      };
    }
    function niceCeil(value){
      if(!Number.isFinite(value) || value === 0){ return 1; }
      const magnitude = Math.abs(value);
      const exponent = Math.floor(Math.log10(magnitude));
      const power = Math.pow(10, exponent);
      const scaled = magnitude / power;
      let nice;
      if(scaled <= 1){ nice = 1; }
      else if(scaled <= 2){ nice = 2; }
      else if(scaled <= 5){ nice = 5; }
      else { nice = 10; }
      return nice * power;
    }
    function updateDmmMode(){
      document.querySelectorAll('#card-dmm [data-mode]').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.mode === dmmMode);
      });
      document.querySelectorAll('#card-dmm .dmm-view').forEach(view=>{
        view.classList.toggle('active', view.dataset.view === dmmMode);
      });
    }
    function determineBinaryBitCount(value){
      if(!Number.isFinite(value)) return 8;
      const abs = Math.abs(value);
      if(abs < 16) return 8;
      if(abs < 256) return 8;
      if(abs < 4096) return 12;
      if(abs < 65536) return 16;
      if(abs < 16777216) return 24;
      return 32;
    }
    function updateDmmBinary(value){
      const grid = $('#dmm-binary');
      const meta = $('#dmm-binary-meta');
      const rawEl = $('#dmm-binary-value');
      if(!grid || !meta || !rawEl) return;
      grid.innerHTML = '';
      if(!Number.isFinite(value)){
        grid.innerHTML = '<div class="binary-empty">Aucune donnée</div>';
        rawEl.textContent = '—';
        meta.textContent = 'Valeur non disponible';
        return;
      }
      const rounded = Math.round(value);
      rawEl.textContent = formatDecimal(value, 6);
      const absValue = Math.abs(rounded);
      const bits = determineBinaryBitCount(absValue);
      const binary = absValue.toString(2).padStart(bits, '0');
      for(let i=0; i<bits; i++){
        const bitIndex = bits - 1 - i;
        const bit = binary[bitIndex];
        const cell = document.createElement('div');
        cell.className = 'binary-cell';
        const bitEl = document.createElement('div');
        bitEl.className = 'binary-bit' + (bit === '1' ? ' on' : '');
        bitEl.textContent = bit;
        cell.appendChild(bitEl);
        grid.appendChild(cell);
      }
      meta.textContent = `Bits : ${bits} • Arrondi : ${rounded}`;
    }
    function buildAutoGaugeRange(value){
      const base = Number.isFinite(value) ? value : 0;
      const magnitude = Math.max(Math.abs(base), 1);
      const max = niceCeil(magnitude);
      if(base >= 0){
        return {min: 0, max, explicit: false};
      }
      return {min: -max, max, explicit: false};
    }
    function getGaugeRange(ioId, meta, snapshot, numericValue){
      const candidatesMin = [meta?.min, meta?.minValue, meta?.minimum, meta?.rangeMin, meta?.range?.min, meta?.lower, meta?.low];
      const candidatesMax = [meta?.max, meta?.maxValue, meta?.maximum, meta?.rangeMax, meta?.range?.max, meta?.upper, meta?.high];
      const explicitMin = candidatesMin.map(parseNumeric).find(v=>v!==null);
      const explicitMax = candidatesMax.map(parseNumeric).find(v=>v!==null);
      if(explicitMin != null && explicitMax != null && explicitMin < explicitMax){
        const range = {min: explicitMin, max: explicitMax, explicit: true};
        dmmState.gaugeRanges[ioId] = range;
        return range;
      }
      const previous = dmmState.gaugeRanges[ioId];
      const baseRaw = parseNumeric(snapshot?.raw);
      const baseValue = Number.isFinite(numericValue) ? numericValue : (Number.isFinite(baseRaw) ? baseRaw : null);
      if(previous && previous.explicit){
        return previous;
      }
      if(previous && !Number.isFinite(baseValue)){
        return previous;
      }
      let range = previous;
      if(!range){
        range = buildAutoGaugeRange(baseValue);
      }else if(Number.isFinite(baseValue) && (baseValue < range.min || baseValue > range.max)){
        range = buildAutoGaugeRange(baseValue);
      }
      if(!range){
        range = {min: -1, max: 1, explicit: false};
      }
      if(range.max <= range.min){
        range = {min: range.min - 1, max: range.max + 1, explicit: range.explicit || false};
      }
      dmmState.gaugeRanges[ioId] = range;
      return range;
    }
    function updateGaugeTicks(range){
      const ticksGroup = document.getElementById('dmm-gauge-ticks');
      if(!ticksGroup) return;
      const arc = document.getElementById('dmm-gauge-arc');
      const largeArc = (gaugeGeom.endAngle - gaugeGeom.startAngle) > 180 ? 1 : 0;
      if(arc){
        const start = gaugePolar(gaugeGeom.startAngle, gaugeGeom.radius);
        const end = gaugePolar(gaugeGeom.endAngle, gaugeGeom.radius);
        arc.setAttribute('d', `M ${start.x.toFixed(2)} ${start.y.toFixed(2)} A ${gaugeGeom.radius} ${gaugeGeom.radius} 0 ${largeArc} 1 ${end.x.toFixed(2)} ${end.y.toFixed(2)}`);
      }
      ticksGroup.innerHTML = '';
      const majorCount = 5;
      const minorPerSegment = 4;
      const span = range.max - range.min;
      const labelDecimals = (()=>{
        if(span === 0) return 0;
        const step = span / (majorCount - 1);
        let decimals = 0, scaled = step;
        while(decimals < 3 && scaled > 0 && scaled < 1){ decimals += 1; scaled *= 10; }
        return decimals;
      })();
      const formatLabel = (value)=>{
        if(!Number.isFinite(value)) return '0';
        let txt = value.toFixed(labelDecimals);
        txt = txt.replace(/\.0+$/,'').replace(/(\.\d*?)0+$/,'$1');
        return txt;
      };
      const createLine = (angle, length, className)=>{
        const outer = gaugePolar(angle, gaugeGeom.radius);
        const inner = gaugePolar(angle, gaugeGeom.radius - length);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', inner.x.toFixed(2));
        line.setAttribute('y1', inner.y.toFixed(2));
        line.setAttribute('x2', outer.x.toFixed(2));
        line.setAttribute('y2', outer.y.toFixed(2));
        line.setAttribute('class', className);
        ticksGroup.appendChild(line);
      };
      for(let i=0;i<majorCount;i++){
        const ratio = i/(majorCount-1);
        const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
        createLine(angle, 14, 'gauge-tick');
        const labelPos = gaugePolar(angle, gaugeGeom.radius + 18);
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', labelPos.x.toFixed(2));
        text.setAttribute('y', labelPos.y.toFixed(2));
        text.setAttribute('text-anchor','middle');
        text.setAttribute('dominant-baseline','middle');
        text.setAttribute('class','gauge-label');
        text.textContent = formatLabel(range.min + ratio * span);
        ticksGroup.appendChild(text);
        if(i < majorCount-1){
          for(let m=1;m<=minorPerSegment;m++){
            const minorRatio = (i + m/(minorPerSegment+1)) / (majorCount-1);
            const minorAngle = gaugeGeom.startAngle + minorRatio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
            createLine(minorAngle, 8, 'gauge-tick minor');
          }
        }
      }
    }
    function updateDmmGauge(value, formatted, unit, meta, snapshot, ioId){
      const range = getGaugeRange(ioId, meta, snapshot, value);
      updateGaugeTicks(range);
      const needle = document.getElementById('dmm-gauge-needle');
      if(!needle) return;
      const span = range.max - range.min;
      const effectiveSpan = span === 0 ? 1 : span;
      const fallback = range.min + effectiveSpan / 2;
      const clamped = Number.isFinite(value) ? Math.min(Math.max(value, range.min), range.max) : fallback;
      const ratio = (clamped - range.min) / effectiveSpan;
      const angle = gaugeGeom.startAngle + ratio*(gaugeGeom.endAngle - gaugeGeom.startAngle);
      const tip = gaugePolar(angle, gaugeGeom.radius - 18);
      needle.setAttribute('x1', gaugeGeom.centerX.toFixed(2));
      needle.setAttribute('y1', gaugeGeom.centerY.toFixed(2));
      needle.setAttribute('x2', tip.x.toFixed(2));
      needle.setAttribute('y2', tip.y.toFixed(2));
      needle.setAttribute('opacity', Number.isFinite(value) ? '1' : '0.25');
    }
    function buildFallbackMeta(snapshot){
      return snapshot.map((ch, idx)=>({
        label: `CH${idx+1}`,
        io: ch.id || `CH${idx+1}`,
        mode: 'UDC',
        decimals: 2,
        unit: ch.unit || ''
      }));
    }
    function ensureDmmOptions(snapshot){
      const sel = $('#dmm-select');
      if(!sel) return;
      const previous = sel.value;
      const metaList = dmmState.config.length ? dmmState.config : buildFallbackMeta(snapshot||[]);
      if(!metaList.length){
        sel.innerHTML='';
        updateDmmHeader(null);
        return;
      }
      sel.innerHTML='';
      metaList.forEach(meta=>{
        const opt=document.createElement('option');
        opt.value = meta.io;
        const baseLabel = meta.label || meta.io || '—';
        const detail = meta.io && meta.io !== baseLabel ? ` — ${meta.io}` : '';
        const modeLabel = meta.mode ? ` (${meta.mode})` : '';
        opt.textContent = `${baseLabel}${detail}${modeLabel}`;
        sel.appendChild(opt);
      });
      if(previous && metaList.some(m=>m.io===previous)){
        sel.value = previous;
      }
      if(!sel.value){
        sel.value = metaList[0].io;
      }
      const currentMeta = metaList.find(m=>m.io===sel.value) || metaList[0];
      updateDmmHeader(currentMeta);
    }
    function renderDmm(){
      updateDmmMode();
      const sel = $('#dmm-select');
      if(!sel) return;
      const ioId = sel.value || dmmState.config[0]?.io || dmmState.snapshot[0]?.id || '';
      if(!sel.value && ioId) sel.value = ioId;
      const snapshot = dmmState.snapshot.find(ch=>ch.id===ioId) || dmmState.snapshot[0];
      const meta = getDmmMeta(ioId) || (snapshot ? {
        label: snapshot.id || '—',
        io: snapshot.id || '—',
        mode: 'UDC',
        decimals: 2,
        unit: snapshot.unit || ''
      } : null);
      if(meta) updateDmmHeader(meta);
      const unit = (snapshot?.unit ?? meta?.unit ?? '').toString();
      let formatted = '—.—';
      let numericValue = null;
      if(snapshot && snapshot.value !== undefined && snapshot.value !== null){
        const valueNumber = Number(snapshot.value);
        const decimals = typeof meta?.decimals === 'number' ? meta.decimals : null;
        if(Number.isFinite(valueNumber)){
          numericValue = valueNumber;
          formatted = decimals !== null ? valueNumber.toFixed(decimals) : valueNumber.toString();
        }else{
          formatted = String(snapshot.value);
        }
      }
      dmmState.lastNumericValue = Number.isFinite(numericValue) ? numericValue : null;
      const rawNumber = parseNumeric(snapshot?.raw);
      const binaryValue = Number.isFinite(rawNumber) ? rawNumber : dmmState.lastNumericValue;
      dmmState.lastBinaryValue = Number.isFinite(binaryValue) ? binaryValue : null;
      const displayFormatted = dmmHold && dmmState.holdValue !== null ? dmmState.holdValue : formatted;
      const displayUnit = dmmHold && dmmState.holdUnit !== null ? dmmState.holdUnit : unit;
      $('#dmm-value').textContent = displayFormatted;
      $('#dmm-unit-inline').textContent = displayUnit;
      const effectiveNumeric = dmmHold && dmmState.holdNumeric !== null ? dmmState.holdNumeric : dmmState.lastNumericValue;
      const effectiveBinary = dmmHold && dmmState.holdBinary !== null ? dmmState.holdBinary : dmmState.lastBinaryValue;
      const metaParts = [];
      metaParts.push('Entrée : ' + (meta?.io || snapshot?.id || '—'));
      metaParts.push('Mode : ' + (meta?.mode || '—'));
      metaParts.push('Décimales : ' + (typeof meta?.decimals === 'number' ? meta.decimals : '—'));
      $('#dmm-meta').textContent = metaParts.join(' • ');
      updateDmmBinary(effectiveBinary);
      updateDmmGauge(effectiveNumeric, displayFormatted, displayUnit, meta, snapshot, ioId);
    }
    async function loadDmmConfig(){
      try{
        const r = await j('/api/config?area=dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const cfg = await r.json();
        if(Array.isArray(cfg)){
          dmmState.config = cfg.map((entry, idx)=>{
            const mode = entry.mode || entry.acquisition || 'UDC';
            return {
              label: entry.name || `CH${idx+1}`,
              io: entry.io || `CH${idx+1}`,
              mode,
              decimals: typeof entry.decimals === 'number' ? entry.decimals : 2,
              unit: entry.unit || (mode === 'UDC' ? 'V' : ''),
            };
          });
        }else{
          dmmState.config = [];
        }
      }catch(e){
        console.warn(e);
        dmmState.config = [];
      }
      ensureDmmOptions(dmmState.snapshot);
      renderDmm();
    }
    async function loadDmm(){
      try{
        const r = await j('/api/dmm');
        if(!r.ok) throw new Error('HTTP '+r.status);
        const data = await r.json();
        const channels = Array.isArray(data.channels) ? data.channels : [];
        dmmState.snapshot = channels.map((ch, idx)=>({
          id: ch.id || ch.name || `CH${idx+1}`,
          raw: ch.raw,
          value: ch.value,
          unit: ch.unit
        }));
        const sel = $('#dmm-select');
        if(sel && sel.options.length===0){
          ensureDmmOptions(dmmState.snapshot);
        }
        if(!dmmHold){
          dmmState.holdValue = null;
          dmmState.holdUnit = null;
          dmmState.holdNumeric = null;
          dmmState.holdBinary = null;
        }
        renderDmm();
      }catch(e){
        console.warn(e);
      }
    }
    $('#dmm-hold').addEventListener('click',()=>{
      dmmHold = !dmmHold;
      if(dmmHold){
        dmmState.holdValue = $('#dmm-value').textContent;
        dmmState.holdUnit = $('#dmm-unit-inline').textContent;
        dmmState.holdNumeric = dmmState.lastNumericValue;
        dmmState.holdBinary = dmmState.lastBinaryValue;
      }else{
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      $('#dmm-hold').textContent = dmmHold?'Hold (ON)':'Hold';
      renderDmm();
    });
    $('#dmm-select').addEventListener('change',(e)=>{
      const meta = getDmmMeta(e.target.value) || dmmState.config[0] || null;
      updateDmmHeader(meta);
      if(dmmHold){
        dmmState.holdValue = null;
        dmmState.holdUnit = null;
        dmmState.holdNumeric = null;
        dmmState.holdBinary = null;
      }
      renderDmm();
    });
    document.querySelectorAll('#card-dmm [data-mode]').forEach(b=>b.addEventListener('click',()=>{
      dmmMode = b.dataset.mode;
      updateDmmMode();
      renderDmm();
    }));
    updateDmmMode();

    /* --------- FUNCGEN --------- */
    async function loadIOForFunc(){
      const sel = $('#func-target');
      if(!sel) return;
      let ids = [];
      try{
        const resp = await j('/api/io/snapshot');
        if(resp.ok){
          const payload = await resp.json();
          if(payload && Array.isArray(payload.channels)){
            ids = payload.channels.map(ch=>ch && typeof ch.id==='string'? ch.id : null).filter(Boolean);
          }
        }
      }catch(err){
        console.warn(err);
      }
      if(!ids.length){
        try{
          const fallback = await fetch('io.json',{cache:'no-cache'});
          if(fallback.ok){
            const arr = await fallback.json();
            if(Array.isArray(arr)){
              ids = arr.map(entry=>entry && typeof entry.id==='string'? entry.id : null).filter(Boolean);
            }
          }
        }catch(err){
          console.warn(err);
        }
      }
      sel.innerHTML='';
      if(ids.length){
        ids.forEach(id=>{
          const opt=document.createElement('option');
          opt.value=id;
          opt.textContent=id;
          sel.appendChild(opt);
        });
        sel.value = ids[0];
      }else{
        const opt=document.createElement('option');
        opt.value='';
        opt.textContent='—';
        sel.appendChild(opt);
      }
      const cfg = await (async()=>{
        try{
          const cfgResp = await j('/api/config?area=funcgen');
          if(cfgResp.ok){
            return await cfgResp.json();
          }
        }catch(err){
          console.warn(err);
        }
        try{
          const fallback = await fetch('funcgen.json',{cache:'no-cache'});
          if(fallback.ok){
            return await fallback.json();
          }
        }catch(err){
          console.warn(err);
        }
        return null;
      })();
      if(cfg && typeof cfg==='object'){
        const ampInput = $('#func-amp');
        const offInput = $('#func-off');
        const freqInput = $('#func-freq');
        const waveSelect = $('#func-wave');
        if(ampInput) ampInput.value = typeof cfg.amp_pct === 'number' ? cfg.amp_pct : (ampInput.value||50);
        if(offInput) offInput.value = typeof cfg.offset_pct === 'number' ? cfg.offset_pct : (offInput.value||0);
        if(freqInput) freqInput.value = typeof cfg.freq === 'number' ? cfg.freq : (freqInput.value||50);
        if(waveSelect) waveSelect.value = typeof cfg.type === 'string' ? cfg.type : (waveSelect.value||'sine');
        if(typeof cfg.target === 'string' && ids.includes(cfg.target)){
          sel.value = cfg.target;
        }
      }
      $('#func-target-pill').textContent = 'cible : ' + (sel.value||'—');
    }
    async function applyFunc(){
      const target = $('#func-target') ? $('#func-target').value : '';
      const freqVal = parseFloat($('#func-freq') ? $('#func-freq').value : '0');
      const ampVal = parseFloat($('#func-amp') ? $('#func-amp').value : '0');
      const offsetVal = parseFloat($('#func-off') ? $('#func-off').value : '0');
      const waveVal = $('#func-wave') ? $('#func-wave').value : 'sine';
      const payload = {
        type: waveVal,
        freq: Number.isFinite(freqVal) ? freqVal : 0,
        amp_pct: Number.isFinite(ampVal) ? ampVal : 0,
        offset_pct: Number.isFinite(offsetVal) ? offsetVal : 0,
        enabled: true
      };
      if(target) payload.target = target;
      try{
        const r = await j('/api/funcgen',{method:'POST', body: JSON.stringify(payload)});
        let ok = null;
        if(r.ok){
          ok = await r.json().catch(()=>({}));
        }
        const success = r.ok && ok && (ok.ok === true || ok.success === true || ok.status === 'ok');
        $('#func-status').textContent = success ? 'Paramètres appliqués.' : 'Erreur d’application.';
        $('#func-target-pill').textContent = 'cible : ' + (target||'—');
      }catch(e){
        console.warn(e);
        $('#func-status').textContent = 'Erreur réseau.';
        $('#func-target-pill').textContent = 'cible : ' + (target||'—');
      }
    }
    $('#func-apply').addEventListener('click', applyFunc);

    /* --------- SCOPE (aperçu 1 canal) --------- */
    const scopeMeta = $('#scope-meta');
    const scopeTraceInfo = $('#scope-trace-info');
    const scopeScalePopup = $('#scope-scale-popup');
    const scopeRefPopup = $('#scope-ref-popup');
    const scopeTimebaseSelect = $('#scope-timebase-select');
    const scopeVoltSelect = $('#scope-volt-select');
    const scopeTimebaseStatus = $('#scope-timebase-status');
    const scopeTraceStatus = $('#scope-trace-status');
    const scopeTimebasePill = $('#scope-timebase');
    const scopeVoltageLabel = $('#scope-voltage-scale');
    const scopeTimeLabel = $('#scope-time-scale');
    const scopeTracePath = $('#scope-trace-path');
    const scopeTraceModal = $('#scope-trace-modal');
    const scopeTraceForm = $('#scope-trace-form');
    const scopeTraceChannelSelect = $('#scope-trace-channel');
    const scopeTraceColor = $('#scope-trace-color');
    const scopeTraceOpen = $('#scope-trace-open');
    const scopeTraceCancel = $('#scope-trace-cancel');
    const scopeVoltsPerDivValues = [0.01,0.02,0.05,0.1,0.2,0.5,1,2,5,10];
    const scopeTimebaseValues = [0.05,0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,2000];
    const scopeColorPalette = ['#64ffda','#ffd74d','#3dff70','#ff5f85','#00d2ff','#b19cff'];
    const scopeGridSize = {width:500, height:500};

    let scopeSelectedChannel = null;
    let scopeChannelColors = {};
    let scopeLatestSamples = [];
    let scopeChannelsData = {};
    let scopeLastScopeData = null;
    let scopeUsingFallback = false;
    let scopeNextScopeApiRetry = 0;
    let scopeFallbackCache = null;
    let scopeApiUnavailable = false;

    function formatVolt(value, suffix=''){
      if(value === null || value === undefined || Number.isNaN(value)) return '—';
      const abs = Math.abs(value);
      if(abs >= 1000){ return `${(value/1000).toFixed(2)} kV${suffix}`; }
      if(abs >= 1){ return `${value.toFixed(abs >= 10 ? 1 : 2)} V${suffix}`; }
      if(abs >= 0.001){ return `${(value*1000).toFixed(abs >= 0.01 ? 1 : 2)} mV${suffix}`; }
      return `${(value*1e6).toFixed(1)} µV${suffix}`;
    }

    function formatTimebase(ms){
      if(ms === null || ms === undefined || Number.isNaN(ms)) return '—';
      if(ms >= 1000){
        const value = ms/1000;
        const digits = value >= 10 ? 0 : 2;
        return `${value.toFixed(digits)} s/div`;
      }
      if(ms >= 1){
        const digits = ms >= 10 ? 0 : 2;
        return `${ms.toFixed(digits)} ms/div`;
      }
      const us = ms*1000;
      const digits = us >= 10 ? 0 : 2;
      return `${us.toFixed(digits)} µs/div`;
    }

    function formatVoltPerDiv(v){
      if(v === null || v === undefined || Number.isNaN(v)) return '—';
      if(v >= 1){
        const digits = v >= 10 ? 0 : 1;
        return `${v.toFixed(digits)} V/div`;
      }
      if(v >= 0.001){
        const mv = v*1000;
        const digits = mv >= 10 ? 0 : 1;
        return `${mv.toFixed(digits)} mV/div`;
      }
      return `${(v*1e6).toFixed(0)} µV/div`;
    }

    function populateSelect(select, values, formatter){
      if(!select) return;
      select.innerHTML = '';
      values.forEach((val)=>{
        const opt = document.createElement('option');
        opt.value = String(val);
        opt.textContent = formatter(val);
        select.appendChild(opt);
      });
    }

    populateSelect(scopeTimebaseSelect, scopeTimebaseValues, (ms)=>formatTimebase(ms));
    populateSelect(scopeVoltSelect, scopeVoltsPerDivValues, (v)=>formatVoltPerDiv(v));

    function updateTimebaseDisplay(ms){
      const label = formatTimebase(ms);
      if(scopeTimebasePill){ scopeTimebasePill.textContent = label; }
      if(scopeTimeLabel){ scopeTimeLabel.textContent = label === '—' ? '—' : label.replace('/div',''); }
    }

    function updateVoltDisplay(v){
      const label = formatVoltPerDiv(v);
      if(scopeVoltageLabel){ scopeVoltageLabel.textContent = label; }
      if(scopeScalePopup){ scopeScalePopup.setAttribute('data-tooltip', label); }
    }

    function findClosestIndex(values, target){
      if(!values.length || typeof target !== 'number' || !isFinite(target)) return 0;
      let bestIdx = 0;
      let bestDiff = Math.abs(values[0]-target);
      for(let i=1;i<values.length;i++){
        const diff = Math.abs(values[i]-target);
        if(diff < bestDiff){
          bestDiff = diff;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    function getCurrentTimebase(){
      if(!scopeTimebaseSelect) return null;
      return parseFloat(scopeTimebaseSelect.value);
    }

    function getCurrentVoltPerDiv(){
      if(!scopeVoltSelect) return scopeVoltsPerDivValues[scopeVoltsPerDivValues.length-1];
      return parseFloat(scopeVoltSelect.value);
    }

    function plot(samples, color, voltsPerDiv){
      if(!scopeTracePath){ return null; }
      if(!samples || samples.length < 2){
        scopeTracePath.setAttribute('d','');
        return null;
      }
      const width = scopeGridSize.width;
      const height = scopeGridSize.height;
      const verticalDivs = 8;
      const verticalPixelsPerDiv = height / verticalDivs;
      const clamp = (val, min, max)=>Math.min(Math.max(val, min), max);
      const len = samples.length;
      let min = samples[0];
      let max = samples[0];
      let sum = 0;
      let d = '';
      for(let i=0;i<len;i++){
        const v = samples[i];
        if(v < min) min = v;
        if(v > max) max = v;
        sum += v;
        const x = (i/(len-1)) * width;
        const y = height/2 - (v/voltsPerDiv) * verticalPixelsPerDiv;
        const yClamped = clamp(y, 0, height);
        d += `${i === 0 ? 'M' : 'L'}${x.toFixed(2)},${yClamped.toFixed(2)} `;
      }
      scopeTracePath.setAttribute('d', d.trim());
      scopeTracePath.setAttribute('stroke', color || '#64ffda');
      return {min, max, mean: sum/len, voltsPerDiv};
    }

    function updateScopeDetails(meta, count){
      let lines = '—';
      if(meta){
        lines = [
          `Points : ${count}`,
          `Min : ${formatVolt(meta.min)}`,
          `Max : ${formatVolt(meta.max)}`,
          `Moyenne : ${formatVolt(meta.mean)}`,
          meta.voltsPerDiv ? `1 div = ${formatVolt(meta.voltsPerDiv)}` : null
        ].filter(Boolean).join('\n');
      }else if(count){
        lines = `Points : ${count}`;
      }
      if(scopeMeta){ scopeMeta.setAttribute('data-tooltip', lines || '—'); }

      const traceLines = meta ? [
        `Vpp : ${formatVolt(meta.max - meta.min)}`,
        meta.voltsPerDiv ? `Échelle : ${formatVolt(meta.voltsPerDiv, '/div')}` : null
      ].filter(Boolean).join('\n') : '—';
      if(scopeTraceInfo){ scopeTraceInfo.setAttribute('data-tooltip', traceLines || '—'); }

      if(scopeScalePopup){
        if(meta && meta.voltsPerDiv){
          scopeScalePopup.setAttribute('data-tooltip', `1 div ≈ ${formatVolt(meta.voltsPerDiv)}`);
        }else{
          scopeScalePopup.setAttribute('data-tooltip', formatVoltPerDiv(getCurrentVoltPerDiv()));
        }
      }
      if(scopeRefPopup){
        scopeRefPopup.setAttribute('data-tooltip', '0 V (réf. lecture)\nLigne rouge pointillée = niveau de référence.');
      }
    }

    async function applyScopeTimebase(ms){
      if(!scopeTimebaseSelect) return;
      updateTimebaseDisplay(ms);
      if(scopeTimebaseStatus){ scopeTimebaseStatus.textContent = 'Envoi…'; }
      try{
        const r = await j('/api/scope/timebase',{method:'POST', body: JSON.stringify({ms_per_div: ms})});
        if(!r.ok){
          if(r.status === 404){
            scopeApiUnavailable = true;
            scopeNextScopeApiRetry = Number.POSITIVE_INFINITY;
            if(scopeTimebaseStatus){ scopeTimebaseStatus.textContent = 'Réglage non supporté.'; }
            setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 2500);
            return;
          }
          throw new Error('bad');
        }
        scopeTimebaseStatus.textContent = 'Synchronisé';
        setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 1500);
      }catch(e){
        console.warn(e);
        if(scopeTimebaseStatus){ scopeTimebaseStatus.textContent = 'Erreur de réglage.'; }
        setTimeout(()=>{ if(scopeTimebaseStatus) scopeTimebaseStatus.textContent=''; }, 2000);
      }
    }

    function renderScope(){
      const voltsPerDiv = getCurrentVoltPerDiv();
      updateVoltDisplay(voltsPerDiv);
      if(!scopeSelectedChannel){
        if(scopeTracePath){ scopeTracePath.setAttribute('d',''); }
        updateScopeDetails(null, 0);
        return;
      }
      const color = scopeChannelColors[scopeSelectedChannel] || scopeColorPalette[0];
      const meta = plot(scopeLatestSamples, color, voltsPerDiv);
      updateScopeDetails(meta, scopeLatestSamples ? scopeLatestSamples.length : 0);
    }

    function setScopeChannelList(channels){
      if(!scopeTraceChannelSelect) return;
      const previouslySelected = scopeSelectedChannel;
      scopeTraceChannelSelect.innerHTML = '';
      channels.forEach((name, idx)=>{
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        if(name === previouslySelected || (!previouslySelected && idx === 0)){
          opt.selected = true;
        }
        scopeTraceChannelSelect.appendChild(opt);
        if(!scopeChannelColors[name]){
          scopeChannelColors[name] = scopeColorPalette[idx % scopeColorPalette.length];
        }
      });
      if(!channels.includes(previouslySelected)){
        scopeSelectedChannel = channels[0] || null;
      }
      if(scopeTraceColor && scopeSelectedChannel){
        scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel];
      }
    }

    function openTraceModal(){
      if(!scopeTraceModal) return;
      scopeTraceModal.classList.remove('hidden');
      scopeTraceModal.setAttribute('aria-hidden','false');
      if(scopeTraceChannelSelect && scopeSelectedChannel){
        scopeTraceChannelSelect.value = scopeSelectedChannel;
      }
      if(scopeTraceColor && scopeSelectedChannel){
        scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel] || scopeTraceColor.value;
      }
      const targetFocus = scopeTraceChannelSelect || scopeTraceModal.querySelector('input, select, button');
      if(targetFocus){
        setTimeout(()=>{ targetFocus.focus(); }, 0);
      }
    }

    function closeTraceModal(){
      if(!scopeTraceModal) return;
      if(scopeTraceModal.contains(document.activeElement)){
        if(scopeTraceOpen){
          scopeTraceOpen.focus();
        }else if(document.activeElement && typeof document.activeElement.blur === 'function'){
          document.activeElement.blur();
        }
      }
      scopeTraceModal.classList.add('hidden');
      scopeTraceModal.setAttribute('aria-hidden','true');
    }

    if(scopeTraceOpen){
      scopeTraceOpen.addEventListener('click', ()=>{
        openTraceModal();
      });
    }
    if(scopeTraceCancel){
      scopeTraceCancel.addEventListener('click', ()=>{
        closeTraceModal();
      });
    }
    if(scopeTraceModal){
      scopeTraceModal.addEventListener('click', (ev)=>{
        if(ev.target === scopeTraceModal){
          closeTraceModal();
        }
      });
    }
    if(scopeTraceChannelSelect && scopeTraceColor){
      scopeTraceChannelSelect.addEventListener('change', ()=>{
        const channel = scopeTraceChannelSelect.value;
        scopeTraceColor.value = scopeChannelColors[channel] || scopeColorPalette[0];
      });
    }
    document.addEventListener('keydown', (ev)=>{
      if(ev.key === 'Escape' && scopeTraceModal && !scopeTraceModal.classList.contains('hidden')){
        closeTraceModal();
      }
    });
    if(scopeTraceForm){
      scopeTraceForm.addEventListener('submit', (ev)=>{
        ev.preventDefault();
        const channel = scopeTraceChannelSelect ? scopeTraceChannelSelect.value : null;
        const color = scopeTraceColor ? scopeTraceColor.value : '#64ffda';
        if(channel){
          scopeSelectedChannel = channel;
          scopeChannelColors[channel] = color;
          scopeLatestSamples = scopeChannelsData[channel] || [];
          $('#scope-chan').textContent = channel;
          renderScope();
          if(scopeTraceStatus){
            scopeTraceStatus.textContent = `Trace sur ${channel}`;
            setTimeout(()=>{ if(scopeTraceStatus) scopeTraceStatus.textContent=''; }, 1800);
          }
        }
        closeTraceModal();
      });
    }
    if(scopeTraceColor){
      scopeTraceColor.addEventListener('input', ()=>{
        if(scopeTraceChannelSelect){
          const channel = scopeTraceChannelSelect.value;
          scopeChannelColors[channel] = scopeTraceColor.value;
        }
      });
    }

    if(scopeTimebaseSelect){
      scopeTimebaseSelect.addEventListener('change', ()=>{
        const ms = getCurrentTimebase();
        applyScopeTimebase(ms);
        updateTimebaseDisplay(ms);
      });
      scopeTimebaseSelect.value = String(scopeTimebaseValues[6]);
      updateTimebaseDisplay(getCurrentTimebase());
    }

    if(scopeVoltSelect){
      scopeVoltSelect.addEventListener('change', ()=>{
        updateVoltDisplay(getCurrentVoltPerDiv());
        renderScope();
      });
      scopeVoltSelect.value = String(scopeVoltsPerDivValues[5]);
      updateVoltDisplay(getCurrentVoltPerDiv());
    }

    async function loadScopeFallback(){
      try{
        if(scopeFallbackCache){
          return Object.assign({}, scopeFallbackCache, {
            channels: Object.fromEntries(Object.entries(scopeFallbackCache.channels).map(([name, samples])=>[name, Array.from(samples || [])]))
          });
        }
        const r = await fetch('scope.json', {cache: 'no-cache'});
        if(!r.ok) return null;
        const cfg = await r.json();
        let channels = {};
        if(cfg.channels && typeof cfg.channels === 'object'){
          Object.entries(cfg.channels).forEach(([name, samples])=>{
            channels[name] = Array.isArray(samples) ? samples : new Array(200).fill(0);
          });
        }else{
          const channelName = cfg.channel || 'CH1';
          const samples = Array.isArray(cfg.samples) ? cfg.samples : new Array(200).fill(0);
          channels[channelName] = samples;
        }
        const result = {
          channels,
          timebase_ms_per_div: typeof cfg.timebase_ms_per_div === 'number' ? cfg.timebase_ms_per_div : (typeof cfg.timebase === 'number' ? cfg.timebase : null),
          volts_per_div: typeof cfg.volts_per_div === 'number' ? cfg.volts_per_div : (typeof cfg.vdiv === 'number' ? cfg.vdiv : null)
        };
        scopeFallbackCache = {
          channels: Object.fromEntries(Object.entries(channels).map(([name, samples])=>[name, Array.from(samples || [])])),
          timebase_ms_per_div: result.timebase_ms_per_div,
          volts_per_div: result.volts_per_div
        };
        return result;
      }catch(err){
        return null;
      }
    }

    function applyScopeData(data){
      const rawChannels = data.channels && typeof data.channels === 'object' ? data.channels : {};
      const normalizedChannels = {};
      Object.entries(rawChannels).forEach(([name, samples])=>{
        if(Array.isArray(samples)){
          normalizedChannels[name] = samples.slice();
        }else if(samples && typeof samples[Symbol.iterator] === 'function'){
          normalizedChannels[name] = Array.from(samples);
        }else{
          normalizedChannels[name] = [];
        }
      });
      scopeLastScopeData = Object.assign({}, data, {channels: normalizedChannels});
      scopeChannelsData = scopeLastScopeData.channels;
      const chNames = Object.keys(scopeChannelsData);
      if(chNames.length){
        setScopeChannelList(chNames);
        if(!scopeSelectedChannel){
          scopeSelectedChannel = chNames[0];
        }
        $('#scope-chan').textContent = scopeSelectedChannel || '—';
        scopeLatestSamples = scopeChannelsData[scopeSelectedChannel] || [];
        if(scopeTraceColor && scopeSelectedChannel){
          scopeTraceColor.value = scopeChannelColors[scopeSelectedChannel];
        }
      }else{
        scopeSelectedChannel = null;
        scopeLatestSamples = [];
        $('#scope-chan').textContent = '—';
      }

      const timebase = typeof data.timebase_ms_per_div === 'number' ? data.timebase_ms_per_div : null;
      if(scopeTimebaseSelect && timebase !== null){
        const idx = findClosestIndex(scopeTimebaseValues, timebase);
        scopeTimebaseSelect.value = String(scopeTimebaseValues[idx]);
      }
      const currentTimebase = getCurrentTimebase();
      updateTimebaseDisplay(currentTimebase);
      if(scopeTimebaseStatus){
        scopeTimebaseStatus.textContent = scopeTimebaseStatus.textContent === 'Synchronisé' ? scopeTimebaseStatus.textContent : '';
      }

      if(scopeVoltSelect && typeof data.volts_per_div === 'number'){
        const idx = findClosestIndex(scopeVoltsPerDivValues, data.volts_per_div);
        scopeVoltSelect.value = String(scopeVoltsPerDivValues[idx]);
        updateVoltDisplay(getCurrentVoltPerDiv());
      }

      renderScope();
    }

    async function loadScope(){
      const now = Date.now();
      const shouldTryApi = !scopeApiUnavailable && (!scopeUsingFallback || now >= scopeNextScopeApiRetry);
      let data = null;

      if(shouldTryApi){
        try{
          const r = await j('/api/scope');
          if(!r.ok){
            if(r.status === 404){
              scopeApiUnavailable = true;
              scopeUsingFallback = true;
              scopeNextScopeApiRetry = Number.POSITIVE_INFINITY;
            }else{
              scopeUsingFallback = true;
              scopeNextScopeApiRetry = Date.now() + 5000;
            }
          }else{
            data = await r.json();
            scopeUsingFallback = false;
            scopeFallbackCache = null;
            scopeApiUnavailable = false;
          }
        }catch(e){
          console.warn(e);
          scopeUsingFallback = true;
          if(!scopeApiUnavailable){
            scopeNextScopeApiRetry = Date.now() + 5000;
          }
        }
      }

      if(!data){
        if(scopeUsingFallback && scopeLastScopeData){
          applyScopeData(scopeLastScopeData);
          return;
        }
        const fallback = await loadScopeFallback();
        if(fallback){
          data = fallback;
          scopeUsingFallback = true;
          scopeNextScopeApiRetry = Date.now() + 5000;
        }else{
          scopeSelectedChannel = null;
          scopeLatestSamples = [];
          scopeChannelsData = {};
          scopeLastScopeData = null;
          scopeUsingFallback = false;
          $('#scope-chan').textContent = '—';
          updateScopeDetails(null, 0);
          updateTimebaseDisplay(null);
          return;
        }
      }

      applyScopeData(data);
    }
    /* --------- MATH EDITOR --------- */
    async function loadMath(){
      try{
        const r = await j('/api/config?area=math');
        if(r.ok){
          const cfg = await r.json();
          const expressions = cfg && Array.isArray(cfg.expressions) ? cfg.expressions : [];
          const expr = expressions.length ? expressions.join('\n') : '';
          $('#math-text').value = expr;
          $('#math-status').textContent='Config chargée.';
          return;
        }
      }catch(e){
        console.warn(e);
      }
      try{
        const fallback = await fetch('math.json',{cache:'no-cache'});
        if(fallback.ok){
          const cfg = await fallback.json();
          const expressions = Array.isArray(cfg)
            ? cfg
            : (cfg && Array.isArray(cfg.expressions) ? cfg.expressions : []);
          const expr = expressions.length ? expressions.join('\n') : '';
          $('#math-text').value = expr;
          $('#math-status').textContent='Config locale chargée.';
          return;
        }
      }catch(e){
        console.warn(e);
      }
      $('#math-status').textContent='Impossible de charger la config.';
    }
    async function saveMath(){
      const lines = $('#math-text').value.split('\n').map(s=>s.trim()).filter(Boolean);
      const body = JSON.stringify({expressions: lines});
      try{
        const r = await j('/api/config?area=math',{method:'PUT', body});
        $('#math-status').textContent = r.ok ? 'Enregistré.' : 'Erreur d’enregistrement.';
      }catch(e){
        console.warn(e);
        $('#math-status').textContent='Erreur réseau.';
      }
    }
    $('#math-load').addEventListener('click', loadMath);
    $('#math-save').addEventListener('click', saveMath);

    /* --------- Boot --------- */
    async function boot(){
      await loadDmmConfig();
      await loadDmm();
      loadIOForFunc();
      loadMath();
      loadScope();
      setInterval(()=>{ loadDmm(); }, 2000);   // DMM 2 Hz
      setInterval(()=>{ loadScope(); }, 150);  // Scope ~6-7 fps (léger)
    }
    document.addEventListener('DOMContentLoaded', ()=>{ boot(); });
  </script>
</body>
</html>
